<!DOCTYPE html>
<html lang='en'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>kubelet æ˜¯å¦‚ä½•å¯åŠ¨ POD - sn0rt's blog</title>

  
    <meta name="description" content="å‡ºäº containerd ä¸Šçº¿éœ€æ±‚ï¼Œèµ°è¯»çº¿ä¸Šç»„ä»¶çš„ä»£ç ç¡®å®šç°æœ‰ POD åˆ›å»ºæµç¨‹ï¼Œä¸»è¦å…³æ³¨çš„æ˜¯ç»„ä»¶ä¹‹é—´æ˜¯å¦‚ä½•äº¤äº’æ²Ÿé€šçš„è¿›è¡Œ POD åˆ›å»ºçš„ã€‚ kubelet-create-pod      kubelet kubelet å¦‚ä½•åˆ›å»º POD   dockershim dockerd æ¥å£ &#x2F;containers&#x2F;{name:.*}&#x2F;start   containerd">
<meta property="og:type" content="article">
<meta property="og:title" content="kubelet æ˜¯å¦‚ä½•å¯åŠ¨ POD">
<meta property="og:url" content="http://sn0rt.github.io/2020/12/15/kubelet-create-pod/index.html">
<meta property="og:site_name" content="sn0rt&#39;s blog">
<meta property="og:description" content="å‡ºäº containerd ä¸Šçº¿éœ€æ±‚ï¼Œèµ°è¯»çº¿ä¸Šç»„ä»¶çš„ä»£ç ç¡®å®šç°æœ‰ POD åˆ›å»ºæµç¨‹ï¼Œä¸»è¦å…³æ³¨çš„æ˜¯ç»„ä»¶ä¹‹é—´æ˜¯å¦‚ä½•äº¤äº’æ²Ÿé€šçš„è¿›è¡Œ POD åˆ›å»ºçš„ã€‚ kubelet-create-pod      kubelet kubelet å¦‚ä½•åˆ›å»º POD   dockershim dockerd æ¥å£ &#x2F;containers&#x2F;{name:.*}&#x2F;start   containerd">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://sn0rt.github.io/media/pic/kubelet-create-pod-with-docker.jpg">
<meta property="article:published_time" content="2020-12-14T16:00:00.000Z">
<meta property="article:modified_time" content="2023-05-14T05:02:02.782Z">
<meta property="article:author" content="Sn0rt">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://sn0rt.github.io/media/pic/kubelet-create-pod-with-docker.jpg">
  
  
  
  <meta name="keywords" content="k8s">

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="/favicon.ico">
  

  

  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/favicon.ico" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">sn0rt's blog</div><div class="sub cap">4Fun</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">Blog</a><a class="nav-item" href="/wiki/">Wiki</a><a class="nav-item" href="/friends/">links</a><a class="nav-item" href="/about/">about</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="æ–‡ç« æœç´¢"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">No Results!</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">kubelet æ˜¯å¦‚ä½•å¯åŠ¨ POD</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#kubelet-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA-POD"><span class="toc-text">kubelet å¦‚ä½•åˆ›å»º POD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x2F-containers-x2F-name-x2F-start"><span class="toc-text">&#x2F;containers&#x2F;{name:.*}&#x2F;start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ContainersServer-Create-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">ContainersServer.Create æ–¹æ³•çš„å®ç°</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TasksServer-Create-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">TasksServer.Create æ–¹æ³•çš„å®ç°</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TasksServer-Start-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">TasksServer.Start æ–¹æ³•çš„å®ç°</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#contained-shim-create"><span class="toc-text">contained-shim create</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#contained-shim-start"><span class="toc-text">contained-shim start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#run-create-%E2%80%93bundle"><span class="toc-text">run create â€“bundle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runc-init"><span class="toc-text">runc init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runc-start"><span class="toc-text">runc start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reference"><span class="toc-text">reference</span></a></li></ol></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      



<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a><span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a></div><div id="post-meta">Posted on&nbsp;<time datetime="2020-12-14T16:00:00.000Z">2020-12-15</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>kubelet æ˜¯å¦‚ä½•å¯åŠ¨ POD</span></h1>
<p>å‡ºäº <code>containerd</code> ä¸Šçº¿éœ€æ±‚ï¼Œèµ°è¯»çº¿ä¸Šç»„ä»¶çš„ä»£ç ç¡®å®šç°æœ‰ <code>POD</code> åˆ›å»ºæµç¨‹ï¼Œä¸»è¦å…³æ³¨çš„æ˜¯ç»„ä»¶ä¹‹é—´æ˜¯å¦‚ä½•äº¤äº’æ²Ÿé€šçš„è¿›è¡Œ <code>POD</code> åˆ›å»ºçš„ã€‚</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/media/pic/kubelet-create-pod-with-docker.jpg" alt="kubelet-create-pod"></div><div class="image-meta"><span class="image-caption center">kubelet-create-pod</span></div></div>

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

<ul>
<li><a href="#kubelet">kubelet</a><ul>
<li><a href="#kubelet-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA-pod">kubelet å¦‚ä½•åˆ›å»º POD</a></li>
</ul>
</li>
<li><a href="#dockershim">dockershim</a></li>
<li><a href="#dockerd-%E6%8E%A5%E5%8F%A3">dockerd æ¥å£</a><ul>
<li><a href="#containersnamestart">&#x2F;containers&#x2F;{name:.*}&#x2F;start</a></li>
</ul>
</li>
<li><a href="#containerd">containerd</a><ul>
<li><a href="#containersservercreate-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">ContainersServer.Create æ–¹æ³•çš„å®ç°</a></li>
<li><a href="#tasksservercreate-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">TasksServer.Create æ–¹æ³•çš„å®ç°</a></li>
<li><a href="#tasksserverstart-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">TasksServer.Start æ–¹æ³•çš„å®ç°</a></li>
</ul>
</li>
<li><a href="#containerd-shim-%E7%9A%84%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C">containerd-shim çš„å¦‚ä½•å·¥ä½œ</a><ul>
<li><a href="#contained-shim-create">contained-shim create</a></li>
<li><a href="#contained-shim-start">contained-shim start</a></li>
</ul>
</li>
<li><a href="#runc">runc</a><ul>
<li><a href="#run-create---bundle">run create â€“bundle</a></li>
<li><a href="#runc-init">runc init</a></li>
<li><a href="#runc-start">runc start</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<h1 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h1><p>çº¿ä¸Šä¸»è¦æœ‰ä¸¤ä¸ªç‰ˆæœ¬çš„ <code>k8s</code>ï¼Œè¿™æ¬¡ä»£ç èµ°è¯»ä¸»è¦å…³æ³¨ <code>1.17.4</code> ç‰ˆæœ¬ã€‚è§‚å¯Ÿ <code>kubelet</code> åˆå§‹åŒ–æµç¨‹å¯ä»¥çœ‹åˆ°ä¸è¿è¡Œæ—¶ç›¸å…³å‚æ•°å¦‚ä¸‹<code>--container-runtime=</code> å‚æ•°ä¸º <code>docker</code>ã€‚æŸ¥çœ‹å¯åŠ¨æ—¥å¿—ï¼Œå¯ä»¥çœ‹åˆ° <code>kubelet</code> å¯åŠ¨äº†ä¸€ä¸ª <code>dockershim</code> çš„æœåŠ¡ï¼Œè¿™ä¸ªæœåŠ¡å°±æ˜¯ç›®å‰è°ƒç ”çš„ä¸€ä¸ªå…³é”®ç‚¹ï¼Œå› ä¸ºç¤¾åŒºåœ¨ <code>1.20</code> ç‰ˆæœ¬ä¸­å‡†å¤‡å¼ƒç”¨ <code>dockershim</code> äº†ã€‚</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I1215 16:38:23.359299 2052022 docker_service.go:274] Setting cgroupDriver to cgroupfs</span><br><span class="line">I1215 16:38:23.359435 2052022 kubelet.go:642] Starting the GRPC server for the docker CRI shim.</span><br><span class="line">I1215 16:38:23.359456 2052022 docker_server.go:59] Start dockershim grpc server</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>è°ƒç ”ç¤¾åŒºæ–‡æ¡£å‘ç°ï¼Œ<code>dockershim</code> ä¹‹æ‰€ä»¥è¢«æå‡ºæ˜¯ä¸ºäº†è§£å†³ <code>kubernetes</code> å¼€å‘è€…é¢ä¸´å¤šä¸ª<code>runtime</code>éƒ½è¦æ¥å…¥<code>kubernetes</code>å¯¼è‡´è°ƒç”¨è¿è¡Œæ—¶çš„ç›¸å…³ä»£ç æ¥å£ä¸ç¨³å®šçš„é—®é¢˜ã€‚<br>å¼€å‘è€…å¼•å…¥ä¸€ä¸ªæŠ½è±¡å±‚å¯¹ä¸Šå±è”½åº•å±‚çš„<code>runtime</code>å®ç°å·®å¼‚ï¼Œè¿™ä¸ªæŠ½è±¡å±‚ç§°ä¸º<a href="%5Bhttps://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/%5D(https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/)">CRI</a>, è¿™é‡Œçš„ <code>dockershim</code> å°±æ˜¯åŸºäº <code>docker</code> äºŒæ¬¡å°è£…çš„ä¸€ä¸ª <code>CRI</code> å®ç°ã€‚<br><code>shim</code> è¿™ä¸ªå•è¯çš„ç”±æ¥å¯ä»¥ä» wiki ä¸ŠæŸ¥åˆ° <code>an application compatibility workaround</code>ã€‚</p>
<h2 id="kubelet-å¦‚ä½•åˆ›å»º-POD"><a href="#kubelet-å¦‚ä½•åˆ›å»º-POD" class="headerlink" title="kubelet å¦‚ä½•åˆ›å»º POD"></a>kubelet å¦‚ä½•åˆ›å»º POD</h2><p>åœ¨ <code>POD</code> åˆ›å»ºè¿‡ç¨‹ä¸­é¦–å…ˆéœ€è¦å‡†å¤‡ä¸€ä¸ªè¢«æˆä¸º <code>sandbox</code> çš„å®¹å™¨ç”¨æ¥åˆå§‹åŒ–è®¾ç½®åŸºç¡€ç½‘ç»œç­‰ç­‰è¯¸å¤šäº‹å®œã€‚èµ°è¯» <code>CRI</code> æ¥å£å‘ç°åˆ›å»º <code>Sandbox</code> è¿™ä¸ªæ˜¯ <code>CRI</code> çš„ä¸€ä¸ªé‡è¦åŠŸèƒ½ã€‚</p>
<p>åŸºäº <code>kubelet</code> çš„æºç åˆ†æï¼Œé€šè¿‡æºç åˆ†æäº†è§£åˆ° <code>syncLoopIteration</code> -&gt; <code>HandlePodAdditions</code> -&gt; <code>dispatchWork</code>-&gt;<code>UpdatePod</code>-&gt; <code>managePodLoop</code> è¿™æ ·çš„ä¸€ä¸ªå‡½æ•°è°ƒç”¨å…³ç³»ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span></span> managePodLoop(podUpdates &lt;-<span class="keyword">chan</span> UpdatePodOptions) &#123;</span><br><span class="line">	<span class="keyword">var</span> lastSyncTime time.Time</span><br><span class="line">...</span><br><span class="line">			err = p.syncPodFn(syncPodOptions&#123; <span class="comment">// å°±æ˜¯è¿™ä¸ª syncPodFn å‡½æ•°çš„å®ç°</span></span><br><span class="line">				mirrorPod:      update.MirrorPod,</span><br><span class="line">				pod:            update.Pod,</span><br><span class="line">				podStatus:      status,</span><br><span class="line">				killPodOptions: update.KillPodOptions,</span><br><span class="line">				updateType:     update.UpdateType,</span><br><span class="line">			&#125;)</span><br></pre></td></tr></table></figure>

<p>å…¶ä¸­çš„ <code>syncPodFn</code> å…·ä½“å®ç°æ˜¯ <code>klet.syncPod</code> å‡½æ•°ï¼Œå¯ä»¥é€šè¿‡ä»£ç <code>klet.podWorkers = newPodWorkers(klet.syncPod, kubeDeps.Recorder, klet.workQueue, klet.resyncInterval, backOffPeriod, klet.podCache)</code>çœ‹å‡ºã€‚åŸºäºä»¥ä¸Šä¿¡æ¯å¯ä»¥æ¨è®ºå‡º <code>podWorkers</code> æ‰æ˜¯ <code>pod</code> åˆ›å»ºçš„æ ¸å¿ƒã€‚èµ°è¯»<code>woker</code>çš„ <code>SyncPod</code> è¿™ä¸ªå‡½æ•°å°±æ˜¯å°±æ˜¯ <code>podWorkers</code> æ ¸å¿ƒæµç¨‹äº†ï¼Œ<code>worker</code> é€šè¿‡ <code>sync</code> å‡½æ•°æ¥è°ƒç”¨å„ä¸ª <code>CRI</code> æ¥å£å°†è¿™äº›åŸå­æ¥å£ç»„è£…æˆä¸€ä¸ªä¸ªå®é™…çš„ <code>kubernetes</code> çš„ <code>POD</code>ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SyncPod syncs the running pod into the desired pod by executing following steps:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  1. Compute sandbox and container changes.</span></span><br><span class="line"><span class="comment">//  2. Kill pod sandbox if necessary.</span></span><br><span class="line"><span class="comment">//  3. Kill any containers that should not be running.</span></span><br><span class="line"><span class="comment">//  4. Create sandbox if necessary.</span></span><br><span class="line"><span class="comment">//  5. Create ephemeral containers.</span></span><br><span class="line"><span class="comment">//  6. Create init containers.</span></span><br><span class="line"><span class="comment">//  7. Create normal containers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span></span> SyncPod(pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) (result kubecontainer.PodSyncResult) &#123;</span><br><span class="line">	<span class="comment">// Step 1: Compute sandbox and container changes.</span></span><br><span class="line">	podContainerChanges := m.computePodActions(pod, podStatus) <span class="comment">// è¿˜æ˜¯å£°æ˜å¼ api æ¨¡å‹ï¼Œå°†æ“ä½œåºåˆ—åŒ–</span></span><br><span class="line">...</span><br><span class="line">	<span class="comment">// Step 2: Kill the pod if the sandbox has changed.</span></span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.KillPod &#123;</span><br><span class="line">...</span><br><span class="line">		killResult := m.killPodWithSyncResult(pod, kubecontainer.ConvertPodStatusToRunningPod(m.runtimeName, podStatus), <span class="literal">nil</span>)</span><br><span class="line">... <span class="comment">// åˆ é™¤ä¸€ä¸‹æ— å…³ç´§è¦çš„ä»£ç ï¼Œä¸å½±å“ä¸»çº¿é€»è¾‘</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Step 3: kill any running containers in this pod which are not to keep.</span></span><br><span class="line">		<span class="keyword">for</span> containerID, containerInfo := <span class="keyword">range</span> podContainerChanges.ContainersToKill &#123;</span><br><span class="line">			klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;Killing unwanted container %q(id=%q) for pod %q&quot;</span>, containerInfo.name, containerID, format.Pod(pod))</span><br><span class="line">			killContainerResult := kubecontainer.NewSyncResult(kubecontainer.KillContainer, containerInfo.name)</span><br><span class="line">			result.AddSyncResult(killContainerResult)</span><br><span class="line">			<span class="keyword">if</span> err := m.killContainer(pod, containerID, containerInfo.name, containerInfo.message, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">...<span class="comment">// ä¸€äº›åœ¨è¿è¡Œï¼Œä½†æ˜¯åº”è¯¥è¢«åˆ é™¤çš„ container å¤„ç†é€»è¾‘ï¼Œ</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// Step 4: Create a sandbox for the pod if necessary.</span></span><br><span class="line">	podSandboxID := podContainerChanges.SandboxID</span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">...</span><br><span class="line">    createSandboxResult := kubecontainer.NewSyncResult(kubecontainer.CreatePodSandbox, format.Pod(pod))</span><br><span class="line">		result.AddSyncResult(createSandboxResult)</span><br><span class="line">		podSandboxID, msg, err = m.createPodSandbox(pod, podContainerChanges.Attempt) </span><br><span class="line">    <span class="comment">// è¿™ä¸ªå‡½æ•°æ˜¯æˆ‘ä»¬å…³æ³¨çš„æ ¸å¿ƒï¼Œå‡†å¤‡ pod çš„æ²™ç›’ï¼Œå¦‚ä½•åœ¨ sandbox ä¸­è°ƒç”¨ CNI è®¾ç½®ç½‘ç»œ/å­˜å‚¨ç­‰</span></span><br><span class="line">... <span class="comment">// åˆ é™¤ä¸€ä¸‹é”™è¯¯å¤„ç†ï¼Œäº‹ä»¶çš„é€»è¾‘ï¼Œç½‘ç»œç›¸å…³ï¼Œä¸å½±å“å¯åŠ¨ä¸€ä¸ªä¸ä½¿ç”¨ç½‘ç»œçš„ container ğŸ˜„</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Get podSandboxConfig for containers to start.</span></span><br><span class="line">	configPodSandboxResult := kubecontainer.NewSyncResult(kubecontainer.ConfigPodSandbox, podSandboxID)</span><br><span class="line">	result.AddSyncResult(configPodSandboxResult)</span><br><span class="line">	podSandboxConfig, err := m.generatePodSandboxConfig(pod, podContainerChanges.Attempt)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		message := fmt.Sprintf(<span class="string">&quot;GeneratePodSandboxConfig for pod %q failed: %v&quot;</span>, format.Pod(pod), err)</span><br><span class="line">		klog.Error(message)</span><br><span class="line">		configPodSandboxResult.Fail(kubecontainer.ErrConfigPodSandbox, message)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Helper containing boilerplate common to starting all types of containers.</span></span><br><span class="line">	<span class="comment">// typeName is a label used to describe this type of container in log messages,</span></span><br><span class="line">	<span class="comment">// currently: &quot;container&quot;, &quot;init container&quot; or &quot;ephemeral container&quot;</span></span><br><span class="line">	start := <span class="function"><span class="keyword">func</span><span class="params">(typeName <span class="type">string</span>, container *v1.Container)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		startContainerResult := kubecontainer.NewSyncResult(kubecontainer.StartContainer, container.Name)</span><br><span class="line">		result.AddSyncResult(startContainerResult)</span><br><span class="line"></span><br><span class="line">		isInBackOff, msg, err := m.doBackOff(pod, container, podStatus, backOff)</span><br><span class="line">		<span class="keyword">if</span> isInBackOff &#123;</span><br><span class="line">			startContainerResult.Fail(err, msg)</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Backing Off restarting %v %+v in pod %v&quot;</span>, typeName, container, format.Pod(pod))</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Creating %v %+v in pod %v&quot;</span>, typeName, container, format.Pod(pod))</span><br><span class="line">		<span class="comment">// NOTE (aramase) podIPs are populated for single stack and dual stack clusters. Send only podIPs.</span></span><br><span class="line">		<span class="keyword">if</span> msg, err := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, podIPs); err != <span class="literal">nil</span> &#123; <span class="comment">// åˆ›å»º cotnainer å’Œ å¯åŠ¨ container æ˜¯ä¸¤å›äº‹ï¼Œåˆ›å»ºè¯´çš„æ˜¯å‡†å¤‡å¥½ç›¸å…³åº•å±‚æ–‡ä»¶èµ„æºï¼Œå¯åŠ¨å°±æ˜¯ä»¥è¿›ç¨‹å½¢å¼åœ¨ OS å¯è§ï¼Œå…·ä½“è¿˜è¦çœ‹åº•å±‚è¿è¡Œæ—¶æ˜¯å¦‚ä½•å®ç°çš„ã€‚</span></span><br><span class="line">      <span class="comment">// .. åˆ é™¤äº†ä¸€éƒ¨åˆ†é”™è¯¯å¤„ç†çš„é€»è¾‘</span></span><br><span class="line">      </span><br><span class="line">	<span class="comment">// Step 5: start ephemeral containers</span></span><br><span class="line">	<span class="comment">//  è¿™éƒ¨åˆ†é€»è¾‘éä¸»çº¿</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 6: start the init container.</span></span><br><span class="line">	<span class="keyword">if</span> container := podContainerChanges.NextInitContainerToStart; container != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Start the next init container.</span></span><br><span class="line">		<span class="keyword">if</span> err := start(<span class="string">&quot;init container&quot;</span>, container); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Successfully started the container; clear the entry in the failure</span></span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Completed init container %q for pod %q&quot;</span>, container.Name, format.Pod(pod))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 7: start containers in podContainerChanges.ContainersToStart. </span></span><br><span class="line">	<span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.ContainersToStart &#123; <span class="comment">// å°±æ˜¯ä¸šåŠ¡çš„ container </span></span><br><span class="line">		start(<span class="string">&quot;container&quot;</span>, &amp;pod.Spec.Containers[idx]) <span class="comment">// start å¯ä»¥å‰é¢çœ‹åˆ°å®šä¹‰ start := func(typeName string, container *v1.Container) </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ä¸Šé¢çš„æºç å…¶å®å·²ç»çŸ¥é“ä¸ºä»€ä¹ˆè¦å¼•å…¥ <code>sandbox container</code> äº†ã€‚åˆ†æä¸€ä¸‹ <code>createPodSandbox</code> è¿™ä¸ªå‡½æ•°æ˜¯å¦‚ä½•å®ç°çš„ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createPodSandbox creates a pod sandbox and returns (podSandBoxID, message, error).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span></span> createPodSandbox(pod *v1.Pod, attempt <span class="type">uint32</span>) (<span class="type">string</span>, <span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	podSandboxConfig, err := m.generatePodSandboxConfig(pod, attempt)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		message := fmt.Sprintf(<span class="string">&quot;GeneratePodSandboxConfig for pod %q failed: %v&quot;</span>, format.Pod(pod), err)</span><br><span class="line">		klog.Error(message)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, message, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create pod logs directory</span></span><br><span class="line">	err = m.osInterface.MkdirAll(podSandboxConfig.LogDirectory, <span class="number">0755</span>) <span class="comment">// è¿™ä¸ªç›®å½•å°±æ˜¯ kubelet é…ç½®è¯»å–ä¸‹æ¥çš„</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		message := fmt.Sprintf(<span class="string">&quot;Create pod log directory for pod %q failed: %v&quot;</span>, format.Pod(pod), err)</span><br><span class="line">... <span class="comment">// çœç•¥é”™è¯¯å¤„ç†	</span></span><br><span class="line">... <span class="comment">// åˆ é™¤äº†éä¸»çº¿é€»è¾‘</span></span><br><span class="line">	podSandBoxID, err := m.runtimeService.RunPodSandbox(podSandboxConfig, runtimeHandler)</span><br><span class="line">... <span class="comment">// çœç•¥é”™è¯¯å¤„ç†</span></span><br><span class="line">	<span class="keyword">return</span> podSandBoxID, <span class="string">&quot;&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è¿™å°±æ˜¯çœ‹åˆ°è°ƒç”¨çš„ <code>func (in instrumentedRuntimeService) RunPodSandboxha</code> å‡½æ•°åŸºæœ¬æ˜¯é€ä¼ ï¼Œå­˜ç²¹æ˜¯ä¸ºäº†è®°å½•ä¸€ä¸‹ <code>metric</code> ä¸ºç›‘æ§æœåŠ¡ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in instrumentedRuntimeService)</span></span> RunPodSandbox(config *runtimeapi.PodSandboxConfig, runtimeHandler <span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> operation = <span class="string">&quot;run_podsandbox&quot;</span></span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> recordOperation(operation, startTime)</span><br><span class="line">	<span class="keyword">defer</span> metrics.RunPodSandboxDuration.WithLabelValues(runtimeHandler).Observe(metrics.SinceInSeconds(startTime))</span><br><span class="line"></span><br><span class="line">	out, err := in.service.RunPodSandbox(config, runtimeHandler)</span><br><span class="line">	recordError(operation, err)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		metrics.RunPodSandboxErrors.WithLabelValues(runtimeHandler).Inc()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>åœ¨ä¸Šé¢è®°å½•å®Œæˆç›‘æ§ç›¸å…³è¿‡åï¼Œä¸‹é¢å°±æ˜¯å‡†å¤‡è°ƒç”¨ <code>grpc</code> æœåŠ¡äº†ï¼Œå¯ä»¥çœ‹åˆ°è°ƒç”¨çš„æ˜¯ <code>CRI</code> çš„ <code>/runtime.v1alpha2.RuntimeService/RunPodSandbox</code> æ¥å£ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RunPodSandbox creates and starts a pod-level sandbox. Runtimes should ensure</span></span><br><span class="line"><span class="comment">// the sandbox is in ready state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RemoteRuntimeService)</span></span> RunPodSandbox(config *runtimeapi.PodSandboxConfig, runtimeHandler <span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// Use 2 times longer timeout for sandbox operation (4 mins by default)</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Make the pod sandbox timeout configurable.</span></span><br><span class="line">	ctx, cancel := getContextWithTimeout(r.timeout * <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	resp, err := r.runtimeClient.RunPodSandbox(ctx, &amp;runtimeapi.RunPodSandboxRequest&#123;</span><br><span class="line">		Config:         config,</span><br><span class="line">		RuntimeHandler: runtimeHandler,</span><br><span class="line">	&#125;)</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">return</span> resp.PodSandboxId, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *runtimeServiceClient)</span></span> RunPodSandbox(ctx context.Context, in *RunPodSandboxRequest, opts ...grpc.CallOption) (*RunPodSandboxResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	out := <span class="built_in">new</span>(RunPodSandboxResponse)</span><br><span class="line">	err := c.cc.Invoke(ctx, <span class="string">&quot;/runtime.v1alpha2.RuntimeService/RunPodSandbox&quot;</span>, in, out, opts...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ä»¥ä¸Šå°±æ˜¯ <code>kubeGenericRuntimeManager</code> æ‰€å¤„ç†çš„ <code>POD</code> åˆ›å»ºæµç¨‹ä¸­çš„ <code>sandbox</code> çš„éƒ¨åˆ†ï¼Œå¯¹å…¶ <code>sandbox</code> å…·ä½“æ˜¯å¦‚ä½•è¢«åˆ›å»ºçš„æ›´å¤šç»†èŠ‚å°±è¦çœ‹ <code>grpc</code> æœåŠ¡ç«¯çš„å®ç°äº†ã€‚</p>
<h1 id="dockershim"><a href="#dockershim" class="headerlink" title="dockershim"></a>dockershim</h1><p>å‰é¢æ¢³ç†å‡ºæ¥äº† <code>kubeGenericRuntimeManager</code> æ˜¯å¦‚ä½•é€šè¿‡<code>SyncPod</code>å®ç°<code>POD</code>çš„åˆ›å»ºï¼Œä½†æ˜¯ä¹Ÿå‘ç°ä»–çš„å®ç°å®Œå…¨æ˜¯é¢å‘æ¥å£çš„ï¼Œå®Œå…¨ä¸å…³å¿ƒåº•å±‚æ˜¯å¦‚ä½•å®ç° <code>cotnainer</code> çš„ã€‚æˆ‘ä»¬æ¥ç€ä¸Šé¢ <code>client</code> çš„ç›¸å…³é€»è¾‘èµ°è¯»ä¸€ä¸‹<code>/runtime.v1alpha2.RuntimeService/RunPodSandbox</code> çš„æœåŠ¡ç«¯ä»£ç é€»è¾‘ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _RuntimeService_serviceDesc = grpc.ServiceDesc&#123;</span><br><span class="line">	ServiceName: <span class="string">&quot;runtime.v1alpha2.RuntimeService&quot;</span>,</span><br><span class="line">	HandlerType: (*RuntimeServiceServer)(<span class="literal">nil</span>),</span><br><span class="line">	Methods: []grpc.MethodDesc&#123;</span><br><span class="line">...</span><br><span class="line">		&#123;</span><br><span class="line">			MethodName: <span class="string">&quot;RunPodSandbox&quot;</span>,</span><br><span class="line">			Handler:    _RuntimeService_RunPodSandbox_Handler,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>ä¸‹é¢æ˜¯ <code>handler</code> æ³¨å†Œçš„è¿‡ç¨‹ï¼Œå…¶å®éƒ½æ˜¯æœºå™¨ç”Ÿæˆçš„ä»£ç æ²¡æœ‰å•¥å¥½çœ‹çš„ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">RuntimeService_RunPodSandbox_Handler</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span>, interceptor grpc.UnaryServerInterceptor) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">	in := <span class="built_in">new</span>(RunPodSandboxRequest)</span><br><span class="line">	<span class="keyword">if</span> err := dec(in); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> interceptor == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> srv.(RuntimeServiceServer).RunPodSandbox(ctx, in)</span><br><span class="line">	&#125;</span><br><span class="line">	info := &amp;grpc.UnaryServerInfo&#123;</span><br><span class="line">		Server:     srv,</span><br><span class="line">		FullMethod: <span class="string">&quot;/runtime.v1alpha2.RuntimeService/RunPodSandbox&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	handler := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> srv.(RuntimeServiceServer).RunPodSandbox(ctx, req.(*RunPodSandboxRequest))</span><br></pre></td></tr></table></figure>

<p>è¿™é‡Œå°±æ˜¯ <code>dockershim</code> å®ç°çš„ <code>CRI</code>ï¼Œèµ°è¯»ä¸Šä¸‹æ–‡ä»£ç çŸ¥é“äº† <code>ds.client.StartContainer()</code> ä¸­çš„ <code>client</code> æ˜¯ <code>libdocker</code> ä¸­ï¼Œä¹Ÿå°±æ˜¯è°ƒç”¨çš„ <code>dockerClient</code>ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RunPodSandbox creates and starts a pod-level sandbox. Runtimes should ensure</span></span><br><span class="line"><span class="comment">// the sandbox is in ready state.</span></span><br><span class="line"><span class="comment">// For docker, PodSandbox is implemented by a container holding the network</span></span><br><span class="line"><span class="comment">// namespace for the pod.</span></span><br><span class="line"><span class="comment">// Note: docker doesn&#x27;t use LogDirectory (yet).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *dockerService)</span></span> RunPodSandbox(ctx context.Context, r *runtimeapi.RunPodSandboxRequest) (*runtimeapi.RunPodSandboxResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	config := r.GetConfig()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Pull the image for the sandbox.</span></span><br><span class="line">	image := defaultSandboxImage <span class="comment">// è¿™é‡Œå°±æ˜¯ Google çš„é‚£ä¸ª sandbox çš„ image</span></span><br><span class="line">	podSandboxImage := ds.podSandboxImage</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(podSandboxImage) != <span class="number">0</span> &#123;</span><br><span class="line">		image = podSandboxImage</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> To use a custom sandbox image in a private repository, users need to configure the nodes with credentials properly.</span></span><br><span class="line">	<span class="comment">// see: http://kubernetes.io/docs/user-guide/images/#configuring-nodes-to-authenticate-to-a-private-repository</span></span><br><span class="line">	<span class="comment">// Only pull sandbox image when it&#x27;s not present - v1.PullIfNotPresent.</span></span><br><span class="line">	<span class="keyword">if</span> err := ensureSandboxImageExists(ds.client, image); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: Create the sandbox container.</span></span><br><span class="line">	<span class="keyword">if</span> r.GetRuntimeHandler() != <span class="string">&quot;&quot;</span> &amp;&amp; r.GetRuntimeHandler() != runtimeName &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;RuntimeHandler %q not supported&quot;</span>, r.GetRuntimeHandler())</span><br><span class="line">	&#125;</span><br><span class="line">	createConfig, err := ds.makeSandboxDockerConfig(config, image)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to make sandbox docker config for pod %q: %v&quot;</span>, config.Metadata.Name, err)</span><br><span class="line">	&#125;</span><br><span class="line">	createResp, err := ds.client.CreateContainer(*createConfig) <span class="comment">// è¿™é‡Œçš„åˆ›å»º sandbox æ˜¯å¤‡å¥½ container éœ€è¦åº•å±‚èµ„æº</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		createResp, err = recoverFromCreationConflictIfNeeded(ds.client, *createConfig, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || createResp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to create a sandbox for pod %q: %v&quot;</span>, config.Metadata.Name, err)</span><br><span class="line">	&#125;</span><br><span class="line">	resp := &amp;runtimeapi.RunPodSandboxResponse&#123;PodSandboxId: createResp.ID&#125;</span><br><span class="line"></span><br><span class="line">	ds.setNetworkReady(createResp.ID, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(e *<span class="type">error</span>)</span></span> &#123;</span><br><span class="line">		<span class="comment">// Set networking ready depending on the error return of</span></span><br><span class="line">		<span class="comment">// the parent function</span></span><br><span class="line">		<span class="keyword">if</span> *e == <span class="literal">nil</span> &#123;</span><br><span class="line">			ds.setNetworkReady(createResp.ID, <span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(&amp;err)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: Create Sandbox Checkpoint.</span></span><br><span class="line">	<span class="keyword">if</span> err = ds.checkpointManager.CreateCheckpoint(createResp.ID, constructPodSandboxCheckpoint(config)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err <span class="comment">// ç›®å‰æ¥çœ‹ checkpoint åŠŸèƒ½å¥½åƒå¹¶æ²¡æœ‰å¤§è§„æ¨¡ä½¿ç”¨ï¼Ÿä¸è¿‡è¿™ä¸ªå¯¹æˆ‘ä»¬è¿™æ¬¡çœ‹ pod åˆ›å»ºæµç¨‹æ— å…³ç»éªŒ</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 4: Start the sandbox container.</span></span><br><span class="line">	<span class="comment">// Assume kubelet&#x27;s garbage collector would remove the sandbox later, if</span></span><br><span class="line">	<span class="comment">// startContainer failed.</span></span><br><span class="line">	err = ds.client.StartContainer(createResp.ID) <span class="comment">// å‰é¢å‡†å¤‡å¥½ container è¿™é‡Œæ‰å»å¯åŠ¨ï¼Œå…·ä½“æ€ä¹ˆå¯åŠ¨ kubelet å¹¶ä¸å…³å¿ƒ</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to start sandbox container for pod %q: %v&quot;</span>, config.Metadata.Name, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// åˆ é™¤äº†ä¸€ä¸‹ç½‘ç»œå’Œå®‰å…¨ç›¸å…³ä»£ç å’Œæ ¸å¿ƒæµç¨‹æ— å…³</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 5: Setup networking for the sandbox.</span></span><br><span class="line">	<span class="comment">// All pod networking is setup by a CNI plugin discovered at startup time.</span></span><br><span class="line">	<span class="comment">// This plugin assigns the pod ip, sets up routes inside the sandbox,</span></span><br><span class="line">	<span class="comment">// creates interfaces etc. In theory, its jurisdiction ends with pod</span></span><br><span class="line">	<span class="comment">// sandbox networking, but it might insert iptables rules or open ports</span></span><br><span class="line">	<span class="comment">// on the host as well, to satisfy parts of the pod spec that aren&#x27;t</span></span><br><span class="line">	<span class="comment">// recognized by the CNI standard yet.</span></span><br><span class="line">	cID := kubecontainer.BuildContainerID(runtimeName, createResp.ID)</span><br><span class="line">	networkOptions := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">if</span> dnsConfig := config.GetDnsConfig(); dnsConfig != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Build DNS options.</span></span><br><span class="line">		dnsOption, err := json.Marshal(dnsConfig)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to marshal dns config for pod %q: %v&quot;</span>, config.Metadata.Name, err)</span><br><span class="line">		&#125;</span><br><span class="line">		networkOptions[<span class="string">&quot;dns&quot;</span>] = <span class="type">string</span>(dnsOption)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// CRI è°ƒç”¨ CNI æ¥è®¾ç½® POD çš„åŸºç¡€ç½‘ç»œ</span></span><br><span class="line">	err = ds.network.SetUpPod(config.GetMetadata().Namespace, config.GetMetadata().Name, cID, config.Annotations, networkOptions)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// åˆ é™¤äº†ä¸€éƒ¨åˆ†è®¾ç½®å®¹å™¨ç½‘ç»œé”™è¯¯çš„å¤„ç†æµç¨‹å’Œæ ¸å¿ƒæµç¨‹æ— å…³</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>èµ°è¯»çš„ <code>dockershim</code> çš„ <code>RunPodSandbox</code> æ¥å£å‘ç°ï¼Œå®ƒè°ƒç”¨äº† <code>docker</code> çš„æ¥å£ <code>ds.client.CreateContainer(*createConfig)</code> åˆ›å»ºäº† <code>cotnainer</code>, åˆä½¿ç”¨äº† <code>ds.client.StartContainer(createResp.ID)</code> å¯åŠ¨åˆšåˆšåˆ›å»ºçš„ <code>cotnainer</code>ã€‚åœ¨å¾€ä¸‹é¢å®ç°å°±éœ€è¦å»èµ°è¯» <code>dockerd</code> çš„ä»£ç äº†ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *dockerService)</span></span> RunPodSandbox(ctx context.Context, r *runtimeapi.RunPodSandboxRequest) (*runtimeapi.RunPodSandboxResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	config := r.GetConfig()</span><br><span class="line">...</span><br><span class="line">	createConfig, err := ds.makeSandboxDockerConfig(config, image)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to make sandbox docker config for pod %q: %v&quot;</span>, config.Metadata.Name, err)</span><br><span class="line">	&#125;</span><br><span class="line">	createResp, err := ds.client.CreateContainer(*createConfig) <span class="comment">// è¿™é‡Œçš„åˆ›å»º sandbox æ˜¯å¤‡å¥½ container éœ€è¦åº•å±‚èµ„æº</span></span><br><span class="line">...</span><br><span class="line">	<span class="comment">// Step 4: Start the sandbox container.</span></span><br><span class="line">	<span class="comment">// Assume kubelet&#x27;s garbage collector would remove the sandbox later, if</span></span><br><span class="line">	<span class="comment">// startContainer failed.</span></span><br><span class="line">	err = ds.client.StartContainer(createResp.ID) <span class="comment">// å‰é¢å‡†å¤‡å¥½ container è¿™é‡Œæ‰å»å¯åŠ¨ï¼Œå…·ä½“æ€ä¹ˆå¯åŠ¨ kubelet å¹¶ä¸å…³å¿ƒ</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to start sandbox container for pod %q: %v&quot;</span>, config.Metadata.Name, err)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>è¿™é‡Œä¸»è¦å…³æ³¨ <code>ds.client.StartContainer()</code>ï¼Œæ˜¯å› ä¸º <code>ds.client.CreateContainer(*createConfig)</code> çš„é€»è¾‘æ¯”è¾ƒç®€å•ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp, err := cli.post(ctx, <span class="string">&quot;/containers/&quot;</span>+containerID+<span class="string">&quot;/start&quot;</span>, query, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>é€šè¿‡å¯¹ä»£ç çš„åˆ†æå‘ç° <code>StartContainer</code> æœ€åå‘å‡ºçš„æ˜¯ <code>http</code> è¯·æ±‚ã€‚</p>
<h1 id="dockerd-æ¥å£"><a href="#dockerd-æ¥å£" class="headerlink" title="dockerd æ¥å£"></a>dockerd æ¥å£</h1><h2 id="x2F-containers-x2F-name-x2F-start"><a href="#x2F-containers-x2F-name-x2F-start" class="headerlink" title="&#x2F;containers&#x2F;{name:.*}&#x2F;start"></a>&#x2F;containers&#x2F;{name:.*}&#x2F;start</h2><p>åŸºäºå‰é¢çš„åˆ†ææˆ‘å·²ç»çŸ¥é“ <code>kubelet</code> çš„ <code>dockershim</code> å…¶å®ä½¿ç”¨è°ƒç”¨çš„ <code>docker</code> çš„ <code>resftul api</code>ï¼Œæ ¹æ®çº¿ä¸Š <code>docker</code> çš„ç‰ˆæœ¬ä¿¡æ¯ <code>18.09.9</code> <code>checkout</code>ç›¸å¯¹åº”çš„ä»£ç ã€‚å¯ä»¥å‘ç° <code>container</code> æµç¨‹ç›¸å…³çš„é€»è¾‘åœ¨ <code>docker/api/server/router/container/container.go</code> çš„ <code>initRoutes()</code> ä¸­ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/start&quot;</span>, r.postContainersStart),</span><br></pre></td></tr></table></figure>

<p>ä¸Šé¢æ˜¯ handler ä¸»è¦é€»è¾‘å¾ˆç®€å•ï¼Œä¸‹é¢å°±æ˜¯å¯åŠ¨ <code>container</code> çš„æ ¸å¿ƒæµç¨‹äº†ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *containerRouter)</span></span> postContainersStart(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// If contentLength is -1, we can assumed chunked encoding</span></span><br><span class="line">	<span class="comment">// or more technically that the length is unknown</span></span><br><span class="line">	<span class="comment">// https://golang.org/src/pkg/net/http/request.go#L139</span></span><br><span class="line">	<span class="comment">// net/http otherwise seems to swallow any headers related to chunked encoding</span></span><br><span class="line">	<span class="comment">// including r.TransferEncoding</span></span><br><span class="line">	<span class="comment">// allow a nil body for backwards compatibility</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ç§»é™¤ http æ£€æŸ¥ç›¸å…³é€»è¾‘ï¼Œå“ªäº›ä¸å½±å“æ ¸å¿ƒ</span></span><br><span class="line">	<span class="keyword">if</span> err := s.backend.ContainerStart(vars[<span class="string">&quot;name&quot;</span>], hostConfig, checkpoint, checkpointDir); err != <span class="literal">nil</span> &#123; <span class="comment">// here </span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContainerStart starts a container.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span></span> ContainerStart(name <span class="type">string</span>, hostConfig *containertypes.HostConfig, checkpoint <span class="type">string</span>, checkpointDir <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// åˆ é™¤å¤§é‡çš„ä¿æŠ¤å¼ç¼–ç¨‹éæ ¸å¿ƒé€»è¾‘ä»£ç </span></span><br><span class="line">	<span class="keyword">return</span> daemon.containerStart(container, checkpoint, checkpointDir, <span class="literal">true</span>) <span class="comment">// here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è·Ÿå¦‚è¿™ä¸ª<code>Start</code>å‡½æ•°å‘ç°å±…ç„¶æ˜¯ä½¿ç”¨ <code>grpc </code>å»è°ƒç”¨<code>/containerd.services.tasks.v1.Tasks/Start</code>çš„æ¥å£ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// containerStart prepares the container to run by setting up everything the</span></span><br><span class="line"><span class="comment">// container needs, such as storage and networking, as well as links</span></span><br><span class="line"><span class="comment">// between containers. The container is left waiting for a signal to</span></span><br><span class="line"><span class="comment">// begin running.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span></span> containerStart(container *container.Container, checkpoint <span class="type">string</span>, checkpointDir <span class="type">string</span>, resetRestartManager <span class="type">bool</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	container.Lock()</span><br><span class="line">	<span class="keyword">defer</span> container.Unlock()</span><br><span class="line">	<span class="comment">// åˆ é™¤é”™è¯¯å¤„ç†ä¸ä¸€ä¸‹é˜²å¾¡ç¼–ç¨‹</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := daemon.conditionalMountOnStart(container); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := daemon.initializeNetworking(container); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spec, err := daemon.createSpec(container)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errdefs.System(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// åˆ é™¤ä¸€ä¸‹éæ ¸å¿ƒåŠŸèƒ½ä»£ç </span></span><br><span class="line"></span><br><span class="line">	createOptions, err := daemon.getLibcontainerdCreateOptions(container)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx := context.TODO()</span><br><span class="line"></span><br><span class="line">	err = daemon.containerd.Create(ctx, container.ID, spec, createOptions) <span class="comment">// è¿™é‡Œæœ€ç»ˆä¼šè°ƒç”¨ cotnainerd çš„ create</span></span><br><span class="line">	<span class="comment">// åˆ é™¤é”™è¯¯å¤„ç†ç›¸å…³ä»£ç </span></span><br><span class="line">	<span class="comment">// TODO(mlaventure): we need to specify checkpoint options here</span></span><br><span class="line">	pid, err := daemon.containerd.Start(context.Background(), container.ID, checkpointDir, <span class="comment">// è¿™é‡Œéœ€è¦è·Ÿè¿›ä¸€ä¸‹</span></span><br><span class="line">		container.StreamConfig.Stdin() != <span class="literal">nil</span> || container.Config.Tty,</span><br><span class="line">		container.InitializeStdio)</span><br><span class="line">  <span class="comment">// å¿½ç•¥é”™è¯¯å¤„ç†</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>containerStart</code> å‡½æ•°å‡†å¤‡ <code>containerd</code> è¿è¡Œçš„ä¸€åˆ‡éœ€è¦çš„ä¸œè¥¿åŒ…æ‹¬å­˜å‚¨å’Œç½‘ç»œã€‚ä½†æ˜¯å®é™…å¯åŠ¨å¯ä»¥å‘ç°æ˜¯è°ƒç”¨äº†<code>daemon.containerd.Create</code>ä¸<code>daemon.containerd.Start</code>æ¥å£ï¼Œç»†èŠ‚ä¸‹é¢è¿›ä¸€æ­¥åˆ†æã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *client)</span></span> Create(ctx context.Context, id <span class="type">string</span>, ociSpec *specs.Spec, runtimeOptions <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ctr := c.getContainer(id); ctr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithStack(newConflictError(<span class="string">&quot;id already in use&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bdir, err := prepareBundleDir(filepath.Join(c.stateDir, id), ociSpec) <span class="comment">// å…¶å®å°±æ˜¯å‡†å¤‡å®¹å™¨å¯åŠ¨ç›®å½•ä¹‹ç±»çš„</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errdefs.System(errors.Wrap(err, <span class="string">&quot;prepare bundle dir failed&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.logger.WithField(<span class="string">&quot;bundle&quot;</span>, bdir).WithField(<span class="string">&quot;root&quot;</span>, ociSpec.Root.Path).Debug(<span class="string">&quot;bundle dir created&quot;</span>)</span><br><span class="line"></span><br><span class="line">	cdCtr, err := c.client.NewContainer(ctx, id, <span class="comment">// æ ¸å¿ƒä»£ç ï¼Œæ›´å¤šçš„é€»è¾‘éœ€è¦ä¸‹é¢å±•å¼€</span></span><br><span class="line">		containerd.WithSpec(ociSpec),</span><br><span class="line">		<span class="comment">// TODO(mlaventure): when containerd support lcow, revisit runtime value</span></span><br><span class="line">		containerd.WithRuntime(fmt.Sprintf(<span class="string">&quot;io.containerd.runtime.v1.%s&quot;</span>, runtime.GOOS), runtimeOptions))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> wrapError(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.Lock()</span><br><span class="line">	c.containers[id] = &amp;container&#123;</span><br><span class="line">		bundleDir: bdir,</span><br><span class="line">		ctr:       cdCtr,</span><br><span class="line">	&#125;</span><br><span class="line">	c.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NewContainer()</code> å°±æ˜¯è¿™ä¸€æ®µä»£ç çš„æ ¸å¿ƒï¼Œéœ€è¦å±•å¼€è¯´æ˜</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewContainer will create a new container in container with the provided id</span></span><br><span class="line"><span class="comment">// the id must be unique within the namespace</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> NewContainer(ctx context.Context, id <span class="type">string</span>, opts ...NewContainerOpts) (Container, <span class="type">error</span>) &#123;</span><br><span class="line">   ctx, done, err := c.WithLease(ctx)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> done(ctx)</span><br><span class="line"></span><br><span class="line">   container := containers.Container&#123;</span><br><span class="line">      ID: id,</span><br><span class="line">      Runtime: containers.RuntimeInfo&#123;</span><br><span class="line">         Name: c.runtime,</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">      <span class="keyword">if</span> err := o(ctx, c, &amp;container); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   r, err := c.ContainerService().Create(ctx, container) <span class="comment">// æ ¸å¿ƒå°±æ˜¯ create äº†</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> containerFromRecord(c, r), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>å¯ä»¥çœ‹åˆ°<code>c.ContainerService().Create(ctx, container)</code>å…¶å®è°ƒç”¨äº† <code>container service</code>ï¼Œè¿™ä¸ªä¸ªæ˜¯ <code>docker</code> å±‚é¢çš„æŠ½è±¡ï¼Œå…·ä½“å®ç°æ˜¯ <code>containerd</code>æä¾›çš„ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *remoteContainers)</span></span> Create(ctx context.Context, container containers.Container) (containers.Container, <span class="type">error</span>) &#123;</span><br><span class="line">   created, err := r.client.Create(ctx, &amp;containersapi.CreateContainerRequest&#123;</span><br><span class="line">      Container: containerToProto(&amp;container),</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *containersClient)</span></span> Create(ctx context.Context, in *CreateContainerRequest, opts ...grpc.CallOption) (*CreateContainerResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	out := <span class="built_in">new</span>(CreateContainerResponse)</span><br><span class="line">	err := grpc.Invoke(ctx, <span class="string">&quot;/containerd.services.containers.v1.Containers/Create&quot;</span>, in, out, c.cc, opts...)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>åŸºäºä¸Šè¿°<code>client.create</code>å…¶å®ä¹Ÿå¯ä»¥å‘ç°ï¼Œå®è´¨æ€§çš„å·¥ä½œåªæœ‰ä¸€ä¸ªå°±æ˜¯å‡†å¤‡å¯åŠ¨éœ€è¦ä¸€äº›ç›®å½•ç»“æ„ã€‚è¿™ä¸€åˆ‡éƒ½æ˜¯ä¸ºäº†å‡†å¤‡è°ƒç”¨ <code>/containerd.services.containers.v1.Containers/Create</code>æ¥å£ã€‚</p>
<p><code>docker</code> è°ƒç”¨å®Œæˆ <code>containerd</code> çš„ <code>create</code> ä¸‹é¢å°±è¦è°ƒç”¨ <code>daemon.containerd.Start()</code>ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start create and start a task for the specified containerd id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *client)</span></span> Start(ctx context.Context, id, checkpointDir <span class="type">string</span>, withStdin <span class="type">bool</span>, attachStdio StdioCallback) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	ctr := c.getContainer(id)</span><br><span class="line">	<span class="keyword">if</span> ctr == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, errors.WithStack(newNotFoundError(<span class="string">&quot;no such container&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t := ctr.getTask(); t != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, errors.WithStack(newConflictError(<span class="string">&quot;container already started&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		cp             *types.Descriptor</span><br><span class="line">		t              containerd.Task</span><br><span class="line">		rio            cio.IO</span><br><span class="line">		err            <span class="type">error</span></span><br><span class="line">		stdinCloseSync = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// å¿½ç•¥ checkpoint ç›¸å…³ä»£ç </span></span><br><span class="line"></span><br><span class="line">	spec, err := ctr.ctr.Spec(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, errors.Wrap(err, <span class="string">&quot;failed to retrieve spec&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	uid, gid := getSpecUser(spec)</span><br><span class="line">	t, err = ctr.ctr.NewTask(ctx, <span class="comment">// è¿™é‡Œå°±æ˜¯è°ƒç”¨ containerd, /containerd.services.tasks.v1.Tasks/Create</span></span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> (cio.IO, <span class="type">error</span>) &#123;</span><br><span class="line">			fifos := newFIFOSet(ctr.bundleDir, InitProcessName, withStdin, spec.Process.Terminal)</span><br><span class="line"></span><br><span class="line">			rio, err = c.createIO(fifos, id, InitProcessName, stdinCloseSync, attachStdio)</span><br><span class="line">			<span class="keyword">return</span> rio, err</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, _ *containerd.Client, info *containerd.TaskInfo)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			info.Checkpoint = cp</span><br><span class="line">			info.Options = &amp;runctypes.CreateOptions&#123;</span><br><span class="line">				IoUid:       <span class="type">uint32</span>(uid),</span><br><span class="line">				IoGid:       <span class="type">uint32</span>(gid),</span><br><span class="line">				NoPivotRoot: os.Getenv(<span class="string">&quot;DOCKER_RAMDISK&quot;</span>) != <span class="string">&quot;&quot;</span>,</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line"><span class="comment">// ç§»é™¤é”™è¯¯å¤„ç†ç›¸å…³ä»£ç </span></span><br><span class="line">	ctr.setTask(t)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Signal c.createIO that it can call CloseIO</span></span><br><span class="line">	<span class="built_in">close</span>(stdinCloseSync)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := t.Start(ctx); err != <span class="literal">nil</span> &#123; <span class="comment">// è¿™ä¸ª t æ˜¯ task çš„ç¼©å†™ï¼Œ/containerd.services.tasks.v1.Tasks/Start</span></span><br><span class="line"><span class="comment">// ç§»é™¤é”™è¯¯å¤„ç†ç›¸å…³ä»£ç </span></span><br></pre></td></tr></table></figure>

<p>åŸºäºä¸Šè¿°ä»£ç å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œè¿˜æ˜¯äºŒæ¬¡å°è£…äº†ã€‚</p>
<p><code>ctr.ctr.NewTask()</code> å°±æ˜¯å‡†å¤‡å¥½å‚æ•°å‡†å¤‡è°ƒç”¨ <code>containerd</code>çš„<code>/containerd.services.tasks.v1.Tasks/Create</code>æ¥å£ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *container)</span></span> NewTask(ctx context.Context, ioCreate cio.Creator, opts ...NewTaskOpts) (_ Task, err <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// åˆ é™¤ææ„å‡½æ•°å’Œé”™è¯¯å¤„ç†</span></span><br><span class="line">	cfg := i.Config()</span><br><span class="line">	request := &amp;tasks.CreateTaskRequest&#123;</span><br><span class="line">		ContainerID: c.id,</span><br><span class="line">		Terminal:    cfg.Terminal,</span><br><span class="line">		Stdin:       cfg.Stdin,</span><br><span class="line">		Stdout:      cfg.Stdout,</span><br><span class="line">		Stderr:      cfg.Stderr,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// åˆ é™¤éƒ¨åˆ†ä»£ç </span></span><br><span class="line">	response, err := c.client.TaskService().Create(ctx, request) <span class="comment">// task service create</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.FromGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	t.pid = response.Pid</span><br><span class="line">	<span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *tasksClient)</span></span> Create(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*CreateTaskResponse, <span class="type">error</span>) &#123;</span><br><span class="line">   out := <span class="built_in">new</span>(CreateTaskResponse)</span><br><span class="line">   err := grpc.Invoke(ctx, <span class="string">&quot;/containerd.services.tasks.v1.Tasks/Create&quot;</span>, in, out, c.cc, opts...)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è€Œ<code>t.Start(ctx)</code>å‡½æ•°çš„å®ç°æ›´ç®€å•ï¼Œæœ€åè°ƒç”¨<code>containerd</code>çš„<code>/containerd.services.tasks.v1.Tasks/Start</code>æ¥å£</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *tasksClient)</span></span> Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	out := <span class="built_in">new</span>(StartResponse)</span><br><span class="line">	err := grpc.Invoke(ctx, <span class="string">&quot;/containerd.services.tasks.v1.Tasks/Start&quot;</span>, in, out, c.cc, opts...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>åŸºäºä»¥ä¸Šåˆ†æï¼Œå…¶å® <code>dockerd</code> çš„<code>ContainerStart</code>å…ˆåä¼šè°ƒç”¨åˆ°<code>cotnainerd</code>çš„<code>/containerd.services.containers.v1.Containers/Create</code>ï¼Œå…¶æ¬¡<code>/containerd.services.tasks.v1.Tasks/Create</code>ï¼Œæœ€åæ˜¯<code>/containerd.services.tasks.v1.Tasks/Start</code>ã€‚</p>
<p>é‚£ä¹ˆä¸‹é¢å°±å»èµ°è¯»ä¸€ä¸‹ <code>containerd</code>çš„ç›¸å…³å®ç°ã€‚</p>
<h1 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h1><p>æ ¹æ®çº¿ä¸Šä¿¡æ¯ <code>checkout </code>å‡º<code>containerd</code>ç‰ˆæœ¬ä¸º<code>7ad184331fa3e55e52b890ea95e65ba581ae3429</code>çš„ä»£ç è¿›è¡Œèµ°è¯»ã€‚æ ¹æ®ä¸Šä¸€ç¯‡ç»“æŸçš„æ¥å£ä¿¡æ¯ï¼Œç›´æ¥æœç´¢ç›¸å…³<code>GRPC</code>æ¥å£å¯ä»¥æ‰¾åˆ°å®ç°çš„ <code>handler</code>ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">Containers_Create_Handler</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span>, interceptor </span><br><span class="line">...</span><br><span class="line">	info := &amp;grpc.UnaryServerInfo&#123;</span><br><span class="line">		Server:     srv,</span><br><span class="line">		FullMethod: <span class="string">&quot;/containerd.services.containers.v1.Containers/Create&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	handler := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> srv.(ContainersServer).Create(ctx, req.(*CreateContainerRequest))</span><br><span class="line">...    </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">Tasks_Create_Handler</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span>, interceptor grpc.UnaryServerInterceptor) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">	info := &amp;grpc.UnaryServerInfo&#123;</span><br><span class="line">		Server:     srv,</span><br><span class="line">		FullMethod: <span class="string">&quot;/containerd.services.tasks.v1.Tasks/Create&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	handler := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> srv.(TasksServer).Create(ctx, req.(*CreateTaskRequest))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">Tasks_Start_Handler</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span>, interceptor grpc.UnaryServerInterceptor) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">	info := &amp;grpc.UnaryServerInfo&#123;</span><br><span class="line">		Server:     srv,</span><br><span class="line">		FullMethod: <span class="string">&quot;/containerd.services.tasks.v1.Tasks/Start&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	handler := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> srv.(TasksServer).Start(ctx, req.(*StartRequest))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>é‚£ä¹ˆè¿™ä¸€ç¯‡åˆ†åˆ«èµ°è¯»ä¸€ä¸‹ä¸‰ä¸ªæ¥å£æ˜¯å¦‚ä½•å®ç°çš„ã€‚</p>
<h2 id="ContainersServer-Create-æ–¹æ³•çš„å®ç°"><a href="#ContainersServer-Create-æ–¹æ³•çš„å®ç°" class="headerlink" title="ContainersServer.Create æ–¹æ³•çš„å®ç°"></a>ContainersServer.Create æ–¹æ³•çš„å®ç°</h2><p>å†æ¥çœ‹ä¸€ä¸‹<code>create</code>å®ç°ï¼Œé€šè¿‡ä¹‹å‰ api é…åˆ IDE å°±èƒ½ç›´æ¥è½¬è·³åˆ°ä¸‹é¢çš„ä»£ç å®ç°ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *local)</span></span> Create(ctx context.Context, req *api.CreateContainerRequest, _ ...grpc.CallOption) (*api.CreateContainerResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> resp api.CreateContainerResponse</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := l.withStoreUpdate(ctx, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, store containers.Store)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		container := containerFromProto(&amp;req.Container)</span><br><span class="line"></span><br><span class="line">		created, err := store.Create(ctx, container) <span class="comment">// å°† container çš„ä¿¡æ¯å†™å…¥æœ¬åœ°çš„ä¸€ä¸ªæ•°æ®åº“</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>é€šè¿‡å¯¹ä¸Šé¢ä»£ç èµ°è¯»åˆ†æï¼Œå‘ç°å…¶å® <code>cotnainerd</code> çš„ <code>create</code> æ“ä½œä»…ä»…å°±æ˜¯å†™ä¸€ä¸ªæ•°æ®åˆ° <code>bucket </code> ä¸­å»ï¼Œè¿˜æœ‰ä¸€ä¸ª <code>event</code>ä¿¡æ¯ <code>create container</code>ã€‚ç›®å‰è¿˜ä¸æ˜ç™½è¿™ä¸ª <code>event</code> é™¤äº†ä½¿ç”¨ <code>ctr events</code>çœ‹åˆ°è¿˜æœ‰å…¶ä»–çš„ä½œç”¨ä¹ˆï¼Ÿ</p>
<h2 id="TasksServer-Create-æ–¹æ³•çš„å®ç°"><a href="#TasksServer-Create-æ–¹æ³•çš„å®ç°" class="headerlink" title="TasksServer.Create æ–¹æ³•çš„å®ç°"></a>TasksServer.Create æ–¹æ³•çš„å®ç°</h2><p><code>containerd</code> ä½¿ç”¨ <code>task</code> æ¥ç®¡ç† <code>container</code> çš„åˆ›å»ºå’Œåˆ é™¤ï¼Œåœ¨ <code>containerd</code> çš„ <code>readme</code> æ–‡æ¡£ä¸­ä¹Ÿå†™çš„æ¯”è¾ƒæ¸…æ¥šäº†ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *local)</span></span> Create(ctx context.Context, r *api.CreateTaskRequest, _ ...grpc.CallOption) (*api.CreateTaskResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		checkpointPath <span class="type">string</span></span><br><span class="line">		err            <span class="type">error</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	container, err := l.getContainer(ctx, r.ContainerID) <span class="comment">// å‰é¢å†™ dbï¼Œè¿™é‡Œè¯» db è·å– cotnainer çš„ä¿¡æ¯ã€‚</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.ToGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	opts := runtime.CreateOpts&#123;</span><br><span class="line">		Spec: container.Spec,</span><br><span class="line">		IO: runtime.IO&#123;</span><br><span class="line">			Stdin:    r.Stdin,</span><br><span class="line">			Stdout:   r.Stdout,</span><br><span class="line">			Stderr:   r.Stderr,</span><br><span class="line">			Terminal: r.Terminal,</span><br><span class="line">		&#125;,</span><br><span class="line">		Checkpoint:     checkpointPath,</span><br><span class="line">		Runtime:        container.Runtime.Name,</span><br><span class="line">		RuntimeOptions: container.Runtime.Options,</span><br><span class="line">		TaskOptions:    r.Options,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> r.Rootfs &#123;</span><br><span class="line">		opts.Rootfs = <span class="built_in">append</span>(opts.Rootfs, mount.Mount&#123;</span><br><span class="line">			Type:    m.Type,</span><br><span class="line">			Source:  m.Source,</span><br><span class="line">			Options: m.Options,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	runtime, err := l.getRuntime(container.Runtime.Name) <span class="comment">// runtime åå­—ï¼Œç°åœ¨æœ‰ v1.linux, v2 ä¸¤ä¸ªå®ç°</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	c, err := runtime.Create(ctx, r.ContainerID, opts) <span class="comment">// ç›®å‰çº¿ä¸Šä½¿ç”¨ v1ï¼ˆç›®å‰æ˜¯é€šè¿‡ containerd-shim åé¢çš„å‚æ•°åˆ¤æ–­å‡ºæ¥çš„ï¼Œv1/v2 å‚æ•°å·®åˆ«å¾ˆæ˜æ˜¾</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.ToGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> fast path for getting pid on create</span></span><br><span class="line">	<span class="keyword">if</span> err := l.monitor.Monitor(c); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;monitor task&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	state, err := c.State(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.G(ctx).Error(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;api.CreateTaskResponse&#123;</span><br><span class="line">		ContainerID: r.ContainerID,</span><br><span class="line">		Pid:         state.Pid,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è¿™é‡Œä½¿ç”¨ <code>v1 Linux runtime</code> çš„<code>create</code> æ–¹æ³•</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runtime)</span></span> Create(ctx context.Context, id <span class="type">string</span>, opts runtime.CreateOpts) (_ runtime.Task, err <span class="type">error</span>) &#123;</span><br><span class="line">	namespace, err := namespaces.NamespaceRequired(ctx) <span class="comment">// è¿™é‡Œ ns æ˜¯ mobyï¼Œå°±æ˜¯ docker é‚£ä¸ªæ–°çš„åå­—</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := identifiers.Validate(id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;invalid task id&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ropts, err := r.getRuncOptions(ctx, id)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bundle, err := newBundle(id, <span class="comment">// newBundle creates a new bundle on disk at the provided path for the given id</span></span><br><span class="line">		filepath.Join(r.state, namespace),</span><br><span class="line">		filepath.Join(r.root, namespace),</span><br><span class="line">		opts.Spec.Value)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			bundle.Delete()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ShimLocal is a ShimOpt for using an in process shim implementation</span></span><br><span class="line">	shimopt := ShimLocal(r.config, r.events)</span><br><span class="line">	<span class="keyword">if</span> !r.config.NoShim &#123; <span class="comment">// åœ¨æ­£å¸¸çš„é€»è¾‘ä¼šå‘½ä¸­è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨äº† shim</span></span><br><span class="line">		<span class="keyword">var</span> cgroup <span class="type">string</span></span><br><span class="line">		<span class="keyword">if</span> opts.TaskOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">			v, err := typeurl.UnmarshalAny(opts.TaskOptions)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			cgroup = v.(*runctypes.CreateOptions).ShimCgroup</span><br><span class="line">		&#125;</span><br><span class="line">		exitHandler := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			log.G(ctx).WithField(<span class="string">&quot;id&quot;</span>, id).Info(<span class="string">&quot;shim reaped&quot;</span>)</span><br><span class="line">			t, err := r.tasks.Get(ctx, id)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// Task was never started or was already successfully deleted</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			lc := t.(*Task)</span><br><span class="line"></span><br><span class="line">			log.G(ctx).WithFields(logrus.Fields&#123;</span><br><span class="line">				<span class="string">&quot;id&quot;</span>:        id,</span><br><span class="line">				<span class="string">&quot;namespace&quot;</span>: namespace,</span><br><span class="line">			&#125;).Warn(<span class="string">&quot;cleaning up after killed shim&quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> err = r.cleanupAfterDeadShim(context.Background(), bundle, namespace, id, lc.pid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.G(ctx).WithError(err).WithFields(logrus.Fields&#123;</span><br><span class="line">					<span class="string">&quot;id&quot;</span>:        id,</span><br><span class="line">					<span class="string">&quot;namespace&quot;</span>: namespace,</span><br><span class="line">				&#125;).Warn(<span class="string">&quot;failed to clean up after killed shim&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;   </span><br><span class="line">		shimopt = ShimRemote(r.config, r.address, cgroup, exitHandler) </span><br><span class="line">    <span class="comment">// è¿™é‡Œç›®å‰åªæ˜¯æ„å»ºå¥½äº† shimopt è¿™ä¸ªå‡½æ•°ï¼Œç›®å‰è¿˜æ²¡æœ‰çœŸçš„è°ƒç”¨</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shimopt è¿™ä¸ªå‡½æ•°å‡†å¤‡å¥½äº†ï¼Œè¿™é‡Œæ‰å¼€å§‹è°ƒç”¨å¯åŠ¨ shim å¹¶è¿”å› shim client</span></span><br><span class="line">	s, err := bundle.NewShimClient(ctx, namespace, shimopt, ropts) </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> kerr := s.KillShim(ctx); kerr != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.G(ctx).WithError(err).Error(<span class="string">&quot;failed to kill shim&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	rt := r.config.Runtime</span><br><span class="line">	<span class="keyword">if</span> ropts != <span class="literal">nil</span> &amp;&amp; ropts.Runtime != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		rt = ropts.Runtime</span><br><span class="line">	&#125;</span><br><span class="line">	sopts := &amp;shim.CreateTaskRequest&#123;</span><br><span class="line">		ID:         id,</span><br><span class="line">		Bundle:     bundle.path,</span><br><span class="line">		Runtime:    rt,</span><br><span class="line">		Stdin:      opts.IO.Stdin,</span><br><span class="line">		Stdout:     opts.IO.Stdout,</span><br><span class="line">		Stderr:     opts.IO.Stderr,</span><br><span class="line">		Terminal:   opts.IO.Terminal,</span><br><span class="line">		Checkpoint: opts.Checkpoint,</span><br><span class="line">		Options:    opts.TaskOptions,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> opts.Rootfs &#123;</span><br><span class="line">		sopts.Rootfs = <span class="built_in">append</span>(sopts.Rootfs, &amp;types.Mount&#123;</span><br><span class="line">			Type:    m.Type,</span><br><span class="line">			Source:  m.Source,</span><br><span class="line">			Options: m.Options,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Create a new initial process and container with the underlying OCI runtime </span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">	cr, err := s.Create(ctx, sopts) <span class="comment">// ä¹Ÿå°±æ˜¯ shim çš„ create æ–¹æ³•ï¼ŒæŒ‰ä½ä¸è¡¨åˆ°è®² containerd-shim å†è¯´ã€‚</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.FromGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	t, err := newTask(id, namespace, <span class="type">int</span>(cr.Pid), s, r.events, r.tasks, bundle)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := r.tasks.Add(ctx, t); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ... ç§»é™¤ä¸€éƒ¨åˆ† event ç›¸å…³é€»è¾‘</span></span><br><span class="line">	<span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>åŸºäºä»¥ä¸Šå…¶å®å°±å·²ç»å‡†å¤‡å¥½äº† <code>task</code> å¹¶å¯åŠ¨ï¼Œåœ¨ <code>cotnainerd</code> ä¸­è°ƒç”¨ä½¿ç”¨å‘½ä»¤è¡Œè°ƒç”¨ <code>containerd-shim</code>ã€‚å…¶ä½™çš„é€»è¾‘è¦åˆ° <code>cotnainerd-shim</code> ä¸­å»æ¢ç´¢äº†ã€‚</p>
<h2 id="TasksServer-Start-æ–¹æ³•çš„å®ç°"><a href="#TasksServer-Start-æ–¹æ³•çš„å®ç°" class="headerlink" title="TasksServer.Start æ–¹æ³•çš„å®ç°"></a>TasksServer.Start æ–¹æ³•çš„å®ç°</h2><p><code>create</code> æ“ä½œçœ‹å®Œäº†çœ‹ä¸€ä¸‹ <code>start</code> æ–¹æ³•æ˜¯å¦‚ä½•å®ç°çš„ï¼Œæœç´¢å…¶å¯¹åº”çš„æ¥å£ <code>/containerd.services.tasks.v1.Tasks/Start</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span></span> Start(ctx context.Context, r *api.StartRequest) (*api.StartResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> s.local.Start(ctx, r)</span><br></pre></td></tr></table></figure>

<p>ä¾ç„¶æ˜¯ <code>v1.linux</code> å®ç°</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *local)</span></span> Start(ctx context.Context, r *api.StartRequest, _ ...grpc.CallOption) (*api.StartResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	t, err := l.getTask(ctx, r.ContainerID) <span class="comment">// è¿™é‡Œå°±æ˜¯ä» bucket db ä¸­è·å–æ•°æ®</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	p := runtime.Process(t)</span><br><span class="line">	<span class="keyword">if</span> r.ExecID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p, err = t.Process(ctx, r.ExecID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.ToGRPC(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := p.Start(ctx); err != <span class="literal">nil</span> &#123; <span class="comment">// Start the container&#x27;s user defined process</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.ToGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	state, err := p.State(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.ToGRPC(err) <span class="comment">// ToGRPC</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;api.StartResponse&#123;</span><br><span class="line">		Pid: state.Pid,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Task)</span></span> Start(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">	t.mu.Lock()</span><br><span class="line">	hasCgroup := t.cg != <span class="literal">nil</span></span><br><span class="line">	t.mu.Unlock()</span><br><span class="line">	r, err := t.shim.Start(ctx, &amp;shim.StartRequest&#123; <span class="comment">// è°ƒç”¨ shim çš„ start</span></span><br><span class="line">		ID: t.id,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>åŸºäºä»¥ä¸Šä¸¤ä¸ªæ¥å£å…¶å®å‘ç°æ›´å¤šå·¥ä½œ <code>containerd</code> æ”¾åˆ°äº† <code>conteinrd-shim</code> ä¸­å®Œæˆäº†ã€‚</p>
<h1 id="containerd-shim-çš„å¦‚ä½•å·¥ä½œ"><a href="#containerd-shim-çš„å¦‚ä½•å·¥ä½œ" class="headerlink" title="containerd-shim çš„å¦‚ä½•å·¥ä½œ"></a>containerd-shim çš„å¦‚ä½•å·¥ä½œ</h1><p>åˆçœ‹ <code>containerd-shim</code> çš„å®ç°æ¨¡å‹ä¹Ÿä¸æ˜¯å¾ˆå¤æ‚ï¼Œä¸»å‡½æ•°ä¸­è°ƒç”¨ä¸€ä¸ª <code>rpc</code> æœåŠ¡å¸¸é©»åå°ï¼Œå¯¹å¤–æä¾›æœåŠ¡ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := executeShim(); err != <span class="literal">nil</span> &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">executeShim</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">....</span><br><span class="line">	&#125;</span><br><span class="line">	server, err := newServer()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed creating server&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	sv, err := shim.NewService(</span><br><span class="line">		shim.Config&#123;</span><br><span class="line">			Path:          path,</span><br><span class="line">			Namespace:     namespaceFlag,</span><br><span class="line">			WorkDir:       workdirFlag,</span><br><span class="line">			Criu:          criuFlag,</span><br><span class="line">			SystemdCgroup: systemdCgroupFlag,</span><br><span class="line">			RuntimeRoot:   runtimeRootFlag,</span><br><span class="line">		&#125;,</span><br><span class="line">		&amp;remoteEventsPublisher&#123;address: addressFlag&#125;,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	logrus.Debug(<span class="string">&quot;registering ttrpc server&quot;</span>)</span><br><span class="line">	shimapi.RegisterShimService(server, sv) <span class="comment">// ttrpc </span></span><br><span class="line"></span><br><span class="line">	socket := socketFlag</span><br><span class="line">	<span class="keyword">if</span> err := serve(context.Background(), server, socket); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>å”¯ä¸€å€¼å¾—ä¸€æçš„å°±æ˜¯<code>ttrpc</code>æ˜¯ä½å†…å­˜ä¸‹é¢çš„ rpc åè®®ï¼ŒåŸºäº grpc çš„ä½å†…å­˜ç‰ˆæœ¬ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterShimService</span><span class="params">(srv *ttrpc.Server, svc ShimService)</span></span> &#123;</span><br><span class="line">	srv.Register(<span class="string">&quot;containerd.runtime.linux.shim.v1.Shim&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]ttrpc.Method&#123;</span><br><span class="line">...</span><br><span class="line">		<span class="string">&quot;Create&quot;</span>: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, unmarshal <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">			<span class="keyword">var</span> req CreateTaskRequest</span><br><span class="line">			<span class="keyword">if</span> err := unmarshal(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> svc.Create(ctx, &amp;req)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;Start&quot;</span>: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, unmarshal <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">			<span class="keyword">var</span> req StartRequest</span><br><span class="line">			<span class="keyword">if</span> err := unmarshal(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> svc.Start(ctx, &amp;req)</span><br><span class="line">		&#125;,</span><br></pre></td></tr></table></figure>

<p>è¿™æ¬¡åªå…³å¿ƒ <code>shim</code> çš„ <code>Create</code> ä¸ <code>Start</code> å®ç°ã€‚</p>
<h2 id="contained-shim-create"><a href="#contained-shim-create" class="headerlink" title="contained-shim create"></a>contained-shim create</h2><p>è¿™ä¸ªå°±æ˜¯<code>containerd</code>çš„<code>s.Create(ctx, sopts)</code>å®ç°çš„åœ°æ–¹</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *local)</span></span> Create(ctx context.Context, in *shimapi.CreateTaskRequest) (*shimapi.CreateTaskResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> c.s.Create(ctx, in)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>create</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new initial process and container with the underlying OCI runtime</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> Create(ctx context.Context, r *shimapi.CreateTaskRequest) (_ *shimapi.CreateTaskResponse, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> mounts []proc.Mount</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> r.Rootfs &#123;</span><br><span class="line">		mounts = <span class="built_in">append</span>(mounts, proc.Mount&#123;</span><br><span class="line">			Type:    m.Type,</span><br><span class="line">			Source:  m.Source,</span><br><span class="line">			Target:  m.Target,</span><br><span class="line">			Options: m.Options,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	config := &amp;proc.CreateConfig&#123;</span><br><span class="line">		ID:               r.ID,</span><br><span class="line">		Bundle:           r.Bundle,</span><br><span class="line">		Runtime:          r.Runtime,</span><br><span class="line">		Rootfs:           mounts,</span><br><span class="line">		Terminal:         r.Terminal,</span><br><span class="line">		Stdin:            r.Stdin,</span><br><span class="line">		Stdout:           r.Stdout,</span><br><span class="line">		Stderr:           r.Stderr,</span><br><span class="line">		Checkpoint:       r.Checkpoint,</span><br><span class="line">		ParentCheckpoint: r.ParentCheckpoint,</span><br><span class="line">		Options:          r.Options,</span><br><span class="line">	&#125;</span><br><span class="line">	rootfs := filepath.Join(r.Bundle, <span class="string">&quot;rootfs&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(rootfs <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err2 := mount.UnmountAll(rootfs, <span class="number">0</span>); err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.G(ctx).WithError(err2).Warn(<span class="string">&quot;Failed to cleanup rootfs mount&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(rootfs)</span><br><span class="line">	<span class="keyword">for</span> _, rm := <span class="keyword">range</span> mounts &#123;</span><br><span class="line">		m := &amp;mount.Mount&#123;</span><br><span class="line">			Type:    rm.Type,</span><br><span class="line">			Source:  rm.Source,</span><br><span class="line">			Options: rm.Options,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := m.Mount(rootfs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;failed to mount rootfs component %v&quot;</span>, m)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(mounts) == <span class="number">0</span> &#123;</span><br><span class="line">		rootfs = <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	process, err := newInit(</span><br><span class="line">		ctx,</span><br><span class="line">		s.config.Path,</span><br><span class="line">		s.config.WorkDir,</span><br><span class="line">		s.config.RuntimeRoot,</span><br><span class="line">		s.config.Namespace,</span><br><span class="line">		s.config.Criu,</span><br><span class="line">		s.config.SystemdCgroup,</span><br><span class="line">		s.platform,</span><br><span class="line">		config,</span><br><span class="line">		rootfs,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.ToGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := process.Create(ctx, config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.ToGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// save the main task id and bundle to the shim for additional requests</span></span><br><span class="line">	s.id = r.ID</span><br><span class="line">	s.bundle = r.Bundle</span><br><span class="line">	pid := process.Pid()</span><br><span class="line">	s.processes[r.ID] = process</span><br><span class="line">	<span class="keyword">return</span> &amp;shimapi.CreateTaskResponse&#123;</span><br><span class="line">		Pid: <span class="type">uint32</span>(pid),</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the process with the provided config</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Init)</span></span> Create(ctx context.Context, r *CreateConfig) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		err    <span class="type">error</span></span><br><span class="line">		socket *runc.Socket</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> r.Terminal &#123;</span><br><span class="line">		<span class="keyword">if</span> socket, err = runc.NewTempConsoleSocket(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to create OCI runtime console socket&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> socket.Close()</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> hasNoIO(r) &#123;</span><br><span class="line">		<span class="keyword">if</span> p.io, err = runc.NewNullIO(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;creating new NULL IO&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p.io, err = runc.NewPipeIO(p.IoUID, p.IoGID, withConditionalIO(p.stdio)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to create OCI runtime io pipes&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pidFile := filepath.Join(p.Bundle, InitPidFile)</span><br><span class="line">	<span class="keyword">if</span> r.Checkpoint != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		opts := &amp;runc.RestoreOpts&#123;</span><br><span class="line">			CheckpointOpts: runc.CheckpointOpts&#123;</span><br><span class="line">				ImagePath:  r.Checkpoint,</span><br><span class="line">				WorkDir:    p.WorkDir,</span><br><span class="line">				ParentPath: r.ParentCheckpoint,</span><br><span class="line">			&#125;,</span><br><span class="line">			PidFile:     pidFile,</span><br><span class="line">			IO:          p.io,</span><br><span class="line">			NoPivot:     p.NoPivotRoot,</span><br><span class="line">			Detach:      <span class="literal">true</span>,</span><br><span class="line">			NoSubreaper: <span class="literal">true</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		p.initState = &amp;createdCheckpointState&#123;</span><br><span class="line">			p:    p,</span><br><span class="line">			opts: opts,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	opts := &amp;runc.CreateOpts&#123;</span><br><span class="line">		PidFile:      pidFile,</span><br><span class="line">		IO:           p.io,</span><br><span class="line">		NoPivot:      p.NoPivotRoot,</span><br><span class="line">		NoNewKeyring: p.NoNewKeyring,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> socket != <span class="literal">nil</span> &#123;</span><br><span class="line">		opts.ConsoleSocket = socket</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := p.runtime.Create(ctx, r.ID, r.Bundle, opts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p.runtimeError(err, <span class="string">&quot;OCI runtime create failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r.Stdin != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		sc, err := fifo.OpenFifo(context.Background(), r.Stdin, syscall.O_WRONLY|syscall.O_NONBLOCK, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to open stdin fifo %s&quot;</span>, r.Stdin)</span><br><span class="line">		&#125;</span><br><span class="line">		p.stdin = sc</span><br><span class="line">		p.closers = <span class="built_in">append</span>(p.closers, sc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> copyWaitGroup sync.WaitGroup</span><br><span class="line">	ctx, cancel := context.WithTimeout(ctx, <span class="number">30</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="keyword">if</span> socket != <span class="literal">nil</span> &#123;</span><br><span class="line">		console, err := socket.ReceiveMaster()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to retrieve console master&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		console, err = p.Platform.CopyConsole(ctx, console, r.Stdin, r.Stdout, r.Stderr, &amp;p.wg, &amp;copyWaitGroup)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to start console copy&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		p.console = console</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> !hasNoIO(r) &#123;</span><br><span class="line">		<span class="keyword">if</span> err := copyPipes(ctx, p.io, r.Stdin, r.Stdout, r.Stderr, &amp;p.wg, &amp;copyWaitGroup); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to start io pipe copy&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	copyWaitGroup.Wait()</span><br><span class="line">	pid, err := runc.ReadPidFile(pidFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to retrieve OCI runtime container pid&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	p.pid = pid</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create creates a new container and returns its pid if it was created successfully</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runc)</span></span> Create(context context.Context, id, bundle <span class="type">string</span>, opts *CreateOpts) <span class="type">error</span> &#123;</span><br><span class="line">	args := []<span class="type">string</span>&#123;<span class="string">&quot;create&quot;</span>, <span class="string">&quot;--bundle&quot;</span>, bundle&#125; <span class="comment">// è¿™é‡Œå°±æ˜¯ runc create --bundle çš„å‘½ä»¤è¡Œäº†</span></span><br><span class="line">	<span class="keyword">if</span> opts != <span class="literal">nil</span> &#123;</span><br><span class="line">		oargs, err := opts.args()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		args = <span class="built_in">append</span>(args, oargs...)</span><br><span class="line">	&#125;</span><br><span class="line">	cmd := r.command(context, <span class="built_in">append</span>(args, id)...)</span><br><span class="line">	<span class="keyword">if</span> opts != <span class="literal">nil</span> &amp;&amp; opts.IO != <span class="literal">nil</span> &#123;</span><br><span class="line">		opts.Set(cmd)</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.ExtraFiles = opts.ExtraFiles</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cmd.Stdout == <span class="literal">nil</span> &amp;&amp; cmd.Stderr == <span class="literal">nil</span> &#123;</span><br><span class="line">		data, err := cmdOutput(cmd, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s: %s&quot;</span>, err, data)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="contained-shim-start"><a href="#contained-shim-start" class="headerlink" title="contained-shim start"></a>contained-shim start</h2><p>åŸºäº containerd çš„åˆ†æå…¶å®è¿˜çœ‹åˆ°è°ƒç”¨ <code>t.shim.Start(ctx, &amp;shim.StartRequest&#123;ID: t.id&#125;)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *local)</span></span> Start(ctx context.Context, in *shimapi.StartRequest) (*shimapi.StartResponse, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> c.s.Start(ctx, in)  </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start a process</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> Start(ctx context.Context, r *shimapi.StartRequest) (*shimapi.StartResponse, <span class="type">error</span>) &#123;</span><br><span class="line">   p, err := s.getExecProcess(r.ID) <span class="comment">// get exec process </span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := p.Start(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;shimapi.StartResponse&#123;</span><br><span class="line">      ID:  p.ID(),</span><br><span class="line">      Pid: <span class="type">uint32</span>(p.Pid()),</span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *execProcess)</span></span> Start(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">   e.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> e.mu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> e.execState.Start(ctx) <span class="comment">// execState è¿™ä¼šåº”è¯¥æ˜¯ createdï¼Œå› ä¸ºå‰é¢å·²ç» runc create --bundle äº†</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *createdState)</span></span> Start(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := s.p.start(ctx); err != <span class="literal">nil</span> &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Init)</span></span> start(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">	err := p.runtime.Start(ctx, p.id)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start will start an already created container</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runc)</span></span> Start(context context.Context, id <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> r.runOrError(r.command(context, <span class="string">&quot;start&quot;</span>, id)) <span class="comment">// è¿™é‡Œä¼šè¿è¡Œï¼Œr.command è¿”å›çš„ exec.Cmd object </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runc)</span></span> command(context context.Context, args ...<span class="type">string</span>) *exec.Cmd &#123;</span><br><span class="line">   command := r.Command</span><br><span class="line">   <span class="keyword">if</span> command == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      command = DefaultCommand <span class="comment">// DefaultCommand = &quot;runc&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   cmd := exec.CommandContext(context, command, <span class="built_in">append</span>(r.args(), args...)...)</span><br><span class="line">   cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">      Setpgid: r.Setpgid,</span><br><span class="line">   &#125;</span><br><span class="line">   cmd.Env = filterEnv(os.Environ(), <span class="string">&quot;NOTIFY_SOCKET&quot;</span>) <span class="comment">// NOTIFY_SOCKET introduces a special behavior in runc but should only be set if invoked from systemd</span></span><br><span class="line">   <span class="keyword">if</span> r.PdeathSignal != <span class="number">0</span> &#123;</span><br><span class="line">      cmd.SysProcAttr.Pdeathsig = r.PdeathSignal</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>é‚£ä¹ˆå…¶å®åˆ°è¿™é‡Œä¹Ÿå°±çœ‹å®Œäº† <code>containrd-shim</code> è°ƒç”¨ <code>runc create </code>&#x2F; <code>runc start </code></p>
<h1 id="runc"><a href="#runc" class="headerlink" title="runc"></a>runc</h1><p>å‰é¢çœ‹è¿‡äº† <code>containerd-shim</code> è°ƒç”¨äº† <code>runc create</code> ä¸ <code>runc start</code>ï¼Œè¿™é‡Œæ¢³ç†ä¸€ä¸‹ <code>runc</code> çš„ç›¸å…³ä»£ç é€»è¾‘ã€‚</p>
<h2 id="run-create-â€“bundle"><a href="#run-create-â€“bundle" class="headerlink" title="run create â€“bundle"></a>run create â€“bundle</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startContainer</span><span class="params">(context *cli.Context, spec *specs.Spec, action CtAct, criuOpts *libcontainer.CriuOpts)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	id := context.Args().First()</span><br><span class="line">	<span class="keyword">if</span> id == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, errEmptyID</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	notifySocket := newNotifySocket(context, os.Getenv(<span class="string">&quot;NOTIFY_SOCKET&quot;</span>), id)</span><br><span class="line">	<span class="keyword">if</span> notifySocket != <span class="literal">nil</span> &#123;</span><br><span class="line">		notifySocket.setupSpec(context, spec)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	container, err := createContainer(context, id, spec) <span class="comment">// å‡†å¤‡ container åœ¨ runc å†…å­˜ä¸­çš„ object</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> notifySocket != <span class="literal">nil</span> &#123;</span><br><span class="line">		err := notifySocket.setupSocket()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Support on-demand socket activation by passing file descriptors into the container init process.</span></span><br><span class="line">	listenFDs := []*os.File&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> os.Getenv(<span class="string">&quot;LISTEN_FDS&quot;</span>) != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		listenFDs = activation.Files(<span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logLevel := <span class="string">&quot;info&quot;</span></span><br><span class="line">	<span class="keyword">if</span> context.GlobalBool(<span class="string">&quot;debug&quot;</span>) &#123;</span><br><span class="line">		logLevel = <span class="string">&quot;debug&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r := &amp;runner&#123;</span><br><span class="line">		enableSubreaper: !context.Bool(<span class="string">&quot;no-subreaper&quot;</span>),</span><br><span class="line">		shouldDestroy:   <span class="literal">true</span>,</span><br><span class="line">		container:       container,</span><br><span class="line">		listenFDs:       listenFDs,</span><br><span class="line">		notifySocket:    notifySocket,</span><br><span class="line">		consoleSocket:   context.String(<span class="string">&quot;console-socket&quot;</span>),</span><br><span class="line">		detach:          context.Bool(<span class="string">&quot;detach&quot;</span>),</span><br><span class="line">		pidFile:         context.String(<span class="string">&quot;pid-file&quot;</span>),</span><br><span class="line">		preserveFDs:     context.Int(<span class="string">&quot;preserve-fds&quot;</span>),</span><br><span class="line">		action:          action,</span><br><span class="line">		criuOpts:        criuOpts,</span><br><span class="line">		init:            <span class="literal">true</span>,</span><br><span class="line">		logLevel:        logLevel,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r.run(spec.Process) <span class="comment">// run</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è°ƒç”¨ <code>createContainer</code>åˆ›å»º <code>cotnainer</code> å¯¹è±¡ï¼Œå®é™…çš„åˆ›å»ºç”±å¹³å°ç›¸å…³çš„å·¥å‚å‡½æ•°å®ç°</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createContainer</span><span class="params">(context *cli.Context, id <span class="type">string</span>, spec *specs.Spec)</span></span> (libcontainer.Container, <span class="type">error</span>) &#123;</span><br><span class="line">	rootlessCg, err := shouldUseRootlessCgroupManager(context)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	config, err := specconv.CreateLibcontainerConfig(&amp;specconv.CreateOpts&#123;</span><br><span class="line">		CgroupName:       id,</span><br><span class="line">		UseSystemdCgroup: context.GlobalBool(<span class="string">&quot;systemd-cgroup&quot;</span>),</span><br><span class="line">		NoPivotRoot:      context.Bool(<span class="string">&quot;no-pivot&quot;</span>),</span><br><span class="line">		NoNewKeyring:     context.Bool(<span class="string">&quot;no-new-keyring&quot;</span>),</span><br><span class="line">		Spec:             spec,</span><br><span class="line">		RootlessEUID:     os.Geteuid() != <span class="number">0</span>,</span><br><span class="line">		RootlessCgroups:  rootlessCg,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	factory, err := loadFactory(context) <span class="comment">// è¿”å› Linux çš„å®ç° InitPath å­—æ®µä¸º /proc/self/exeï¼ŒInitArgs å­—æ®µä¸º []string&#123;os.Args[0], &quot;init&quot;&#125;,</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> factory.Create(id, config)</span><br></pre></td></tr></table></figure>

<p><code>factory.Create</code> åˆ›å»ºè¿”å›ä¸€ä¸ª <code>container</code>ç»“æ„ä½“ï¼Œå…¶ä¸­ container ç»“æ„ä½“</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c := &amp;linuxContainer&#123;</span><br><span class="line">	id:            id,</span><br><span class="line">	root:          containerRoot, <span class="comment">//è¿™é‡Œæ˜¯ cotnainer çš„ root ç›®å½•</span></span><br><span class="line">	config:        config, </span><br><span class="line">	initPath:      l.InitPath, <span class="comment">// init path /proc/self/exe</span></span><br><span class="line">	initArgs:      l.InitArgs, <span class="comment">// []string&#123;os.Args[0].&#125;</span></span><br><span class="line">	criuPath:      l.CriuPath,</span><br><span class="line">	newuidmapPath: l.NewuidmapPath,</span><br><span class="line">	newgidmapPath: l.NewgidmapPath,</span><br><span class="line">	cgroupManager: l.NewCgroupsManager(config.Cgroups, <span class="literal">nil</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è¿”å›ä¸Šè¿°ç»“æ„ä½“ï¼Œç»§ç»­å›åˆ°åˆ°ä¸Šå±‚ä»£ç ç»§ç»­æ‰§è¡Œåˆ°<code>r.run(spec.Process)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *runner)</span></span> run(config *specs.Process) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">	process, err := newProcess(*config, r.init, r.logLevel)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> r.action &#123;</span><br><span class="line">	<span class="keyword">case</span> CT_ACT_CREATE:</span><br><span class="line">		err = r.container.Start(process) <span class="comment">// è¿™æ¬¡è¡Œä¸ºä¼šåˆ°è¿™ä¸ªæµç¨‹</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>å›åˆ°<code> r.container.Start(process)</code> ç»§ç»­æ‰§è¡Œ</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> Start(process *Process) <span class="type">error</span> &#123;</span><br><span class="line">	c.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> process.Init &#123; <span class="comment">// ä½¿ç”¨ create è¿™é‡Œå°±æ˜¯ true</span></span><br><span class="line">		<span class="keyword">if</span> err := c.createExecFifo(); err != <span class="literal">nil</span> &#123; <span class="comment">// create ä¸€ä¸ª exec.fifo ç”¨ä¸è¿›ç¨‹é—´é€šä¿¡ï¼Œåªæœ‰å†™æ—¶ä¼šè¢«é˜»å¡ï¼Œè¯»å†™éƒ½åœ¨æ—¶æ‰ä¼šæ­£å¸¸è¿è¡Œ</span></span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := c.start(process); err != <span class="literal">nil</span> &#123; <span class="comment">// è¿™æ‰æ˜¯æœ¬æ¬¡å…³æ³¨ç‚¹</span></span><br><span class="line">		<span class="keyword">if</span> process.Init &#123;</span><br><span class="line">			c.deleteExecFifo()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>c.start(process)</code>çš„å®ç°</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> start(process *Process) <span class="type">error</span> &#123;</span><br><span class="line">	parent, err := c.newParentProcess(process) <span class="comment">// åˆ›å»ºçˆ¶è¿›ç¨‹ï¼Œä»£ç åœ¨ä¸‹é¢ review</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;creating new parent process&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	parent.forwardChildLogs()</span><br><span class="line">	<span class="keyword">if</span> err := parent.start(); err != <span class="literal">nil</span> &#123; <span class="comment">// è¿™é‡Œåˆ›å»ºçˆ¶è¿›ç¨‹çš„ startï¼Œå…¶å®ä¹Ÿå°±æ˜¯ runc init</span></span><br><span class="line">		<span class="comment">// terminate the process to ensure that it properly is reaped.</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>newParentProcess()</code>å…¶å®å°±æ˜¯å‘½ä»¤è¡Œä¸º<code> runc init</code> çš„ <code>parentProcess</code>ï¼Œè¿”å›ç»™ä¸Šé¢è°ƒç”¨<code>parent.start()</code>ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> newParentProcess(p *Process) (parentProcess, <span class="type">error</span>) &#123;</span><br><span class="line">	parentInitPipe, childInitPipe, err := utils.NewSockPair(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, newSystemErrorWithCause(err, <span class="string">&quot;creating new init pipe&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	messageSockPair := filePair&#123;parentInitPipe, childInitPipe&#125;</span><br><span class="line"></span><br><span class="line">	parentLogPipe, childLogPipe, err := os.Pipe()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Unable to create the log pipe:  %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	logFilePair := filePair&#123;parentLogPipe, childLogPipe&#125;</span><br><span class="line"></span><br><span class="line">	cmd, err := c.commandTemplate(p, childInitPipe, childLogPipe) <span class="comment">// å‡†å¤‡å‘½ä»¤è¡Œ </span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, newSystemErrorWithCause(err, <span class="string">&quot;creating new command template&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !p.Init &#123;</span><br><span class="line">		<span class="keyword">return</span> c.newSetnsProcess(p, cmd, messageSockPair, logFilePair) <span class="comment">// å¦‚æœä¸æ˜¯ initï¼Œæ‰€ä»¥è¿™ä¸€æ¬¡ä¸å…³å¿ƒè¿™é‡Œ</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We only set up fifoFd if we&#x27;re not doing a `runc exec`. The historic</span></span><br><span class="line">	<span class="comment">// reason for this is that previously we would pass a dirfd that allowed</span></span><br><span class="line">	<span class="comment">// for container rootfs escape (and not doing it in `runc exec` avoided</span></span><br><span class="line">	<span class="comment">// that problem), but we no longer do that. However, there&#x27;s no need to do</span></span><br><span class="line">	<span class="comment">// this for `runc exec` so we just keep it this way to be safe.</span></span><br><span class="line">	<span class="keyword">if</span> err := c.includeExecFifo(cmd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, newSystemErrorWithCause(err, <span class="string">&quot;including execfifo in cmd.Exec setup&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.newInitProcess(p, cmd, messageSockPair, logFilePair) <span class="comment">// è¿”å› initProcessï¼Œå…¶ä¸­ cmd ä¸º runc initï¼Œå¹¶ c.initProcess = init</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>parent.start()</code>  å°±æ˜¯å®é™…å¼€å§‹è¿è¡Œ <code>runc init</code>äº†</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *initProcess)</span></span> start() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> p.messageSockPair.parent.Close()</span><br><span class="line">	err := p.cmd.Start() <span class="comment">// å¯åŠ¨ runc init</span></span><br><span class="line">	p.process.ops = p</span><br><span class="line">	<span class="comment">// close the write-side of the pipes (controlled by child)</span></span><br><span class="line">	p.messageSockPair.child.Close()</span><br><span class="line">	p.logFilePair.child.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		p.process.ops = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;starting init process command&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Do this before syncing with child so that no children can escape the</span></span><br><span class="line">	<span class="comment">// cgroup. We don&#x27;t need to worry about not doing this and not being root</span></span><br><span class="line">	<span class="comment">// because we&#x27;d be using the rootless cgroup manager in that case.</span></span><br><span class="line">	<span class="keyword">if</span> err := p.manager.Apply(p.pid()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;applying cgroup configuration for process&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.intelRdtManager != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := p.intelRdtManager.Apply(p.pid()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;applying Intel RDT configuration for process&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> should not be the responsibility to call here</span></span><br><span class="line">			p.manager.Destroy()</span><br><span class="line">			<span class="keyword">if</span> p.intelRdtManager != <span class="literal">nil</span> &#123;</span><br><span class="line">				p.intelRdtManager.Destroy()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err := io.Copy(p.messageSockPair.parent, p.bootstrapData); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;copying bootstrap data to pipe&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	childPid, err := p.getChildPid() <span class="comment">// è·å– child çš„ pid</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;getting the final child&#x27;s pid from pipe&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save the standard descriptor names before the container process</span></span><br><span class="line">	<span class="comment">// can potentially move them (e.g., via dup2()).  If we don&#x27;t do this now,</span></span><br><span class="line">	<span class="comment">// we won&#x27;t know at checkpoint time which file descriptor to look up.</span></span><br><span class="line">	fds, err := getPipeFds(childPid)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCausef(err, <span class="string">&quot;getting pipe fds for pid %d&quot;</span>, childPid)</span><br><span class="line">	&#125;</span><br><span class="line">	p.setExternalDescriptors(fds)</span><br><span class="line">	<span class="comment">// Do this before syncing with child so that no children</span></span><br><span class="line">	<span class="comment">// can escape the cgroup</span></span><br><span class="line">	<span class="keyword">if</span> err := p.manager.Apply(childPid); err != <span class="literal">nil</span> &#123; <span class="comment">// è¿™é‡Œè®¾ç½®è°ƒç”¨å…·ä½“çš„å®ç°é…ç½® cgroup</span></span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;applying cgroup configuration for process&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.intelRdtManager != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := p.intelRdtManager.Apply(childPid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;applying Intel RDT configuration for process&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Now it&#x27;s time to setup cgroup namesapce</span></span><br><span class="line">	<span class="keyword">if</span> p.config.Config.Namespaces.Contains(configs.NEWCGROUP) &amp;&amp; p.config.Config.Namespaces.PathOf(configs.NEWCGROUP) == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _, err := p.messageSockPair.parent.Write([]<span class="type">byte</span>&#123;createCgroupns&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;sending synchronization value to init process&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for our first child to exit</span></span><br><span class="line">	<span class="keyword">if</span> err := p.waitForChildExit(childPid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;waiting for our first child to exit&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> should not be the responsibility to call here</span></span><br><span class="line">			p.manager.Destroy()</span><br><span class="line">			<span class="keyword">if</span> p.intelRdtManager != <span class="literal">nil</span> &#123;</span><br><span class="line">				p.intelRdtManager.Destroy()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">if</span> err := p.createNetworkInterfaces(); err != <span class="literal">nil</span> &#123; <span class="comment">// åˆ›å»ºç½‘ç»œæ¥å£</span></span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;creating network interfaces&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := p.sendConfig(); err != <span class="literal">nil</span> &#123; <span class="comment">// æŠŠé…ç½®å‘é€ç»™å­è¿›ç¨‹</span></span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;sending config to init process&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		sentRun    <span class="type">bool</span></span><br><span class="line">		sentResume <span class="type">bool</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	ierr := parseSync(p.messageSockPair.parent, <span class="function"><span class="keyword">func</span><span class="params">(sync *syncT)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> sync.Type &#123;</span><br><span class="line">		<span class="keyword">case</span> procReady:</span><br><span class="line">			<span class="comment">// set rlimits, this has to be done here because we lose permissions</span></span><br><span class="line">			<span class="comment">// to raise the limits once we enter a user-namespace</span></span><br><span class="line">			<span class="keyword">if</span> err := setupRlimits(p.config.Rlimits, p.pid()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;setting rlimits for ready process&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// call prestart hooks</span></span><br><span class="line">			<span class="keyword">if</span> !p.config.Config.Namespaces.Contains(configs.NEWNS) &#123;</span><br><span class="line">				<span class="comment">// Setup cgroup before prestart hook, so that the prestart hook could apply cgroup permissions.</span></span><br><span class="line">				<span class="keyword">if</span> err := p.manager.Set(p.config.Config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;setting cgroup config for ready process&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> p.intelRdtManager != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> err := p.intelRdtManager.Set(p.config.Config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;setting Intel RDT config for ready process&quot;</span>)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> p.config.Config.Hooks != <span class="literal">nil</span> &#123;</span><br><span class="line">					s, err := p.container.currentOCIState()</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// initProcessStartTime hasn&#x27;t been set yet.</span></span><br><span class="line">					s.Pid = p.cmd.Process.Pid</span><br><span class="line">					s.Status = <span class="string">&quot;creating&quot;</span></span><br><span class="line">					<span class="keyword">for</span> i, hook := <span class="keyword">range</span> p.config.Config.Hooks.Prestart &#123;</span><br><span class="line">						<span class="keyword">if</span> err := hook.Run(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> newSystemErrorWithCausef(err, <span class="string">&quot;running prestart hook %d&quot;</span>, i)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Sync with child.</span></span><br><span class="line">			<span class="keyword">if</span> err := writeSync(p.messageSockPair.parent, procRun); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;writing syncT &#x27;run&#x27;&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			sentRun = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> procHooks:</span><br><span class="line">			<span class="comment">// Setup cgroup before prestart hook, so that the prestart hook could apply cgroup permissions.</span></span><br><span class="line">			<span class="keyword">if</span> err := p.manager.Set(p.config.Config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;setting cgroup config for procHooks process&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> p.intelRdtManager != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err := p.intelRdtManager.Set(p.config.Config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;setting Intel RDT config for procHooks process&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> p.config.Config.Hooks != <span class="literal">nil</span> &#123;</span><br><span class="line">				s, err := p.container.currentOCIState()</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// initProcessStartTime hasn&#x27;t been set yet.</span></span><br><span class="line">				s.Pid = p.cmd.Process.Pid</span><br><span class="line">				s.Status = <span class="string">&quot;creating&quot;</span></span><br><span class="line">				<span class="keyword">for</span> i, hook := <span class="keyword">range</span> p.config.Config.Hooks.Prestart &#123;</span><br><span class="line">					<span class="keyword">if</span> err := hook.Run(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> newSystemErrorWithCausef(err, <span class="string">&quot;running prestart hook %d&quot;</span>, i)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Sync with child.</span></span><br><span class="line">			<span class="keyword">if</span> err := writeSync(p.messageSockPair.parent, procResume); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;writing syncT &#x27;resume&#x27;&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			sentResume = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> newSystemError(fmt.Errorf(<span class="string">&quot;invalid JSON payload from child&quot;</span>))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !sentRun &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(ierr, <span class="string">&quot;container init&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.config.Config.Namespaces.Contains(configs.NEWNS) &amp;&amp; !sentResume &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemError(fmt.Errorf(<span class="string">&quot;could not synchronise after executing prestart hooks with container process&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := unix.Shutdown(<span class="type">int</span>(p.messageSockPair.parent.Fd()), unix.SHUT_WR); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;shutting down init pipe&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Must be done after Shutdown so the child will exit and we can wait for it.</span></span><br><span class="line">	<span class="keyword">if</span> ierr != <span class="literal">nil</span> &#123;</span><br><span class="line">		p.wait()</span><br><span class="line">		<span class="keyword">return</span> ierr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è¿è¡Œåˆ°è¿™é‡Œä¹Ÿå°±æ˜¯ <code>runc create</code> è¦è¿”å›äº†ï¼Œä½†æ˜¯å­è¿›ç¨‹çš„ <code>runc init</code> å› ä¸ºçˆ¶è¿›ç¨‹çš„é€€å‡ºè¢« <code>1</code> å·è¿›ç¨‹æ¥ç®¡ã€‚</p>
<h2 id="runc-init"><a href="#runc-init" class="headerlink" title="runc init"></a>runc init</h2><p>è¿™ä¸ªå°±æ˜¯ <code>contianer</code> å¯åŠ¨çš„æ—¶å€™<code>swap</code>å‰çš„è¿›ç¨‹</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartInitialization loads a container by opening the pipe fd from the parent to read the configuration and state</span></span><br><span class="line"><span class="comment">// This is a low level implementation detail of the reexec and should not be consumed externally</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LinuxFactory)</span></span> StartInitialization() (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		pipefd, fifofd <span class="type">int</span></span><br><span class="line">		consoleSocket  *os.File</span><br><span class="line">		envInitPipe    = os.Getenv(<span class="string">&quot;_LIBCONTAINER_INITPIPE&quot;</span>)</span><br><span class="line">		envFifoFd      = os.Getenv(<span class="string">&quot;_LIBCONTAINER_FIFOFD&quot;</span>)</span><br><span class="line">		envConsole     = os.Getenv(<span class="string">&quot;_LIBCONTAINER_CONSOLE&quot;</span>)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the INITPIPE.</span></span><br><span class="line">	pipefd, err = strconv.Atoi(envInitPipe)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to convert _LIBCONTAINER_INITPIPE=%s to int: %s&quot;</span>, envInitPipe, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		pipe = os.NewFile(<span class="type">uintptr</span>(pipefd), <span class="string">&quot;pipe&quot;</span>)</span><br><span class="line">		it   = initType(os.Getenv(<span class="string">&quot;_LIBCONTAINER_INITTYPE&quot;</span>))</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">defer</span> pipe.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Only init processes have FIFOFD.</span></span><br><span class="line">	fifofd = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">if</span> it == initStandard &#123;</span><br><span class="line">		<span class="keyword">if</span> fifofd, err = strconv.Atoi(envFifoFd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to convert _LIBCONTAINER_FIFOFD=%s to int: %s&quot;</span>, envFifoFd, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> envConsole != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		console, err := strconv.Atoi(envConsole)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to convert _LIBCONTAINER_CONSOLE=%s to int: %s&quot;</span>, envConsole, err)</span><br><span class="line">		&#125;</span><br><span class="line">		consoleSocket = os.NewFile(<span class="type">uintptr</span>(console), <span class="string">&quot;console-socket&quot;</span>)</span><br><span class="line">		<span class="keyword">defer</span> consoleSocket.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// clear the current process&#x27;s environment to clean any libcontainer</span></span><br><span class="line">	<span class="comment">// specific env vars.</span></span><br><span class="line">	os.Clearenv()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// We have an error during the initialization of the container&#x27;s init,</span></span><br><span class="line">		<span class="comment">// send it back to the parent process in the form of an initError.</span></span><br><span class="line">		<span class="keyword">if</span> werr := utils.WriteJSON(pipe, syncT&#123;procError&#125;); werr != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> werr := utils.WriteJSON(pipe, newSystemError(err)); werr != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;panic from initialization: %v, %v&quot;</span>, e, <span class="type">string</span>(debug.Stack()))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	i, err := newContainerInit(it, pipe, consoleSocket, fifofd)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If Init succeeds, syscall.Exec will not return, hence none of the defers will be called.</span></span><br><span class="line">	<span class="keyword">return</span> i.Init()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newContainerInit()</code>æ•´ä½“é€»è¾‘ä¹Ÿæ¯”è¾ƒç®€å•</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newContainerInit</span><span class="params">(t initType, pipe *os.File, consoleSocket *os.File, fifoFd <span class="type">int</span>)</span></span> (initer, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> config *initConfig</span><br><span class="line">	<span class="keyword">if</span> err := json.NewDecoder(pipe).Decode(&amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := populateProcessEnvironment(config.Env); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> t &#123;</span><br><span class="line">	<span class="keyword">case</span> initSetns:</span><br><span class="line">		<span class="keyword">return</span> &amp;linuxSetnsInit&#123;</span><br><span class="line">			pipe:          pipe,</span><br><span class="line">			consoleSocket: consoleSocket,</span><br><span class="line">			config:        config,</span><br><span class="line">		&#125;, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> initStandard:</span><br><span class="line">		<span class="keyword">return</span> &amp;linuxStandardInit&#123;</span><br><span class="line">			pipe:          pipe,</span><br><span class="line">			consoleSocket: consoleSocket,</span><br><span class="line">			parentPid:     unix.Getppid(),</span><br><span class="line">			config:        config,</span><br><span class="line">			fifoFd:        fifoFd,</span><br><span class="line">		&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unknown init type %q&quot;</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>å½“ä½ è¿è¡Œ <code>runc crate</code> è¿™ä¸ªæ—¶å€™çš„ <code>init</code> æ˜¯è°ƒç”¨å°±æ˜¯ <code>linuxStandardInit</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *linuxStandardInit)</span></span> Init() <span class="type">error</span> &#123;</span><br><span class="line">	runtime.LockOSThread()</span><br><span class="line">	<span class="keyword">defer</span> runtime.UnlockOSThread()</span><br><span class="line">....	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := setupNetwork(l.config); err != <span class="literal">nil</span> &#123; <span class="comment">// æ ¹æ® config ä½¿ç”¨ netlink è¿›è¡Œé…ç½®</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := setupRoute(l.config.Config); err != <span class="literal">nil</span> &#123; <span class="comment">// ä½¿ç”¨ netlink è®¾ç½® route -</span></span><br><span class="line">	<span class="comment">// signal, so we restore it here.</span></span><br><span class="line">	<span class="keyword">if</span> err := pdeath.Restore(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;restore pdeath signal&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Compare the parent from the initial start of the init process and make</span></span><br><span class="line">	<span class="comment">// sure that it did not change.  if the parent changes that means it died</span></span><br><span class="line">	<span class="comment">// and we were reparented to something else so we should just kill ourself</span></span><br><span class="line">	<span class="comment">// and not cause problems for someone else.</span></span><br><span class="line">	<span class="keyword">if</span> unix.Getppid() != l.parentPid &#123;</span><br><span class="line">		<span class="keyword">return</span> unix.Kill(unix.Getpid(), unix.SIGKILL)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Check for the arg before waiting to make sure it exists and it is</span></span><br><span class="line">	<span class="comment">// returned as a create time error.</span></span><br><span class="line">	name, err := exec.LookPath(l.config.Args[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Close the pipe to signal that we have completed our init.</span></span><br><span class="line">	l.pipe.Close()</span><br><span class="line">	<span class="comment">// Wait for the FIFO to be opened on the other side before exec-ing the</span></span><br><span class="line">	<span class="comment">// user process. We open it through /proc/self/fd/$fd, because the fd that</span></span><br><span class="line">	<span class="comment">// was given to us was an O_PATH fd to the fifo itself. Linux allows us to</span></span><br><span class="line">	<span class="comment">// re-open an O_PATH fd through /proc.</span></span><br><span class="line">  <span class="comment">// çœ‹ä¸€ä¸‹æ³¨é‡Šï¼Œè¿™é‡Œåˆ©ç”¨äº† fifo çš„ç‰¹ç‚¹ï¼Œç­‰å¾… runc start æ¥å¼€è¿™ä¸ª fifo</span></span><br><span class="line">	fd, err := unix.Open(fmt.Sprintf(<span class="string">&quot;/proc/self/fd/%d&quot;</span>, l.fifoFd), unix.O_WRONLY|unix.O_CLOEXEC, <span class="number">0</span>) <span class="comment">// ä¸€èµ·å‡†å¤‡å°±ç»ªè¿‡åä»–å°±ä¼š hang åœ¨è¿™é‡Œ</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;open exec fifo&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, err := unix.Write(fd, []<span class="type">byte</span>(<span class="string">&quot;0&quot;</span>)); err != <span class="literal">nil</span> &#123; <span class="comment">// å½“ç”¨æˆ·è°ƒç”¨ runc start æ‰“å¼€ fifoï¼Œå°±ä¼šæ‰§è¡Œåˆ°è¿™é‡Œ</span></span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;write 0 exec fifo&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Close the O_PATH fifofd fd before exec because the kernel resets</span></span><br><span class="line">	<span class="comment">// dumpable in the wrong order. This has been fixed in newer kernels, but</span></span><br><span class="line">	<span class="comment">// we keep this to ensure CVE-2016-9962 doesn&#x27;t re-emerge on older kernels.</span></span><br><span class="line">	<span class="comment">// N.B. the core issue itself (passing dirfds to the host filesystem) has</span></span><br><span class="line">	<span class="comment">// since been resolved.</span></span><br><span class="line">	<span class="comment">// https://github.com/torvalds/linux/blob/v4.9/fs/exec.c#L1290-L1318</span></span><br><span class="line">	unix.Close(l.fifoFd)</span><br><span class="line">	<span class="comment">// Set seccomp as close to execve as possible, so as few syscalls take</span></span><br><span class="line">	<span class="comment">// place afterward (reducing the amount of syscalls that users need to</span></span><br><span class="line">	<span class="comment">// enable in their seccomp profiles).</span></span><br><span class="line">	<span class="keyword">if</span> l.config.Config.Seccomp != <span class="literal">nil</span> &amp;&amp; l.config.NoNewPrivileges &#123;</span><br><span class="line">		<span class="keyword">if</span> err := seccomp.InitSeccomp(l.config.Config.Seccomp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;init seccomp&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := syscall.Exec(name, l.config.Args[<span class="number">0</span>:], os.Environ()); err != <span class="literal">nil</span> &#123; <span class="comment">// è¿™é‡Œ swap ç”¨æˆ·çš„è¿›ç¨‹äº†</span></span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;exec user process&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="runc-start"><a href="#runc-start" class="headerlink" title="runc start"></a>runc start</h2><p>å…¶å® <code>runc start</code> çš„é€»è¾‘æ›´ç®€å•ï¼Œä»…ä»…æ˜¯é€šè¿‡ <code>fifo</code> å’Œ <code>runc init</code>è¿›ç¨‹æ²Ÿé€šï¼Œè®©ä»–ç»§ç»­æ‰§è¡Œç”¨æˆ·è¿›ç¨‹ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> startCommand = cli.Command&#123;</span><br><span class="line">	Name:  <span class="string">&quot;start&quot;</span>,</span><br><span class="line">...</span><br><span class="line">		container, err := getContainer(context)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		status, err := container.Status()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> status &#123;</span><br><span class="line">		<span class="keyword">case</span> libcontainer.Created:</span><br><span class="line">			<span class="keyword">return</span> container.Exec()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> Exec() <span class="type">error</span> &#123;</span><br><span class="line">	c.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.m.Unlock()</span><br><span class="line">	<span class="keyword">return</span> c.exec()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>æ‰“å¼€å­è¿›ç¨‹çš„<code>fifo.exec</code> æ–‡ä»¶ï¼Œå­è¿›ç¨‹å°±èƒ½ç»§ç»­æ‰§è¡Œä¸‹å»äº†ã€‚</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> exec() <span class="type">error</span> &#123;</span><br><span class="line">	path := filepath.Join(c.root, execFifoFilename)</span><br><span class="line">	pid := c.initProcess.pid()</span><br><span class="line">	blockingFifoOpenCh := awaitFifoOpen(path)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> result := &lt;-blockingFifoOpenCh:</span><br><span class="line">			<span class="keyword">return</span> handleFifoResult(result)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">100</span>):</span><br><span class="line">			stat, err := system.Stat(pid)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> || stat.State == system.Zombie &#123;</span><br><span class="line">				<span class="comment">// could be because process started, ran, and completed between our 100ms timeout and our system.Stat() check.</span></span><br><span class="line">				<span class="comment">// see if the fifo exists and has data (with a non-blocking open, which will succeed if the writing process is complete).</span></span><br><span class="line">				<span class="keyword">if</span> err := handleFifoResult(fifoOpen(path, <span class="literal">false</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> errors.New(<span class="string">&quot;container process is already dead&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleFifoResult</span><span class="params">(result openResult)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> result.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result.err</span><br><span class="line">	&#125;</span><br><span class="line">	f := result.file</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="keyword">if</span> err := readFromExecFifo(f); err != <span class="literal">nil</span> &#123; <span class="comment">//</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> os.Remove(f.Name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFromExecFifo</span><span class="params">(execFifo io.Reader)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	data, err := ioutil.ReadAll(execFifo)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(data) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot start an already running container&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>æ‰“å¼€ <code>fifo</code>ï¼Œå¦‚æœ <code>data</code> å°äº 0 è¯´æ˜è¿™ä¸ª  <code>fifo</code> é‡Œé¢ 0 å·²ç»è¢«è¯»å®Œäº†ï¼Œä¹Ÿå°±æ˜¯ running çš„ã€‚</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a target="_blank" rel="noopener" href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/">container-runtime-interface-cri-in-kubernetes&#x2F;</a></p>



<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>License</span></div><div class="body"><p>æœ¬æ–‡é‡‡ç”¨ <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">ç½²å-éå•†ä¸šæ€§ä½¿ç”¨-ç›¸åŒæ–¹å¼å…±äº« 4.0 å›½é™…</a> è®¸å¯åè®®ï¼Œè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">Newer</div><a href="/2021/01/06/kubelet-use-cotnainerd/">kubelet æ˜¯å¦‚ä½•ä½¿ç”¨ containerd</a></div><div class="item" id="next"><div class="note">Older</div><a href="/2020/08/10/aws-nlb-full-nat/">aws nlb ä½¿ç”¨ full nat é‡åˆ°çš„ tcp rest é—®é¢˜</a></div></section></div>






  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      Join the discussion
    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" data-repo="sn0rt/sn0rt.github.io" data-repo-id="R_kgDOJhu0tg" data-category="General" data-category-id="DIC_kwDOJhu0ts4CWai7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">åšå®¢</span><a href="/">è¿‘æœŸ</a><a href="/tags">æ ‡ç­¾</a><a href="/archives">å½’æ¡£</a></div><div class="sitemap-group"><span class="fs14">é¡¹ç›®</span><a href="/wiki">å¼€æºåº“</a></div><div class="sitemap-group"><span class="fs14">ç¤¾äº¤</span><a href="/friends">å‹é“¾</a><a href="/about">ç•™è¨€æ¿</a></div><div class="sitemap-group"><span class="fs14">æ›´å¤š</span><a href="/about">å…³äºæœ¬ç«™</a><a target="_blank" rel="noopener" href="https://github.com/Sn0rt">GitHub</a></div></div><div class="text"><p>æœ¬ç«™ç”± <a href="/">@sn0rt</a> ä½¿ç”¨ <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> ä¸»é¢˜åˆ›å»ºã€‚<br>æœ¬åšå®¢æ‰€æœ‰æ–‡ç« é™¤ç‰¹åˆ«å£°æ˜å¤–ï¼Œå‡é‡‡ç”¨ <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> è®¸å¯åè®®ï¼Œè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // æ‡’åŠ è½½ css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // ä» butterfly å’Œ volantis è·å¾—çµæ„Ÿ
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // é»˜è®¤å¼‚æ­¥ï¼Œå¦‚æœéœ€è¦åŒæ­¥ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¼ å…¥ {} å³å¯
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.19.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0';
  stellar.config = {
    date_suffix: {
      just: 'Just',
      min: 'minutes ago',
      hour: 'hours ago',
      day: 'days ago',
      month: 'months ago',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadJS() {
    const els = document.querySelectorAll("#comments #giscus");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://giscus.app/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    loadJS();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
