<!DOCTYPE html>
<html lang='en'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>kubelet 是如何启动 POD - sn0rt's blog</title>

  
    <meta name="description" content="出于 containerd 上线需求，走读线上组件的代码确定现有 POD 创建流程，主要关注的是组件之间是如何交互沟通的进行 POD 创建的。 kubelet-create-pod      kubelet kubelet 如何创建 POD   dockershim dockerd 接口 &#x2F;containers&#x2F;{name:.*}&#x2F;start   containerd">
<meta property="og:type" content="article">
<meta property="og:title" content="kubelet 是如何启动 POD">
<meta property="og:url" content="http://sn0rt.github.io/2020/12/15/kubelet-create-pod/index.html">
<meta property="og:site_name" content="sn0rt&#39;s blog">
<meta property="og:description" content="出于 containerd 上线需求，走读线上组件的代码确定现有 POD 创建流程，主要关注的是组件之间是如何交互沟通的进行 POD 创建的。 kubelet-create-pod      kubelet kubelet 如何创建 POD   dockershim dockerd 接口 &#x2F;containers&#x2F;{name:.*}&#x2F;start   containerd">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://sn0rt.github.io/media/pic/kubelet-create-pod-with-docker.jpg">
<meta property="article:published_time" content="2020-12-14T16:00:00.000Z">
<meta property="article:modified_time" content="2023-05-14T05:02:02.782Z">
<meta property="article:author" content="Sn0rt">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://sn0rt.github.io/media/pic/kubelet-create-pod-with-docker.jpg">
  
  
  
  <meta name="keywords" content="k8s">

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="/favicon.ico">
  

  

  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/favicon.ico" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">sn0rt's blog</div><div class="sub cap">4Fun</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">Blog</a><a class="nav-item" href="/wiki/">Wiki</a><a class="nav-item" href="/friends/">links</a><a class="nav-item" href="/about/">about</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">No Results!</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">kubelet 是如何启动 POD</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#kubelet-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA-POD"><span class="toc-text">kubelet 如何创建 POD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x2F-containers-x2F-name-x2F-start"><span class="toc-text">&#x2F;containers&#x2F;{name:.*}&#x2F;start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ContainersServer-Create-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">ContainersServer.Create 方法的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TasksServer-Create-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">TasksServer.Create 方法的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TasksServer-Start-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">TasksServer.Start 方法的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#contained-shim-create"><span class="toc-text">contained-shim create</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#contained-shim-start"><span class="toc-text">contained-shim start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#run-create-%E2%80%93bundle"><span class="toc-text">run create –bundle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runc-init"><span class="toc-text">runc init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runc-start"><span class="toc-text">runc start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reference"><span class="toc-text">reference</span></a></li></ol></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      



<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a><span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a></div><div id="post-meta">Posted on&nbsp;<time datetime="2020-12-14T16:00:00.000Z">2020-12-15</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>kubelet 是如何启动 POD</span></h1>
<p>出于 <code>containerd</code> 上线需求，走读线上组件的代码确定现有 <code>POD</code> 创建流程，主要关注的是组件之间是如何交互沟通的进行 <code>POD</code> 创建的。</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/media/pic/kubelet-create-pod-with-docker.jpg" alt="kubelet-create-pod"></div><div class="image-meta"><span class="image-caption center">kubelet-create-pod</span></div></div>

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

<ul>
<li><a href="#kubelet">kubelet</a><ul>
<li><a href="#kubelet-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA-pod">kubelet 如何创建 POD</a></li>
</ul>
</li>
<li><a href="#dockershim">dockershim</a></li>
<li><a href="#dockerd-%E6%8E%A5%E5%8F%A3">dockerd 接口</a><ul>
<li><a href="#containersnamestart">&#x2F;containers&#x2F;{name:.*}&#x2F;start</a></li>
</ul>
</li>
<li><a href="#containerd">containerd</a><ul>
<li><a href="#containersservercreate-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">ContainersServer.Create 方法的实现</a></li>
<li><a href="#tasksservercreate-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">TasksServer.Create 方法的实现</a></li>
<li><a href="#tasksserverstart-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">TasksServer.Start 方法的实现</a></li>
</ul>
</li>
<li><a href="#containerd-shim-%E7%9A%84%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C">containerd-shim 的如何工作</a><ul>
<li><a href="#contained-shim-create">contained-shim create</a></li>
<li><a href="#contained-shim-start">contained-shim start</a></li>
</ul>
</li>
<li><a href="#runc">runc</a><ul>
<li><a href="#run-create---bundle">run create –bundle</a></li>
<li><a href="#runc-init">runc init</a></li>
<li><a href="#runc-start">runc start</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<h1 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h1><p>线上主要有两个版本的 <code>k8s</code>，这次代码走读主要关注 <code>1.17.4</code> 版本。观察 <code>kubelet</code> 初始化流程可以看到与运行时相关参数如下<code>--container-runtime=</code> 参数为 <code>docker</code>。查看启动日志，可以看到 <code>kubelet</code> 启动了一个 <code>dockershim</code> 的服务，这个服务就是目前调研的一个关键点，因为社区在 <code>1.20</code> 版本中准备弃用 <code>dockershim</code> 了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I1215 16:38:23.359299 2052022 docker_service.go:274] Setting cgroupDriver to cgroupfs</span><br><span class="line">I1215 16:38:23.359435 2052022 kubelet.go:642] Starting the GRPC server for the docker CRI shim.</span><br><span class="line">I1215 16:38:23.359456 2052022 docker_server.go:59] Start dockershim grpc server</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>调研社区文档发现，<code>dockershim</code> 之所以被提出是为了解决 <code>kubernetes</code> 开发者面临多个<code>runtime</code>都要接入<code>kubernetes</code>导致调用运行时的相关代码接口不稳定的问题。<br>开发者引入一个抽象层对上屏蔽底层的<code>runtime</code>实现差异，这个抽象层称为<a href="%5Bhttps://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/%5D(https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/)">CRI</a>, 这里的 <code>dockershim</code> 就是基于 <code>docker</code> 二次封装的一个 <code>CRI</code> 实现。<br><code>shim</code> 这个单词的由来可以从 wiki 上查到 <code>an application compatibility workaround</code>。</p>
<h2 id="kubelet-如何创建-POD"><a href="#kubelet-如何创建-POD" class="headerlink" title="kubelet 如何创建 POD"></a>kubelet 如何创建 POD</h2><p>在 <code>POD</code> 创建过程中首先需要准备一个被成为 <code>sandbox</code> 的容器用来初始化设置基础网络等等诸多事宜。走读 <code>CRI</code> 接口发现创建 <code>Sandbox</code> 这个是 <code>CRI</code> 的一个重要功能。</p>
<p>基于 <code>kubelet</code> 的源码分析，通过源码分析了解到 <code>syncLoopIteration</code> -&gt; <code>HandlePodAdditions</code> -&gt; <code>dispatchWork</code>-&gt;<code>UpdatePod</code>-&gt; <code>managePodLoop</code> 这样的一个函数调用关系。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span></span> managePodLoop(podUpdates &lt;-<span class="keyword">chan</span> UpdatePodOptions) &#123;</span><br><span class="line">	<span class="keyword">var</span> lastSyncTime time.Time</span><br><span class="line">...</span><br><span class="line">			err = p.syncPodFn(syncPodOptions&#123; <span class="comment">// 就是这个 syncPodFn 函数的实现</span></span><br><span class="line">				mirrorPod:      update.MirrorPod,</span><br><span class="line">				pod:            update.Pod,</span><br><span class="line">				podStatus:      status,</span><br><span class="line">				killPodOptions: update.KillPodOptions,</span><br><span class="line">				updateType:     update.UpdateType,</span><br><span class="line">			&#125;)</span><br></pre></td></tr></table></figure>

<p>其中的 <code>syncPodFn</code> 具体实现是 <code>klet.syncPod</code> 函数，可以通过代码<code>klet.podWorkers = newPodWorkers(klet.syncPod, kubeDeps.Recorder, klet.workQueue, klet.resyncInterval, backOffPeriod, klet.podCache)</code>看出。基于以上信息可以推论出 <code>podWorkers</code> 才是 <code>pod</code> 创建的核心。走读<code>woker</code>的 <code>SyncPod</code> 这个函数就是就是 <code>podWorkers</code> 核心流程了，<code>worker</code> 通过 <code>sync</code> 函数来调用各个 <code>CRI</code> 接口将这些原子接口组装成一个个实际的 <code>kubernetes</code> 的 <code>POD</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SyncPod syncs the running pod into the desired pod by executing following steps:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  1. Compute sandbox and container changes.</span></span><br><span class="line"><span class="comment">//  2. Kill pod sandbox if necessary.</span></span><br><span class="line"><span class="comment">//  3. Kill any containers that should not be running.</span></span><br><span class="line"><span class="comment">//  4. Create sandbox if necessary.</span></span><br><span class="line"><span class="comment">//  5. Create ephemeral containers.</span></span><br><span class="line"><span class="comment">//  6. Create init containers.</span></span><br><span class="line"><span class="comment">//  7. Create normal containers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span></span> SyncPod(pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) (result kubecontainer.PodSyncResult) &#123;</span><br><span class="line">	<span class="comment">// Step 1: Compute sandbox and container changes.</span></span><br><span class="line">	podContainerChanges := m.computePodActions(pod, podStatus) <span class="comment">// 还是声明式 api 模型，将操作序列化</span></span><br><span class="line">...</span><br><span class="line">	<span class="comment">// Step 2: Kill the pod if the sandbox has changed.</span></span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.KillPod &#123;</span><br><span class="line">...</span><br><span class="line">		killResult := m.killPodWithSyncResult(pod, kubecontainer.ConvertPodStatusToRunningPod(m.runtimeName, podStatus), <span class="literal">nil</span>)</span><br><span class="line">... <span class="comment">// 删除一下无关紧要的代码，不影响主线逻辑</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Step 3: kill any running containers in this pod which are not to keep.</span></span><br><span class="line">		<span class="keyword">for</span> containerID, containerInfo := <span class="keyword">range</span> podContainerChanges.ContainersToKill &#123;</span><br><span class="line">			klog.V(<span class="number">3</span>).Infof(<span class="string">&quot;Killing unwanted container %q(id=%q) for pod %q&quot;</span>, containerInfo.name, containerID, format.Pod(pod))</span><br><span class="line">			killContainerResult := kubecontainer.NewSyncResult(kubecontainer.KillContainer, containerInfo.name)</span><br><span class="line">			result.AddSyncResult(killContainerResult)</span><br><span class="line">			<span class="keyword">if</span> err := m.killContainer(pod, containerID, containerInfo.name, containerInfo.message, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">...<span class="comment">// 一些在运行，但是应该被删除的 container 处理逻辑，</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// Step 4: Create a sandbox for the pod if necessary.</span></span><br><span class="line">	podSandboxID := podContainerChanges.SandboxID</span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">...</span><br><span class="line">    createSandboxResult := kubecontainer.NewSyncResult(kubecontainer.CreatePodSandbox, format.Pod(pod))</span><br><span class="line">		result.AddSyncResult(createSandboxResult)</span><br><span class="line">		podSandboxID, msg, err = m.createPodSandbox(pod, podContainerChanges.Attempt) </span><br><span class="line">    <span class="comment">// 这个函数是我们关注的核心，准备 pod 的沙盒，如何在 sandbox 中调用 CNI 设置网络/存储等</span></span><br><span class="line">... <span class="comment">// 删除一下错误处理，事件的逻辑，网络相关，不影响启动一个不使用网络的 container 😄</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Get podSandboxConfig for containers to start.</span></span><br><span class="line">	configPodSandboxResult := kubecontainer.NewSyncResult(kubecontainer.ConfigPodSandbox, podSandboxID)</span><br><span class="line">	result.AddSyncResult(configPodSandboxResult)</span><br><span class="line">	podSandboxConfig, err := m.generatePodSandboxConfig(pod, podContainerChanges.Attempt)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		message := fmt.Sprintf(<span class="string">&quot;GeneratePodSandboxConfig for pod %q failed: %v&quot;</span>, format.Pod(pod), err)</span><br><span class="line">		klog.Error(message)</span><br><span class="line">		configPodSandboxResult.Fail(kubecontainer.ErrConfigPodSandbox, message)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Helper containing boilerplate common to starting all types of containers.</span></span><br><span class="line">	<span class="comment">// typeName is a label used to describe this type of container in log messages,</span></span><br><span class="line">	<span class="comment">// currently: &quot;container&quot;, &quot;init container&quot; or &quot;ephemeral container&quot;</span></span><br><span class="line">	start := <span class="function"><span class="keyword">func</span><span class="params">(typeName <span class="type">string</span>, container *v1.Container)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		startContainerResult := kubecontainer.NewSyncResult(kubecontainer.StartContainer, container.Name)</span><br><span class="line">		result.AddSyncResult(startContainerResult)</span><br><span class="line"></span><br><span class="line">		isInBackOff, msg, err := m.doBackOff(pod, container, podStatus, backOff)</span><br><span class="line">		<span class="keyword">if</span> isInBackOff &#123;</span><br><span class="line">			startContainerResult.Fail(err, msg)</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Backing Off restarting %v %+v in pod %v&quot;</span>, typeName, container, format.Pod(pod))</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Creating %v %+v in pod %v&quot;</span>, typeName, container, format.Pod(pod))</span><br><span class="line">		<span class="comment">// NOTE (aramase) podIPs are populated for single stack and dual stack clusters. Send only podIPs.</span></span><br><span class="line">		<span class="keyword">if</span> msg, err := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, podIPs); err != <span class="literal">nil</span> &#123; <span class="comment">// 创建 cotnainer 和 启动 container 是两回事，创建说的是准备好相关底层文件资源，启动就是以进程形式在 OS 可见，具体还要看底层运行时是如何实现的。</span></span><br><span class="line">      <span class="comment">// .. 删除了一部分错误处理的逻辑</span></span><br><span class="line">      </span><br><span class="line">	<span class="comment">// Step 5: start ephemeral containers</span></span><br><span class="line">	<span class="comment">//  这部分逻辑非主线</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 6: start the init container.</span></span><br><span class="line">	<span class="keyword">if</span> container := podContainerChanges.NextInitContainerToStart; container != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Start the next init container.</span></span><br><span class="line">		<span class="keyword">if</span> err := start(<span class="string">&quot;init container&quot;</span>, container); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Successfully started the container; clear the entry in the failure</span></span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Completed init container %q for pod %q&quot;</span>, container.Name, format.Pod(pod))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 7: start containers in podContainerChanges.ContainersToStart. </span></span><br><span class="line">	<span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.ContainersToStart &#123; <span class="comment">// 就是业务的 container </span></span><br><span class="line">		start(<span class="string">&quot;container&quot;</span>, &amp;pod.Spec.Containers[idx]) <span class="comment">// start 可以前面看到定义 start := func(typeName string, container *v1.Container) </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的源码其实已经知道为什么要引入 <code>sandbox container</code> 了。分析一下 <code>createPodSandbox</code> 这个函数是如何实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createPodSandbox creates a pod sandbox and returns (podSandBoxID, message, error).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span></span> createPodSandbox(pod *v1.Pod, attempt <span class="type">uint32</span>) (<span class="type">string</span>, <span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	podSandboxConfig, err := m.generatePodSandboxConfig(pod, attempt)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		message := fmt.Sprintf(<span class="string">&quot;GeneratePodSandboxConfig for pod %q failed: %v&quot;</span>, format.Pod(pod), err)</span><br><span class="line">		klog.Error(message)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, message, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create pod logs directory</span></span><br><span class="line">	err = m.osInterface.MkdirAll(podSandboxConfig.LogDirectory, <span class="number">0755</span>) <span class="comment">// 这个目录就是 kubelet 配置读取下来的</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		message := fmt.Sprintf(<span class="string">&quot;Create pod log directory for pod %q failed: %v&quot;</span>, format.Pod(pod), err)</span><br><span class="line">... <span class="comment">// 省略错误处理	</span></span><br><span class="line">... <span class="comment">// 删除了非主线逻辑</span></span><br><span class="line">	podSandBoxID, err := m.runtimeService.RunPodSandbox(podSandboxConfig, runtimeHandler)</span><br><span class="line">... <span class="comment">// 省略错误处理</span></span><br><span class="line">	<span class="keyword">return</span> podSandBoxID, <span class="string">&quot;&quot;</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是看到调用的 <code>func (in instrumentedRuntimeService) RunPodSandboxha</code> 函数基本是透传，存粹是为了记录一下 <code>metric</code> 为监控服务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in instrumentedRuntimeService)</span></span> RunPodSandbox(config *runtimeapi.PodSandboxConfig, runtimeHandler <span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> operation = <span class="string">&quot;run_podsandbox&quot;</span></span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> recordOperation(operation, startTime)</span><br><span class="line">	<span class="keyword">defer</span> metrics.RunPodSandboxDuration.WithLabelValues(runtimeHandler).Observe(metrics.SinceInSeconds(startTime))</span><br><span class="line"></span><br><span class="line">	out, err := in.service.RunPodSandbox(config, runtimeHandler)</span><br><span class="line">	recordError(operation, err)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		metrics.RunPodSandboxErrors.WithLabelValues(runtimeHandler).Inc()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在上面记录完成监控相关过后，下面就是准备调用 <code>grpc</code> 服务了，可以看到调用的是 <code>CRI</code> 的 <code>/runtime.v1alpha2.RuntimeService/RunPodSandbox</code> 接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RunPodSandbox creates and starts a pod-level sandbox. Runtimes should ensure</span></span><br><span class="line"><span class="comment">// the sandbox is in ready state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RemoteRuntimeService)</span></span> RunPodSandbox(config *runtimeapi.PodSandboxConfig, runtimeHandler <span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// Use 2 times longer timeout for sandbox operation (4 mins by default)</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Make the pod sandbox timeout configurable.</span></span><br><span class="line">	ctx, cancel := getContextWithTimeout(r.timeout * <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	resp, err := r.runtimeClient.RunPodSandbox(ctx, &amp;runtimeapi.RunPodSandboxRequest&#123;</span><br><span class="line">		Config:         config,</span><br><span class="line">		RuntimeHandler: runtimeHandler,</span><br><span class="line">	&#125;)</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">return</span> resp.PodSandboxId, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *runtimeServiceClient)</span></span> RunPodSandbox(ctx context.Context, in *RunPodSandboxRequest, opts ...grpc.CallOption) (*RunPodSandboxResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	out := <span class="built_in">new</span>(RunPodSandboxResponse)</span><br><span class="line">	err := c.cc.Invoke(ctx, <span class="string">&quot;/runtime.v1alpha2.RuntimeService/RunPodSandbox&quot;</span>, in, out, opts...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是 <code>kubeGenericRuntimeManager</code> 所处理的 <code>POD</code> 创建流程中的 <code>sandbox</code> 的部分，对其 <code>sandbox</code> 具体是如何被创建的更多细节就要看 <code>grpc</code> 服务端的实现了。</p>
<h1 id="dockershim"><a href="#dockershim" class="headerlink" title="dockershim"></a>dockershim</h1><p>前面梳理出来了 <code>kubeGenericRuntimeManager</code> 是如何通过<code>SyncPod</code>实现<code>POD</code>的创建，但是也发现他的实现完全是面向接口的，完全不关心底层是如何实现 <code>cotnainer</code> 的。我们接着上面 <code>client</code> 的相关逻辑走读一下<code>/runtime.v1alpha2.RuntimeService/RunPodSandbox</code> 的服务端代码逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _RuntimeService_serviceDesc = grpc.ServiceDesc&#123;</span><br><span class="line">	ServiceName: <span class="string">&quot;runtime.v1alpha2.RuntimeService&quot;</span>,</span><br><span class="line">	HandlerType: (*RuntimeServiceServer)(<span class="literal">nil</span>),</span><br><span class="line">	Methods: []grpc.MethodDesc&#123;</span><br><span class="line">...</span><br><span class="line">		&#123;</span><br><span class="line">			MethodName: <span class="string">&quot;RunPodSandbox&quot;</span>,</span><br><span class="line">			Handler:    _RuntimeService_RunPodSandbox_Handler,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面是 <code>handler</code> 注册的过程，其实都是机器生成的代码没有啥好看的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">RuntimeService_RunPodSandbox_Handler</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span>, interceptor grpc.UnaryServerInterceptor) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">	in := <span class="built_in">new</span>(RunPodSandboxRequest)</span><br><span class="line">	<span class="keyword">if</span> err := dec(in); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> interceptor == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> srv.(RuntimeServiceServer).RunPodSandbox(ctx, in)</span><br><span class="line">	&#125;</span><br><span class="line">	info := &amp;grpc.UnaryServerInfo&#123;</span><br><span class="line">		Server:     srv,</span><br><span class="line">		FullMethod: <span class="string">&quot;/runtime.v1alpha2.RuntimeService/RunPodSandbox&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	handler := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> srv.(RuntimeServiceServer).RunPodSandbox(ctx, req.(*RunPodSandboxRequest))</span><br></pre></td></tr></table></figure>

<p>这里就是 <code>dockershim</code> 实现的 <code>CRI</code>，走读上下文代码知道了 <code>ds.client.StartContainer()</code> 中的 <code>client</code> 是 <code>libdocker</code> 中，也就是调用的 <code>dockerClient</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RunPodSandbox creates and starts a pod-level sandbox. Runtimes should ensure</span></span><br><span class="line"><span class="comment">// the sandbox is in ready state.</span></span><br><span class="line"><span class="comment">// For docker, PodSandbox is implemented by a container holding the network</span></span><br><span class="line"><span class="comment">// namespace for the pod.</span></span><br><span class="line"><span class="comment">// Note: docker doesn&#x27;t use LogDirectory (yet).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *dockerService)</span></span> RunPodSandbox(ctx context.Context, r *runtimeapi.RunPodSandboxRequest) (*runtimeapi.RunPodSandboxResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	config := r.GetConfig()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Pull the image for the sandbox.</span></span><br><span class="line">	image := defaultSandboxImage <span class="comment">// 这里就是 Google 的那个 sandbox 的 image</span></span><br><span class="line">	podSandboxImage := ds.podSandboxImage</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(podSandboxImage) != <span class="number">0</span> &#123;</span><br><span class="line">		image = podSandboxImage</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> To use a custom sandbox image in a private repository, users need to configure the nodes with credentials properly.</span></span><br><span class="line">	<span class="comment">// see: http://kubernetes.io/docs/user-guide/images/#configuring-nodes-to-authenticate-to-a-private-repository</span></span><br><span class="line">	<span class="comment">// Only pull sandbox image when it&#x27;s not present - v1.PullIfNotPresent.</span></span><br><span class="line">	<span class="keyword">if</span> err := ensureSandboxImageExists(ds.client, image); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: Create the sandbox container.</span></span><br><span class="line">	<span class="keyword">if</span> r.GetRuntimeHandler() != <span class="string">&quot;&quot;</span> &amp;&amp; r.GetRuntimeHandler() != runtimeName &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;RuntimeHandler %q not supported&quot;</span>, r.GetRuntimeHandler())</span><br><span class="line">	&#125;</span><br><span class="line">	createConfig, err := ds.makeSandboxDockerConfig(config, image)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to make sandbox docker config for pod %q: %v&quot;</span>, config.Metadata.Name, err)</span><br><span class="line">	&#125;</span><br><span class="line">	createResp, err := ds.client.CreateContainer(*createConfig) <span class="comment">// 这里的创建 sandbox 是备好 container 需要底层资源</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		createResp, err = recoverFromCreationConflictIfNeeded(ds.client, *createConfig, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || createResp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to create a sandbox for pod %q: %v&quot;</span>, config.Metadata.Name, err)</span><br><span class="line">	&#125;</span><br><span class="line">	resp := &amp;runtimeapi.RunPodSandboxResponse&#123;PodSandboxId: createResp.ID&#125;</span><br><span class="line"></span><br><span class="line">	ds.setNetworkReady(createResp.ID, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(e *<span class="type">error</span>)</span></span> &#123;</span><br><span class="line">		<span class="comment">// Set networking ready depending on the error return of</span></span><br><span class="line">		<span class="comment">// the parent function</span></span><br><span class="line">		<span class="keyword">if</span> *e == <span class="literal">nil</span> &#123;</span><br><span class="line">			ds.setNetworkReady(createResp.ID, <span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(&amp;err)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: Create Sandbox Checkpoint.</span></span><br><span class="line">	<span class="keyword">if</span> err = ds.checkpointManager.CreateCheckpoint(createResp.ID, constructPodSandboxCheckpoint(config)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err <span class="comment">// 目前来看 checkpoint 功能好像并没有大规模使用？不过这个对我们这次看 pod 创建流程无关经验</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 4: Start the sandbox container.</span></span><br><span class="line">	<span class="comment">// Assume kubelet&#x27;s garbage collector would remove the sandbox later, if</span></span><br><span class="line">	<span class="comment">// startContainer failed.</span></span><br><span class="line">	err = ds.client.StartContainer(createResp.ID) <span class="comment">// 前面准备好 container 这里才去启动，具体怎么启动 kubelet 并不关心</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to start sandbox container for pod %q: %v&quot;</span>, config.Metadata.Name, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除了一下网络和安全相关代码和核心流程无关</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 5: Setup networking for the sandbox.</span></span><br><span class="line">	<span class="comment">// All pod networking is setup by a CNI plugin discovered at startup time.</span></span><br><span class="line">	<span class="comment">// This plugin assigns the pod ip, sets up routes inside the sandbox,</span></span><br><span class="line">	<span class="comment">// creates interfaces etc. In theory, its jurisdiction ends with pod</span></span><br><span class="line">	<span class="comment">// sandbox networking, but it might insert iptables rules or open ports</span></span><br><span class="line">	<span class="comment">// on the host as well, to satisfy parts of the pod spec that aren&#x27;t</span></span><br><span class="line">	<span class="comment">// recognized by the CNI standard yet.</span></span><br><span class="line">	cID := kubecontainer.BuildContainerID(runtimeName, createResp.ID)</span><br><span class="line">	networkOptions := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">if</span> dnsConfig := config.GetDnsConfig(); dnsConfig != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Build DNS options.</span></span><br><span class="line">		dnsOption, err := json.Marshal(dnsConfig)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to marshal dns config for pod %q: %v&quot;</span>, config.Metadata.Name, err)</span><br><span class="line">		&#125;</span><br><span class="line">		networkOptions[<span class="string">&quot;dns&quot;</span>] = <span class="type">string</span>(dnsOption)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// CRI 调用 CNI 来设置 POD 的基础网络</span></span><br><span class="line">	err = ds.network.SetUpPod(config.GetMetadata().Namespace, config.GetMetadata().Name, cID, config.Annotations, networkOptions)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除了一部分设置容器网络错误的处理流程和核心流程无关</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>走读的 <code>dockershim</code> 的 <code>RunPodSandbox</code> 接口发现，它调用了 <code>docker</code> 的接口 <code>ds.client.CreateContainer(*createConfig)</code> 创建了 <code>cotnainer</code>, 又使用了 <code>ds.client.StartContainer(createResp.ID)</code> 启动刚刚创建的 <code>cotnainer</code>。在往下面实现就需要去走读 <code>dockerd</code> 的代码了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *dockerService)</span></span> RunPodSandbox(ctx context.Context, r *runtimeapi.RunPodSandboxRequest) (*runtimeapi.RunPodSandboxResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	config := r.GetConfig()</span><br><span class="line">...</span><br><span class="line">	createConfig, err := ds.makeSandboxDockerConfig(config, image)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to make sandbox docker config for pod %q: %v&quot;</span>, config.Metadata.Name, err)</span><br><span class="line">	&#125;</span><br><span class="line">	createResp, err := ds.client.CreateContainer(*createConfig) <span class="comment">// 这里的创建 sandbox 是备好 container 需要底层资源</span></span><br><span class="line">...</span><br><span class="line">	<span class="comment">// Step 4: Start the sandbox container.</span></span><br><span class="line">	<span class="comment">// Assume kubelet&#x27;s garbage collector would remove the sandbox later, if</span></span><br><span class="line">	<span class="comment">// startContainer failed.</span></span><br><span class="line">	err = ds.client.StartContainer(createResp.ID) <span class="comment">// 前面准备好 container 这里才去启动，具体怎么启动 kubelet 并不关心</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to start sandbox container for pod %q: %v&quot;</span>, config.Metadata.Name, err)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要关注 <code>ds.client.StartContainer()</code>，是因为 <code>ds.client.CreateContainer(*createConfig)</code> 的逻辑比较简单。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp, err := cli.post(ctx, <span class="string">&quot;/containers/&quot;</span>+containerID+<span class="string">&quot;/start&quot;</span>, query, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>通过对代码的分析发现 <code>StartContainer</code> 最后发出的是 <code>http</code> 请求。</p>
<h1 id="dockerd-接口"><a href="#dockerd-接口" class="headerlink" title="dockerd 接口"></a>dockerd 接口</h1><h2 id="x2F-containers-x2F-name-x2F-start"><a href="#x2F-containers-x2F-name-x2F-start" class="headerlink" title="&#x2F;containers&#x2F;{name:.*}&#x2F;start"></a>&#x2F;containers&#x2F;{name:.*}&#x2F;start</h2><p>基于前面的分析我已经知道 <code>kubelet</code> 的 <code>dockershim</code> 其实使用调用的 <code>docker</code> 的 <code>resftul api</code>，根据线上 <code>docker</code> 的版本信息 <code>18.09.9</code> <code>checkout</code>相对应的代码。可以发现 <code>container</code> 流程相关的逻辑在 <code>docker/api/server/router/container/container.go</code> 的 <code>initRoutes()</code> 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/start&quot;</span>, r.postContainersStart),</span><br></pre></td></tr></table></figure>

<p>上面是 handler 主要逻辑很简单，下面就是启动 <code>container</code> 的核心流程了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *containerRouter)</span></span> postContainersStart(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// If contentLength is -1, we can assumed chunked encoding</span></span><br><span class="line">	<span class="comment">// or more technically that the length is unknown</span></span><br><span class="line">	<span class="comment">// https://golang.org/src/pkg/net/http/request.go#L139</span></span><br><span class="line">	<span class="comment">// net/http otherwise seems to swallow any headers related to chunked encoding</span></span><br><span class="line">	<span class="comment">// including r.TransferEncoding</span></span><br><span class="line">	<span class="comment">// allow a nil body for backwards compatibility</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移除 http 检查相关逻辑，哪些不影响核心</span></span><br><span class="line">	<span class="keyword">if</span> err := s.backend.ContainerStart(vars[<span class="string">&quot;name&quot;</span>], hostConfig, checkpoint, checkpointDir); err != <span class="literal">nil</span> &#123; <span class="comment">// here </span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContainerStart starts a container.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span></span> ContainerStart(name <span class="type">string</span>, hostConfig *containertypes.HostConfig, checkpoint <span class="type">string</span>, checkpointDir <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 删除大量的保护式编程非核心逻辑代码</span></span><br><span class="line">	<span class="keyword">return</span> daemon.containerStart(container, checkpoint, checkpointDir, <span class="literal">true</span>) <span class="comment">// here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟如这个<code>Start</code>函数发现居然是使用 <code>grpc </code>去调用<code>/containerd.services.tasks.v1.Tasks/Start</code>的接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// containerStart prepares the container to run by setting up everything the</span></span><br><span class="line"><span class="comment">// container needs, such as storage and networking, as well as links</span></span><br><span class="line"><span class="comment">// between containers. The container is left waiting for a signal to</span></span><br><span class="line"><span class="comment">// begin running.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span></span> containerStart(container *container.Container, checkpoint <span class="type">string</span>, checkpointDir <span class="type">string</span>, resetRestartManager <span class="type">bool</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	container.Lock()</span><br><span class="line">	<span class="keyword">defer</span> container.Unlock()</span><br><span class="line">	<span class="comment">// 删除错误处理与一下防御编程</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := daemon.conditionalMountOnStart(container); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := daemon.initializeNetworking(container); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spec, err := daemon.createSpec(container)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errdefs.System(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一下非核心功能代码</span></span><br><span class="line"></span><br><span class="line">	createOptions, err := daemon.getLibcontainerdCreateOptions(container)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx := context.TODO()</span><br><span class="line"></span><br><span class="line">	err = daemon.containerd.Create(ctx, container.ID, spec, createOptions) <span class="comment">// 这里最终会调用 cotnainerd 的 create</span></span><br><span class="line">	<span class="comment">// 删除错误处理相关代码</span></span><br><span class="line">	<span class="comment">// TODO(mlaventure): we need to specify checkpoint options here</span></span><br><span class="line">	pid, err := daemon.containerd.Start(context.Background(), container.ID, checkpointDir, <span class="comment">// 这里需要跟进一下</span></span><br><span class="line">		container.StreamConfig.Stdin() != <span class="literal">nil</span> || container.Config.Tty,</span><br><span class="line">		container.InitializeStdio)</span><br><span class="line">  <span class="comment">// 忽略错误处理</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>containerStart</code> 函数准备 <code>containerd</code> 运行的一切需要的东西包括存储和网络。但是实际启动可以发现是调用了<code>daemon.containerd.Create</code>与<code>daemon.containerd.Start</code>接口，细节下面进一步分析。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *client)</span></span> Create(ctx context.Context, id <span class="type">string</span>, ociSpec *specs.Spec, runtimeOptions <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ctr := c.getContainer(id); ctr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithStack(newConflictError(<span class="string">&quot;id already in use&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bdir, err := prepareBundleDir(filepath.Join(c.stateDir, id), ociSpec) <span class="comment">// 其实就是准备容器启动目录之类的</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errdefs.System(errors.Wrap(err, <span class="string">&quot;prepare bundle dir failed&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.logger.WithField(<span class="string">&quot;bundle&quot;</span>, bdir).WithField(<span class="string">&quot;root&quot;</span>, ociSpec.Root.Path).Debug(<span class="string">&quot;bundle dir created&quot;</span>)</span><br><span class="line"></span><br><span class="line">	cdCtr, err := c.client.NewContainer(ctx, id, <span class="comment">// 核心代码，更多的逻辑需要下面展开</span></span><br><span class="line">		containerd.WithSpec(ociSpec),</span><br><span class="line">		<span class="comment">// TODO(mlaventure): when containerd support lcow, revisit runtime value</span></span><br><span class="line">		containerd.WithRuntime(fmt.Sprintf(<span class="string">&quot;io.containerd.runtime.v1.%s&quot;</span>, runtime.GOOS), runtimeOptions))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> wrapError(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.Lock()</span><br><span class="line">	c.containers[id] = &amp;container&#123;</span><br><span class="line">		bundleDir: bdir,</span><br><span class="line">		ctr:       cdCtr,</span><br><span class="line">	&#125;</span><br><span class="line">	c.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NewContainer()</code> 就是这一段代码的核心，需要展开说明</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewContainer will create a new container in container with the provided id</span></span><br><span class="line"><span class="comment">// the id must be unique within the namespace</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> NewContainer(ctx context.Context, id <span class="type">string</span>, opts ...NewContainerOpts) (Container, <span class="type">error</span>) &#123;</span><br><span class="line">   ctx, done, err := c.WithLease(ctx)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> done(ctx)</span><br><span class="line"></span><br><span class="line">   container := containers.Container&#123;</span><br><span class="line">      ID: id,</span><br><span class="line">      Runtime: containers.RuntimeInfo&#123;</span><br><span class="line">         Name: c.runtime,</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">      <span class="keyword">if</span> err := o(ctx, c, &amp;container); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   r, err := c.ContainerService().Create(ctx, container) <span class="comment">// 核心就是 create 了</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> containerFromRecord(c, r), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>c.ContainerService().Create(ctx, container)</code>其实调用了 <code>container service</code>，这个个是 <code>docker</code> 层面的抽象，具体实现是 <code>containerd</code>提供的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *remoteContainers)</span></span> Create(ctx context.Context, container containers.Container) (containers.Container, <span class="type">error</span>) &#123;</span><br><span class="line">   created, err := r.client.Create(ctx, &amp;containersapi.CreateContainerRequest&#123;</span><br><span class="line">      Container: containerToProto(&amp;container),</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *containersClient)</span></span> Create(ctx context.Context, in *CreateContainerRequest, opts ...grpc.CallOption) (*CreateContainerResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	out := <span class="built_in">new</span>(CreateContainerResponse)</span><br><span class="line">	err := grpc.Invoke(ctx, <span class="string">&quot;/containerd.services.containers.v1.Containers/Create&quot;</span>, in, out, c.cc, opts...)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>基于上述<code>client.create</code>其实也可以发现，实质性的工作只有一个就是准备启动需要一些目录结构。这一切都是为了准备调用 <code>/containerd.services.containers.v1.Containers/Create</code>接口。</p>
<p><code>docker</code> 调用完成 <code>containerd</code> 的 <code>create</code> 下面就要调用 <code>daemon.containerd.Start()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start create and start a task for the specified containerd id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *client)</span></span> Start(ctx context.Context, id, checkpointDir <span class="type">string</span>, withStdin <span class="type">bool</span>, attachStdio StdioCallback) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	ctr := c.getContainer(id)</span><br><span class="line">	<span class="keyword">if</span> ctr == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, errors.WithStack(newNotFoundError(<span class="string">&quot;no such container&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t := ctr.getTask(); t != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, errors.WithStack(newConflictError(<span class="string">&quot;container already started&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		cp             *types.Descriptor</span><br><span class="line">		t              containerd.Task</span><br><span class="line">		rio            cio.IO</span><br><span class="line">		err            <span class="type">error</span></span><br><span class="line">		stdinCloseSync = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 忽略 checkpoint 相关代码</span></span><br><span class="line"></span><br><span class="line">	spec, err := ctr.ctr.Spec(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, errors.Wrap(err, <span class="string">&quot;failed to retrieve spec&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	uid, gid := getSpecUser(spec)</span><br><span class="line">	t, err = ctr.ctr.NewTask(ctx, <span class="comment">// 这里就是调用 containerd, /containerd.services.tasks.v1.Tasks/Create</span></span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> (cio.IO, <span class="type">error</span>) &#123;</span><br><span class="line">			fifos := newFIFOSet(ctr.bundleDir, InitProcessName, withStdin, spec.Process.Terminal)</span><br><span class="line"></span><br><span class="line">			rio, err = c.createIO(fifos, id, InitProcessName, stdinCloseSync, attachStdio)</span><br><span class="line">			<span class="keyword">return</span> rio, err</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, _ *containerd.Client, info *containerd.TaskInfo)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			info.Checkpoint = cp</span><br><span class="line">			info.Options = &amp;runctypes.CreateOptions&#123;</span><br><span class="line">				IoUid:       <span class="type">uint32</span>(uid),</span><br><span class="line">				IoGid:       <span class="type">uint32</span>(gid),</span><br><span class="line">				NoPivotRoot: os.Getenv(<span class="string">&quot;DOCKER_RAMDISK&quot;</span>) != <span class="string">&quot;&quot;</span>,</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line"><span class="comment">// 移除错误处理相关代码</span></span><br><span class="line">	ctr.setTask(t)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Signal c.createIO that it can call CloseIO</span></span><br><span class="line">	<span class="built_in">close</span>(stdinCloseSync)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := t.Start(ctx); err != <span class="literal">nil</span> &#123; <span class="comment">// 这个 t 是 task 的缩写，/containerd.services.tasks.v1.Tasks/Start</span></span><br><span class="line"><span class="comment">// 移除错误处理相关代码</span></span><br></pre></td></tr></table></figure>

<p>基于上述代码可以看到，这里还是二次封装了。</p>
<p><code>ctr.ctr.NewTask()</code> 就是准备好参数准备调用 <code>containerd</code>的<code>/containerd.services.tasks.v1.Tasks/Create</code>接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *container)</span></span> NewTask(ctx context.Context, ioCreate cio.Creator, opts ...NewTaskOpts) (_ Task, err <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 删除析构函数和错误处理</span></span><br><span class="line">	cfg := i.Config()</span><br><span class="line">	request := &amp;tasks.CreateTaskRequest&#123;</span><br><span class="line">		ContainerID: c.id,</span><br><span class="line">		Terminal:    cfg.Terminal,</span><br><span class="line">		Stdin:       cfg.Stdin,</span><br><span class="line">		Stdout:      cfg.Stdout,</span><br><span class="line">		Stderr:      cfg.Stderr,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 删除部分代码</span></span><br><span class="line">	response, err := c.client.TaskService().Create(ctx, request) <span class="comment">// task service create</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.FromGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	t.pid = response.Pid</span><br><span class="line">	<span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *tasksClient)</span></span> Create(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*CreateTaskResponse, <span class="type">error</span>) &#123;</span><br><span class="line">   out := <span class="built_in">new</span>(CreateTaskResponse)</span><br><span class="line">   err := grpc.Invoke(ctx, <span class="string">&quot;/containerd.services.tasks.v1.Tasks/Create&quot;</span>, in, out, c.cc, opts...)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>t.Start(ctx)</code>函数的实现更简单，最后调用<code>containerd</code>的<code>/containerd.services.tasks.v1.Tasks/Start</code>接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *tasksClient)</span></span> Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	out := <span class="built_in">new</span>(StartResponse)</span><br><span class="line">	err := grpc.Invoke(ctx, <span class="string">&quot;/containerd.services.tasks.v1.Tasks/Start&quot;</span>, in, out, c.cc, opts...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于以上分析，其实 <code>dockerd</code> 的<code>ContainerStart</code>先后会调用到<code>cotnainerd</code>的<code>/containerd.services.containers.v1.Containers/Create</code>，其次<code>/containerd.services.tasks.v1.Tasks/Create</code>，最后是<code>/containerd.services.tasks.v1.Tasks/Start</code>。</p>
<p>那么下面就去走读一下 <code>containerd</code>的相关实现。</p>
<h1 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h1><p>根据线上信息 <code>checkout </code>出<code>containerd</code>版本为<code>7ad184331fa3e55e52b890ea95e65ba581ae3429</code>的代码进行走读。根据上一篇结束的接口信息，直接搜索相关<code>GRPC</code>接口可以找到实现的 <code>handler</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">Containers_Create_Handler</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span>, interceptor </span><br><span class="line">...</span><br><span class="line">	info := &amp;grpc.UnaryServerInfo&#123;</span><br><span class="line">		Server:     srv,</span><br><span class="line">		FullMethod: <span class="string">&quot;/containerd.services.containers.v1.Containers/Create&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	handler := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> srv.(ContainersServer).Create(ctx, req.(*CreateContainerRequest))</span><br><span class="line">...    </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">Tasks_Create_Handler</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span>, interceptor grpc.UnaryServerInterceptor) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">	info := &amp;grpc.UnaryServerInfo&#123;</span><br><span class="line">		Server:     srv,</span><br><span class="line">		FullMethod: <span class="string">&quot;/containerd.services.tasks.v1.Tasks/Create&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	handler := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> srv.(TasksServer).Create(ctx, req.(*CreateTaskRequest))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">Tasks_Start_Handler</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span>, interceptor grpc.UnaryServerInterceptor) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">	info := &amp;grpc.UnaryServerInfo&#123;</span><br><span class="line">		Server:     srv,</span><br><span class="line">		FullMethod: <span class="string">&quot;/containerd.services.tasks.v1.Tasks/Start&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	handler := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> srv.(TasksServer).Start(ctx, req.(*StartRequest))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>那么这一篇分别走读一下三个接口是如何实现的。</p>
<h2 id="ContainersServer-Create-方法的实现"><a href="#ContainersServer-Create-方法的实现" class="headerlink" title="ContainersServer.Create 方法的实现"></a>ContainersServer.Create 方法的实现</h2><p>再来看一下<code>create</code>实现，通过之前 api 配合 IDE 就能直接转跳到下面的代码实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *local)</span></span> Create(ctx context.Context, req *api.CreateContainerRequest, _ ...grpc.CallOption) (*api.CreateContainerResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> resp api.CreateContainerResponse</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := l.withStoreUpdate(ctx, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, store containers.Store)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		container := containerFromProto(&amp;req.Container)</span><br><span class="line"></span><br><span class="line">		created, err := store.Create(ctx, container) <span class="comment">// 将 container 的信息写入本地的一个数据库</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>通过对上面代码走读分析，发现其实 <code>cotnainerd</code> 的 <code>create</code> 操作仅仅就是写一个数据到 <code>bucket </code> 中去，还有一个 <code>event</code>信息 <code>create container</code>。目前还不明白这个 <code>event</code> 除了使用 <code>ctr events</code>看到还有其他的作用么？</p>
<h2 id="TasksServer-Create-方法的实现"><a href="#TasksServer-Create-方法的实现" class="headerlink" title="TasksServer.Create 方法的实现"></a>TasksServer.Create 方法的实现</h2><p><code>containerd</code> 使用 <code>task</code> 来管理 <code>container</code> 的创建和删除，在 <code>containerd</code> 的 <code>readme</code> 文档中也写的比较清楚了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *local)</span></span> Create(ctx context.Context, r *api.CreateTaskRequest, _ ...grpc.CallOption) (*api.CreateTaskResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		checkpointPath <span class="type">string</span></span><br><span class="line">		err            <span class="type">error</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	container, err := l.getContainer(ctx, r.ContainerID) <span class="comment">// 前面写 db，这里读 db 获取 cotnainer 的信息。</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.ToGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	opts := runtime.CreateOpts&#123;</span><br><span class="line">		Spec: container.Spec,</span><br><span class="line">		IO: runtime.IO&#123;</span><br><span class="line">			Stdin:    r.Stdin,</span><br><span class="line">			Stdout:   r.Stdout,</span><br><span class="line">			Stderr:   r.Stderr,</span><br><span class="line">			Terminal: r.Terminal,</span><br><span class="line">		&#125;,</span><br><span class="line">		Checkpoint:     checkpointPath,</span><br><span class="line">		Runtime:        container.Runtime.Name,</span><br><span class="line">		RuntimeOptions: container.Runtime.Options,</span><br><span class="line">		TaskOptions:    r.Options,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> r.Rootfs &#123;</span><br><span class="line">		opts.Rootfs = <span class="built_in">append</span>(opts.Rootfs, mount.Mount&#123;</span><br><span class="line">			Type:    m.Type,</span><br><span class="line">			Source:  m.Source,</span><br><span class="line">			Options: m.Options,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	runtime, err := l.getRuntime(container.Runtime.Name) <span class="comment">// runtime 名字，现在有 v1.linux, v2 两个实现</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	c, err := runtime.Create(ctx, r.ContainerID, opts) <span class="comment">// 目前线上使用 v1（目前是通过 containerd-shim 后面的参数判断出来的，v1/v2 参数差别很明显</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.ToGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> fast path for getting pid on create</span></span><br><span class="line">	<span class="keyword">if</span> err := l.monitor.Monitor(c); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;monitor task&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	state, err := c.State(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.G(ctx).Error(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;api.CreateTaskResponse&#123;</span><br><span class="line">		ContainerID: r.ContainerID,</span><br><span class="line">		Pid:         state.Pid,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用 <code>v1 Linux runtime</code> 的<code>create</code> 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runtime)</span></span> Create(ctx context.Context, id <span class="type">string</span>, opts runtime.CreateOpts) (_ runtime.Task, err <span class="type">error</span>) &#123;</span><br><span class="line">	namespace, err := namespaces.NamespaceRequired(ctx) <span class="comment">// 这里 ns 是 moby，就是 docker 那个新的名字</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := identifiers.Validate(id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;invalid task id&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ropts, err := r.getRuncOptions(ctx, id)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bundle, err := newBundle(id, <span class="comment">// newBundle creates a new bundle on disk at the provided path for the given id</span></span><br><span class="line">		filepath.Join(r.state, namespace),</span><br><span class="line">		filepath.Join(r.root, namespace),</span><br><span class="line">		opts.Spec.Value)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			bundle.Delete()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ShimLocal is a ShimOpt for using an in process shim implementation</span></span><br><span class="line">	shimopt := ShimLocal(r.config, r.events)</span><br><span class="line">	<span class="keyword">if</span> !r.config.NoShim &#123; <span class="comment">// 在正常的逻辑会命中这里，我们使用了 shim</span></span><br><span class="line">		<span class="keyword">var</span> cgroup <span class="type">string</span></span><br><span class="line">		<span class="keyword">if</span> opts.TaskOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">			v, err := typeurl.UnmarshalAny(opts.TaskOptions)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			cgroup = v.(*runctypes.CreateOptions).ShimCgroup</span><br><span class="line">		&#125;</span><br><span class="line">		exitHandler := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			log.G(ctx).WithField(<span class="string">&quot;id&quot;</span>, id).Info(<span class="string">&quot;shim reaped&quot;</span>)</span><br><span class="line">			t, err := r.tasks.Get(ctx, id)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// Task was never started or was already successfully deleted</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			lc := t.(*Task)</span><br><span class="line"></span><br><span class="line">			log.G(ctx).WithFields(logrus.Fields&#123;</span><br><span class="line">				<span class="string">&quot;id&quot;</span>:        id,</span><br><span class="line">				<span class="string">&quot;namespace&quot;</span>: namespace,</span><br><span class="line">			&#125;).Warn(<span class="string">&quot;cleaning up after killed shim&quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> err = r.cleanupAfterDeadShim(context.Background(), bundle, namespace, id, lc.pid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.G(ctx).WithError(err).WithFields(logrus.Fields&#123;</span><br><span class="line">					<span class="string">&quot;id&quot;</span>:        id,</span><br><span class="line">					<span class="string">&quot;namespace&quot;</span>: namespace,</span><br><span class="line">				&#125;).Warn(<span class="string">&quot;failed to clean up after killed shim&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;   </span><br><span class="line">		shimopt = ShimRemote(r.config, r.address, cgroup, exitHandler) </span><br><span class="line">    <span class="comment">// 这里目前只是构建好了 shimopt 这个函数，目前还没有真的调用</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shimopt 这个函数准备好了，这里才开始调用启动 shim 并返回 shim client</span></span><br><span class="line">	s, err := bundle.NewShimClient(ctx, namespace, shimopt, ropts) </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> kerr := s.KillShim(ctx); kerr != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.G(ctx).WithError(err).Error(<span class="string">&quot;failed to kill shim&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	rt := r.config.Runtime</span><br><span class="line">	<span class="keyword">if</span> ropts != <span class="literal">nil</span> &amp;&amp; ropts.Runtime != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		rt = ropts.Runtime</span><br><span class="line">	&#125;</span><br><span class="line">	sopts := &amp;shim.CreateTaskRequest&#123;</span><br><span class="line">		ID:         id,</span><br><span class="line">		Bundle:     bundle.path,</span><br><span class="line">		Runtime:    rt,</span><br><span class="line">		Stdin:      opts.IO.Stdin,</span><br><span class="line">		Stdout:     opts.IO.Stdout,</span><br><span class="line">		Stderr:     opts.IO.Stderr,</span><br><span class="line">		Terminal:   opts.IO.Terminal,</span><br><span class="line">		Checkpoint: opts.Checkpoint,</span><br><span class="line">		Options:    opts.TaskOptions,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> opts.Rootfs &#123;</span><br><span class="line">		sopts.Rootfs = <span class="built_in">append</span>(sopts.Rootfs, &amp;types.Mount&#123;</span><br><span class="line">			Type:    m.Type,</span><br><span class="line">			Source:  m.Source,</span><br><span class="line">			Options: m.Options,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Create a new initial process and container with the underlying OCI runtime </span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">	cr, err := s.Create(ctx, sopts) <span class="comment">// 也就是 shim 的 create 方法，按住不表到讲 containerd-shim 再说。</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.FromGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	t, err := newTask(id, namespace, <span class="type">int</span>(cr.Pid), s, r.events, r.tasks, bundle)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := r.tasks.Add(ctx, t); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ... 移除一部分 event 相关逻辑</span></span><br><span class="line">	<span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>基于以上其实就已经准备好了 <code>task</code> 并启动，在 <code>cotnainerd</code> 中调用使用命令行调用 <code>containerd-shim</code>。其余的逻辑要到 <code>cotnainerd-shim</code> 中去探索了。</p>
<h2 id="TasksServer-Start-方法的实现"><a href="#TasksServer-Start-方法的实现" class="headerlink" title="TasksServer.Start 方法的实现"></a>TasksServer.Start 方法的实现</h2><p><code>create</code> 操作看完了看一下 <code>start</code> 方法是如何实现的，搜索其对应的接口 <code>/containerd.services.tasks.v1.Tasks/Start</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span></span> Start(ctx context.Context, r *api.StartRequest) (*api.StartResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> s.local.Start(ctx, r)</span><br></pre></td></tr></table></figure>

<p>依然是 <code>v1.linux</code> 实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *local)</span></span> Start(ctx context.Context, r *api.StartRequest, _ ...grpc.CallOption) (*api.StartResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	t, err := l.getTask(ctx, r.ContainerID) <span class="comment">// 这里就是从 bucket db 中获取数据</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	p := runtime.Process(t)</span><br><span class="line">	<span class="keyword">if</span> r.ExecID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p, err = t.Process(ctx, r.ExecID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.ToGRPC(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := p.Start(ctx); err != <span class="literal">nil</span> &#123; <span class="comment">// Start the container&#x27;s user defined process</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.ToGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	state, err := p.State(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.ToGRPC(err) <span class="comment">// ToGRPC</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;api.StartResponse&#123;</span><br><span class="line">		Pid: state.Pid,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Task)</span></span> Start(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">	t.mu.Lock()</span><br><span class="line">	hasCgroup := t.cg != <span class="literal">nil</span></span><br><span class="line">	t.mu.Unlock()</span><br><span class="line">	r, err := t.shim.Start(ctx, &amp;shim.StartRequest&#123; <span class="comment">// 调用 shim 的 start</span></span><br><span class="line">		ID: t.id,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>基于以上两个接口其实发现更多工作 <code>containerd</code> 放到了 <code>conteinrd-shim</code> 中完成了。</p>
<h1 id="containerd-shim-的如何工作"><a href="#containerd-shim-的如何工作" class="headerlink" title="containerd-shim 的如何工作"></a>containerd-shim 的如何工作</h1><p>初看 <code>containerd-shim</code> 的实现模型也不是很复杂，主函数中调用一个 <code>rpc</code> 服务常驻后台，对外提供服务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := executeShim(); err != <span class="literal">nil</span> &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">executeShim</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">....</span><br><span class="line">	&#125;</span><br><span class="line">	server, err := newServer()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed creating server&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	sv, err := shim.NewService(</span><br><span class="line">		shim.Config&#123;</span><br><span class="line">			Path:          path,</span><br><span class="line">			Namespace:     namespaceFlag,</span><br><span class="line">			WorkDir:       workdirFlag,</span><br><span class="line">			Criu:          criuFlag,</span><br><span class="line">			SystemdCgroup: systemdCgroupFlag,</span><br><span class="line">			RuntimeRoot:   runtimeRootFlag,</span><br><span class="line">		&#125;,</span><br><span class="line">		&amp;remoteEventsPublisher&#123;address: addressFlag&#125;,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	logrus.Debug(<span class="string">&quot;registering ttrpc server&quot;</span>)</span><br><span class="line">	shimapi.RegisterShimService(server, sv) <span class="comment">// ttrpc </span></span><br><span class="line"></span><br><span class="line">	socket := socketFlag</span><br><span class="line">	<span class="keyword">if</span> err := serve(context.Background(), server, socket); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>唯一值得一提的就是<code>ttrpc</code>是低内存下面的 rpc 协议，基于 grpc 的低内存版本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterShimService</span><span class="params">(srv *ttrpc.Server, svc ShimService)</span></span> &#123;</span><br><span class="line">	srv.Register(<span class="string">&quot;containerd.runtime.linux.shim.v1.Shim&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]ttrpc.Method&#123;</span><br><span class="line">...</span><br><span class="line">		<span class="string">&quot;Create&quot;</span>: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, unmarshal <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">			<span class="keyword">var</span> req CreateTaskRequest</span><br><span class="line">			<span class="keyword">if</span> err := unmarshal(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> svc.Create(ctx, &amp;req)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">&quot;Start&quot;</span>: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, unmarshal <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">			<span class="keyword">var</span> req StartRequest</span><br><span class="line">			<span class="keyword">if</span> err := unmarshal(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> svc.Start(ctx, &amp;req)</span><br><span class="line">		&#125;,</span><br></pre></td></tr></table></figure>

<p>这次只关心 <code>shim</code> 的 <code>Create</code> 与 <code>Start</code> 实现。</p>
<h2 id="contained-shim-create"><a href="#contained-shim-create" class="headerlink" title="contained-shim create"></a>contained-shim create</h2><p>这个就是<code>containerd</code>的<code>s.Create(ctx, sopts)</code>实现的地方</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *local)</span></span> Create(ctx context.Context, in *shimapi.CreateTaskRequest) (*shimapi.CreateTaskResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> c.s.Create(ctx, in)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>create</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new initial process and container with the underlying OCI runtime</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> Create(ctx context.Context, r *shimapi.CreateTaskRequest) (_ *shimapi.CreateTaskResponse, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> mounts []proc.Mount</span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> r.Rootfs &#123;</span><br><span class="line">		mounts = <span class="built_in">append</span>(mounts, proc.Mount&#123;</span><br><span class="line">			Type:    m.Type,</span><br><span class="line">			Source:  m.Source,</span><br><span class="line">			Target:  m.Target,</span><br><span class="line">			Options: m.Options,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	config := &amp;proc.CreateConfig&#123;</span><br><span class="line">		ID:               r.ID,</span><br><span class="line">		Bundle:           r.Bundle,</span><br><span class="line">		Runtime:          r.Runtime,</span><br><span class="line">		Rootfs:           mounts,</span><br><span class="line">		Terminal:         r.Terminal,</span><br><span class="line">		Stdin:            r.Stdin,</span><br><span class="line">		Stdout:           r.Stdout,</span><br><span class="line">		Stderr:           r.Stderr,</span><br><span class="line">		Checkpoint:       r.Checkpoint,</span><br><span class="line">		ParentCheckpoint: r.ParentCheckpoint,</span><br><span class="line">		Options:          r.Options,</span><br><span class="line">	&#125;</span><br><span class="line">	rootfs := filepath.Join(r.Bundle, <span class="string">&quot;rootfs&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(rootfs <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err2 := mount.UnmountAll(rootfs, <span class="number">0</span>); err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.G(ctx).WithError(err2).Warn(<span class="string">&quot;Failed to cleanup rootfs mount&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(rootfs)</span><br><span class="line">	<span class="keyword">for</span> _, rm := <span class="keyword">range</span> mounts &#123;</span><br><span class="line">		m := &amp;mount.Mount&#123;</span><br><span class="line">			Type:    rm.Type,</span><br><span class="line">			Source:  rm.Source,</span><br><span class="line">			Options: rm.Options,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := m.Mount(rootfs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;failed to mount rootfs component %v&quot;</span>, m)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(mounts) == <span class="number">0</span> &#123;</span><br><span class="line">		rootfs = <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	process, err := newInit(</span><br><span class="line">		ctx,</span><br><span class="line">		s.config.Path,</span><br><span class="line">		s.config.WorkDir,</span><br><span class="line">		s.config.RuntimeRoot,</span><br><span class="line">		s.config.Namespace,</span><br><span class="line">		s.config.Criu,</span><br><span class="line">		s.config.SystemdCgroup,</span><br><span class="line">		s.platform,</span><br><span class="line">		config,</span><br><span class="line">		rootfs,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.ToGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := process.Create(ctx, config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errdefs.ToGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// save the main task id and bundle to the shim for additional requests</span></span><br><span class="line">	s.id = r.ID</span><br><span class="line">	s.bundle = r.Bundle</span><br><span class="line">	pid := process.Pid()</span><br><span class="line">	s.processes[r.ID] = process</span><br><span class="line">	<span class="keyword">return</span> &amp;shimapi.CreateTaskResponse&#123;</span><br><span class="line">		Pid: <span class="type">uint32</span>(pid),</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the process with the provided config</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Init)</span></span> Create(ctx context.Context, r *CreateConfig) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		err    <span class="type">error</span></span><br><span class="line">		socket *runc.Socket</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> r.Terminal &#123;</span><br><span class="line">		<span class="keyword">if</span> socket, err = runc.NewTempConsoleSocket(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to create OCI runtime console socket&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> socket.Close()</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> hasNoIO(r) &#123;</span><br><span class="line">		<span class="keyword">if</span> p.io, err = runc.NewNullIO(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;creating new NULL IO&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p.io, err = runc.NewPipeIO(p.IoUID, p.IoGID, withConditionalIO(p.stdio)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to create OCI runtime io pipes&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pidFile := filepath.Join(p.Bundle, InitPidFile)</span><br><span class="line">	<span class="keyword">if</span> r.Checkpoint != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		opts := &amp;runc.RestoreOpts&#123;</span><br><span class="line">			CheckpointOpts: runc.CheckpointOpts&#123;</span><br><span class="line">				ImagePath:  r.Checkpoint,</span><br><span class="line">				WorkDir:    p.WorkDir,</span><br><span class="line">				ParentPath: r.ParentCheckpoint,</span><br><span class="line">			&#125;,</span><br><span class="line">			PidFile:     pidFile,</span><br><span class="line">			IO:          p.io,</span><br><span class="line">			NoPivot:     p.NoPivotRoot,</span><br><span class="line">			Detach:      <span class="literal">true</span>,</span><br><span class="line">			NoSubreaper: <span class="literal">true</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		p.initState = &amp;createdCheckpointState&#123;</span><br><span class="line">			p:    p,</span><br><span class="line">			opts: opts,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	opts := &amp;runc.CreateOpts&#123;</span><br><span class="line">		PidFile:      pidFile,</span><br><span class="line">		IO:           p.io,</span><br><span class="line">		NoPivot:      p.NoPivotRoot,</span><br><span class="line">		NoNewKeyring: p.NoNewKeyring,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> socket != <span class="literal">nil</span> &#123;</span><br><span class="line">		opts.ConsoleSocket = socket</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := p.runtime.Create(ctx, r.ID, r.Bundle, opts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p.runtimeError(err, <span class="string">&quot;OCI runtime create failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r.Stdin != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		sc, err := fifo.OpenFifo(context.Background(), r.Stdin, syscall.O_WRONLY|syscall.O_NONBLOCK, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to open stdin fifo %s&quot;</span>, r.Stdin)</span><br><span class="line">		&#125;</span><br><span class="line">		p.stdin = sc</span><br><span class="line">		p.closers = <span class="built_in">append</span>(p.closers, sc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> copyWaitGroup sync.WaitGroup</span><br><span class="line">	ctx, cancel := context.WithTimeout(ctx, <span class="number">30</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="keyword">if</span> socket != <span class="literal">nil</span> &#123;</span><br><span class="line">		console, err := socket.ReceiveMaster()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to retrieve console master&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		console, err = p.Platform.CopyConsole(ctx, console, r.Stdin, r.Stdout, r.Stderr, &amp;p.wg, &amp;copyWaitGroup)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to start console copy&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		p.console = console</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> !hasNoIO(r) &#123;</span><br><span class="line">		<span class="keyword">if</span> err := copyPipes(ctx, p.io, r.Stdin, r.Stdout, r.Stderr, &amp;p.wg, &amp;copyWaitGroup); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to start io pipe copy&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	copyWaitGroup.Wait()</span><br><span class="line">	pid, err := runc.ReadPidFile(pidFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to retrieve OCI runtime container pid&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	p.pid = pid</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create creates a new container and returns its pid if it was created successfully</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runc)</span></span> Create(context context.Context, id, bundle <span class="type">string</span>, opts *CreateOpts) <span class="type">error</span> &#123;</span><br><span class="line">	args := []<span class="type">string</span>&#123;<span class="string">&quot;create&quot;</span>, <span class="string">&quot;--bundle&quot;</span>, bundle&#125; <span class="comment">// 这里就是 runc create --bundle 的命令行了</span></span><br><span class="line">	<span class="keyword">if</span> opts != <span class="literal">nil</span> &#123;</span><br><span class="line">		oargs, err := opts.args()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		args = <span class="built_in">append</span>(args, oargs...)</span><br><span class="line">	&#125;</span><br><span class="line">	cmd := r.command(context, <span class="built_in">append</span>(args, id)...)</span><br><span class="line">	<span class="keyword">if</span> opts != <span class="literal">nil</span> &amp;&amp; opts.IO != <span class="literal">nil</span> &#123;</span><br><span class="line">		opts.Set(cmd)</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.ExtraFiles = opts.ExtraFiles</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cmd.Stdout == <span class="literal">nil</span> &amp;&amp; cmd.Stderr == <span class="literal">nil</span> &#123;</span><br><span class="line">		data, err := cmdOutput(cmd, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s: %s&quot;</span>, err, data)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="contained-shim-start"><a href="#contained-shim-start" class="headerlink" title="contained-shim start"></a>contained-shim start</h2><p>基于 containerd 的分析其实还看到调用 <code>t.shim.Start(ctx, &amp;shim.StartRequest&#123;ID: t.id&#125;)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *local)</span></span> Start(ctx context.Context, in *shimapi.StartRequest) (*shimapi.StartResponse, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> c.s.Start(ctx, in)  </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start a process</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> Start(ctx context.Context, r *shimapi.StartRequest) (*shimapi.StartResponse, <span class="type">error</span>) &#123;</span><br><span class="line">   p, err := s.getExecProcess(r.ID) <span class="comment">// get exec process </span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := p.Start(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;shimapi.StartResponse&#123;</span><br><span class="line">      ID:  p.ID(),</span><br><span class="line">      Pid: <span class="type">uint32</span>(p.Pid()),</span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *execProcess)</span></span> Start(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">   e.mu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> e.mu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> e.execState.Start(ctx) <span class="comment">// execState 这会应该是 created，因为前面已经 runc create --bundle 了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *createdState)</span></span> Start(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := s.p.start(ctx); err != <span class="literal">nil</span> &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Init)</span></span> start(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">	err := p.runtime.Start(ctx, p.id)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start will start an already created container</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runc)</span></span> Start(context context.Context, id <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> r.runOrError(r.command(context, <span class="string">&quot;start&quot;</span>, id)) <span class="comment">// 这里会运行，r.command 返回的 exec.Cmd object </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runc)</span></span> command(context context.Context, args ...<span class="type">string</span>) *exec.Cmd &#123;</span><br><span class="line">   command := r.Command</span><br><span class="line">   <span class="keyword">if</span> command == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      command = DefaultCommand <span class="comment">// DefaultCommand = &quot;runc&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   cmd := exec.CommandContext(context, command, <span class="built_in">append</span>(r.args(), args...)...)</span><br><span class="line">   cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">      Setpgid: r.Setpgid,</span><br><span class="line">   &#125;</span><br><span class="line">   cmd.Env = filterEnv(os.Environ(), <span class="string">&quot;NOTIFY_SOCKET&quot;</span>) <span class="comment">// NOTIFY_SOCKET introduces a special behavior in runc but should only be set if invoked from systemd</span></span><br><span class="line">   <span class="keyword">if</span> r.PdeathSignal != <span class="number">0</span> &#123;</span><br><span class="line">      cmd.SysProcAttr.Pdeathsig = r.PdeathSignal</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>那么其实到这里也就看完了 <code>containrd-shim</code> 调用 <code>runc create </code>&#x2F; <code>runc start </code></p>
<h1 id="runc"><a href="#runc" class="headerlink" title="runc"></a>runc</h1><p>前面看过了 <code>containerd-shim</code> 调用了 <code>runc create</code> 与 <code>runc start</code>，这里梳理一下 <code>runc</code> 的相关代码逻辑。</p>
<h2 id="run-create-–bundle"><a href="#run-create-–bundle" class="headerlink" title="run create –bundle"></a>run create –bundle</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startContainer</span><span class="params">(context *cli.Context, spec *specs.Spec, action CtAct, criuOpts *libcontainer.CriuOpts)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	id := context.Args().First()</span><br><span class="line">	<span class="keyword">if</span> id == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, errEmptyID</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	notifySocket := newNotifySocket(context, os.Getenv(<span class="string">&quot;NOTIFY_SOCKET&quot;</span>), id)</span><br><span class="line">	<span class="keyword">if</span> notifySocket != <span class="literal">nil</span> &#123;</span><br><span class="line">		notifySocket.setupSpec(context, spec)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	container, err := createContainer(context, id, spec) <span class="comment">// 准备 container 在 runc 内存中的 object</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> notifySocket != <span class="literal">nil</span> &#123;</span><br><span class="line">		err := notifySocket.setupSocket()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Support on-demand socket activation by passing file descriptors into the container init process.</span></span><br><span class="line">	listenFDs := []*os.File&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> os.Getenv(<span class="string">&quot;LISTEN_FDS&quot;</span>) != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		listenFDs = activation.Files(<span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logLevel := <span class="string">&quot;info&quot;</span></span><br><span class="line">	<span class="keyword">if</span> context.GlobalBool(<span class="string">&quot;debug&quot;</span>) &#123;</span><br><span class="line">		logLevel = <span class="string">&quot;debug&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r := &amp;runner&#123;</span><br><span class="line">		enableSubreaper: !context.Bool(<span class="string">&quot;no-subreaper&quot;</span>),</span><br><span class="line">		shouldDestroy:   <span class="literal">true</span>,</span><br><span class="line">		container:       container,</span><br><span class="line">		listenFDs:       listenFDs,</span><br><span class="line">		notifySocket:    notifySocket,</span><br><span class="line">		consoleSocket:   context.String(<span class="string">&quot;console-socket&quot;</span>),</span><br><span class="line">		detach:          context.Bool(<span class="string">&quot;detach&quot;</span>),</span><br><span class="line">		pidFile:         context.String(<span class="string">&quot;pid-file&quot;</span>),</span><br><span class="line">		preserveFDs:     context.Int(<span class="string">&quot;preserve-fds&quot;</span>),</span><br><span class="line">		action:          action,</span><br><span class="line">		criuOpts:        criuOpts,</span><br><span class="line">		init:            <span class="literal">true</span>,</span><br><span class="line">		logLevel:        logLevel,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r.run(spec.Process) <span class="comment">// run</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>createContainer</code>创建 <code>cotnainer</code> 对象，实际的创建由平台相关的工厂函数实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createContainer</span><span class="params">(context *cli.Context, id <span class="type">string</span>, spec *specs.Spec)</span></span> (libcontainer.Container, <span class="type">error</span>) &#123;</span><br><span class="line">	rootlessCg, err := shouldUseRootlessCgroupManager(context)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	config, err := specconv.CreateLibcontainerConfig(&amp;specconv.CreateOpts&#123;</span><br><span class="line">		CgroupName:       id,</span><br><span class="line">		UseSystemdCgroup: context.GlobalBool(<span class="string">&quot;systemd-cgroup&quot;</span>),</span><br><span class="line">		NoPivotRoot:      context.Bool(<span class="string">&quot;no-pivot&quot;</span>),</span><br><span class="line">		NoNewKeyring:     context.Bool(<span class="string">&quot;no-new-keyring&quot;</span>),</span><br><span class="line">		Spec:             spec,</span><br><span class="line">		RootlessEUID:     os.Geteuid() != <span class="number">0</span>,</span><br><span class="line">		RootlessCgroups:  rootlessCg,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	factory, err := loadFactory(context) <span class="comment">// 返回 Linux 的实现 InitPath 字段为 /proc/self/exe，InitArgs 字段为 []string&#123;os.Args[0], &quot;init&quot;&#125;,</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> factory.Create(id, config)</span><br></pre></td></tr></table></figure>

<p><code>factory.Create</code> 创建返回一个 <code>container</code>结构体，其中 container 结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c := &amp;linuxContainer&#123;</span><br><span class="line">	id:            id,</span><br><span class="line">	root:          containerRoot, <span class="comment">//这里是 cotnainer 的 root 目录</span></span><br><span class="line">	config:        config, </span><br><span class="line">	initPath:      l.InitPath, <span class="comment">// init path /proc/self/exe</span></span><br><span class="line">	initArgs:      l.InitArgs, <span class="comment">// []string&#123;os.Args[0].&#125;</span></span><br><span class="line">	criuPath:      l.CriuPath,</span><br><span class="line">	newuidmapPath: l.NewuidmapPath,</span><br><span class="line">	newgidmapPath: l.NewgidmapPath,</span><br><span class="line">	cgroupManager: l.NewCgroupsManager(config.Cgroups, <span class="literal">nil</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回上述结构体，继续回到到上层代码继续执行到<code>r.run(spec.Process)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *runner)</span></span> run(config *specs.Process) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">	process, err := newProcess(*config, r.init, r.logLevel)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> r.action &#123;</span><br><span class="line">	<span class="keyword">case</span> CT_ACT_CREATE:</span><br><span class="line">		err = r.container.Start(process) <span class="comment">// 这次行为会到这个流程</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>回到<code> r.container.Start(process)</code> 继续执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> Start(process *Process) <span class="type">error</span> &#123;</span><br><span class="line">	c.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> process.Init &#123; <span class="comment">// 使用 create 这里就是 true</span></span><br><span class="line">		<span class="keyword">if</span> err := c.createExecFifo(); err != <span class="literal">nil</span> &#123; <span class="comment">// create 一个 exec.fifo 用与进程间通信，只有写时会被阻塞，读写都在时才会正常运行</span></span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := c.start(process); err != <span class="literal">nil</span> &#123; <span class="comment">// 这才是本次关注点</span></span><br><span class="line">		<span class="keyword">if</span> process.Init &#123;</span><br><span class="line">			c.deleteExecFifo()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>c.start(process)</code>的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> start(process *Process) <span class="type">error</span> &#123;</span><br><span class="line">	parent, err := c.newParentProcess(process) <span class="comment">// 创建父进程，代码在下面 review</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;creating new parent process&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	parent.forwardChildLogs()</span><br><span class="line">	<span class="keyword">if</span> err := parent.start(); err != <span class="literal">nil</span> &#123; <span class="comment">// 这里创建父进程的 start，其实也就是 runc init</span></span><br><span class="line">		<span class="comment">// terminate the process to ensure that it properly is reaped.</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>newParentProcess()</code>其实就是命令行为<code> runc init</code> 的 <code>parentProcess</code>，返回给上面调用<code>parent.start()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> newParentProcess(p *Process) (parentProcess, <span class="type">error</span>) &#123;</span><br><span class="line">	parentInitPipe, childInitPipe, err := utils.NewSockPair(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, newSystemErrorWithCause(err, <span class="string">&quot;creating new init pipe&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	messageSockPair := filePair&#123;parentInitPipe, childInitPipe&#125;</span><br><span class="line"></span><br><span class="line">	parentLogPipe, childLogPipe, err := os.Pipe()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Unable to create the log pipe:  %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	logFilePair := filePair&#123;parentLogPipe, childLogPipe&#125;</span><br><span class="line"></span><br><span class="line">	cmd, err := c.commandTemplate(p, childInitPipe, childLogPipe) <span class="comment">// 准备命令行 </span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, newSystemErrorWithCause(err, <span class="string">&quot;creating new command template&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !p.Init &#123;</span><br><span class="line">		<span class="keyword">return</span> c.newSetnsProcess(p, cmd, messageSockPair, logFilePair) <span class="comment">// 如果不是 init，所以这一次不关心这里</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We only set up fifoFd if we&#x27;re not doing a `runc exec`. The historic</span></span><br><span class="line">	<span class="comment">// reason for this is that previously we would pass a dirfd that allowed</span></span><br><span class="line">	<span class="comment">// for container rootfs escape (and not doing it in `runc exec` avoided</span></span><br><span class="line">	<span class="comment">// that problem), but we no longer do that. However, there&#x27;s no need to do</span></span><br><span class="line">	<span class="comment">// this for `runc exec` so we just keep it this way to be safe.</span></span><br><span class="line">	<span class="keyword">if</span> err := c.includeExecFifo(cmd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, newSystemErrorWithCause(err, <span class="string">&quot;including execfifo in cmd.Exec setup&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.newInitProcess(p, cmd, messageSockPair, logFilePair) <span class="comment">// 返回 initProcess，其中 cmd 为 runc init，并 c.initProcess = init</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>parent.start()</code>  就是实际开始运行 <code>runc init</code>了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *initProcess)</span></span> start() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> p.messageSockPair.parent.Close()</span><br><span class="line">	err := p.cmd.Start() <span class="comment">// 启动 runc init</span></span><br><span class="line">	p.process.ops = p</span><br><span class="line">	<span class="comment">// close the write-side of the pipes (controlled by child)</span></span><br><span class="line">	p.messageSockPair.child.Close()</span><br><span class="line">	p.logFilePair.child.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		p.process.ops = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;starting init process command&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Do this before syncing with child so that no children can escape the</span></span><br><span class="line">	<span class="comment">// cgroup. We don&#x27;t need to worry about not doing this and not being root</span></span><br><span class="line">	<span class="comment">// because we&#x27;d be using the rootless cgroup manager in that case.</span></span><br><span class="line">	<span class="keyword">if</span> err := p.manager.Apply(p.pid()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;applying cgroup configuration for process&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.intelRdtManager != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := p.intelRdtManager.Apply(p.pid()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;applying Intel RDT configuration for process&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> should not be the responsibility to call here</span></span><br><span class="line">			p.manager.Destroy()</span><br><span class="line">			<span class="keyword">if</span> p.intelRdtManager != <span class="literal">nil</span> &#123;</span><br><span class="line">				p.intelRdtManager.Destroy()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err := io.Copy(p.messageSockPair.parent, p.bootstrapData); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;copying bootstrap data to pipe&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	childPid, err := p.getChildPid() <span class="comment">// 获取 child 的 pid</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;getting the final child&#x27;s pid from pipe&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save the standard descriptor names before the container process</span></span><br><span class="line">	<span class="comment">// can potentially move them (e.g., via dup2()).  If we don&#x27;t do this now,</span></span><br><span class="line">	<span class="comment">// we won&#x27;t know at checkpoint time which file descriptor to look up.</span></span><br><span class="line">	fds, err := getPipeFds(childPid)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCausef(err, <span class="string">&quot;getting pipe fds for pid %d&quot;</span>, childPid)</span><br><span class="line">	&#125;</span><br><span class="line">	p.setExternalDescriptors(fds)</span><br><span class="line">	<span class="comment">// Do this before syncing with child so that no children</span></span><br><span class="line">	<span class="comment">// can escape the cgroup</span></span><br><span class="line">	<span class="keyword">if</span> err := p.manager.Apply(childPid); err != <span class="literal">nil</span> &#123; <span class="comment">// 这里设置调用具体的实现配置 cgroup</span></span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;applying cgroup configuration for process&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.intelRdtManager != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := p.intelRdtManager.Apply(childPid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;applying Intel RDT configuration for process&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Now it&#x27;s time to setup cgroup namesapce</span></span><br><span class="line">	<span class="keyword">if</span> p.config.Config.Namespaces.Contains(configs.NEWCGROUP) &amp;&amp; p.config.Config.Namespaces.PathOf(configs.NEWCGROUP) == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _, err := p.messageSockPair.parent.Write([]<span class="type">byte</span>&#123;createCgroupns&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;sending synchronization value to init process&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for our first child to exit</span></span><br><span class="line">	<span class="keyword">if</span> err := p.waitForChildExit(childPid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;waiting for our first child to exit&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> should not be the responsibility to call here</span></span><br><span class="line">			p.manager.Destroy()</span><br><span class="line">			<span class="keyword">if</span> p.intelRdtManager != <span class="literal">nil</span> &#123;</span><br><span class="line">				p.intelRdtManager.Destroy()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">if</span> err := p.createNetworkInterfaces(); err != <span class="literal">nil</span> &#123; <span class="comment">// 创建网络接口</span></span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;creating network interfaces&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := p.sendConfig(); err != <span class="literal">nil</span> &#123; <span class="comment">// 把配置发送给子进程</span></span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;sending config to init process&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		sentRun    <span class="type">bool</span></span><br><span class="line">		sentResume <span class="type">bool</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	ierr := parseSync(p.messageSockPair.parent, <span class="function"><span class="keyword">func</span><span class="params">(sync *syncT)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> sync.Type &#123;</span><br><span class="line">		<span class="keyword">case</span> procReady:</span><br><span class="line">			<span class="comment">// set rlimits, this has to be done here because we lose permissions</span></span><br><span class="line">			<span class="comment">// to raise the limits once we enter a user-namespace</span></span><br><span class="line">			<span class="keyword">if</span> err := setupRlimits(p.config.Rlimits, p.pid()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;setting rlimits for ready process&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// call prestart hooks</span></span><br><span class="line">			<span class="keyword">if</span> !p.config.Config.Namespaces.Contains(configs.NEWNS) &#123;</span><br><span class="line">				<span class="comment">// Setup cgroup before prestart hook, so that the prestart hook could apply cgroup permissions.</span></span><br><span class="line">				<span class="keyword">if</span> err := p.manager.Set(p.config.Config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;setting cgroup config for ready process&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> p.intelRdtManager != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> err := p.intelRdtManager.Set(p.config.Config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;setting Intel RDT config for ready process&quot;</span>)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> p.config.Config.Hooks != <span class="literal">nil</span> &#123;</span><br><span class="line">					s, err := p.container.currentOCIState()</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// initProcessStartTime hasn&#x27;t been set yet.</span></span><br><span class="line">					s.Pid = p.cmd.Process.Pid</span><br><span class="line">					s.Status = <span class="string">&quot;creating&quot;</span></span><br><span class="line">					<span class="keyword">for</span> i, hook := <span class="keyword">range</span> p.config.Config.Hooks.Prestart &#123;</span><br><span class="line">						<span class="keyword">if</span> err := hook.Run(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> newSystemErrorWithCausef(err, <span class="string">&quot;running prestart hook %d&quot;</span>, i)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Sync with child.</span></span><br><span class="line">			<span class="keyword">if</span> err := writeSync(p.messageSockPair.parent, procRun); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;writing syncT &#x27;run&#x27;&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			sentRun = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> procHooks:</span><br><span class="line">			<span class="comment">// Setup cgroup before prestart hook, so that the prestart hook could apply cgroup permissions.</span></span><br><span class="line">			<span class="keyword">if</span> err := p.manager.Set(p.config.Config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;setting cgroup config for procHooks process&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> p.intelRdtManager != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err := p.intelRdtManager.Set(p.config.Config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;setting Intel RDT config for procHooks process&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> p.config.Config.Hooks != <span class="literal">nil</span> &#123;</span><br><span class="line">				s, err := p.container.currentOCIState()</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// initProcessStartTime hasn&#x27;t been set yet.</span></span><br><span class="line">				s.Pid = p.cmd.Process.Pid</span><br><span class="line">				s.Status = <span class="string">&quot;creating&quot;</span></span><br><span class="line">				<span class="keyword">for</span> i, hook := <span class="keyword">range</span> p.config.Config.Hooks.Prestart &#123;</span><br><span class="line">					<span class="keyword">if</span> err := hook.Run(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> newSystemErrorWithCausef(err, <span class="string">&quot;running prestart hook %d&quot;</span>, i)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Sync with child.</span></span><br><span class="line">			<span class="keyword">if</span> err := writeSync(p.messageSockPair.parent, procResume); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;writing syncT &#x27;resume&#x27;&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			sentResume = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> newSystemError(fmt.Errorf(<span class="string">&quot;invalid JSON payload from child&quot;</span>))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !sentRun &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(ierr, <span class="string">&quot;container init&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.config.Config.Namespaces.Contains(configs.NEWNS) &amp;&amp; !sentResume &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemError(fmt.Errorf(<span class="string">&quot;could not synchronise after executing prestart hooks with container process&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := unix.Shutdown(<span class="type">int</span>(p.messageSockPair.parent.Fd()), unix.SHUT_WR); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;shutting down init pipe&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Must be done after Shutdown so the child will exit and we can wait for it.</span></span><br><span class="line">	<span class="keyword">if</span> ierr != <span class="literal">nil</span> &#123;</span><br><span class="line">		p.wait()</span><br><span class="line">		<span class="keyword">return</span> ierr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行到这里也就是 <code>runc create</code> 要返回了，但是子进程的 <code>runc init</code> 因为父进程的退出被 <code>1</code> 号进程接管。</p>
<h2 id="runc-init"><a href="#runc-init" class="headerlink" title="runc init"></a>runc init</h2><p>这个就是 <code>contianer</code> 启动的时候<code>swap</code>前的进程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartInitialization loads a container by opening the pipe fd from the parent to read the configuration and state</span></span><br><span class="line"><span class="comment">// This is a low level implementation detail of the reexec and should not be consumed externally</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LinuxFactory)</span></span> StartInitialization() (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		pipefd, fifofd <span class="type">int</span></span><br><span class="line">		consoleSocket  *os.File</span><br><span class="line">		envInitPipe    = os.Getenv(<span class="string">&quot;_LIBCONTAINER_INITPIPE&quot;</span>)</span><br><span class="line">		envFifoFd      = os.Getenv(<span class="string">&quot;_LIBCONTAINER_FIFOFD&quot;</span>)</span><br><span class="line">		envConsole     = os.Getenv(<span class="string">&quot;_LIBCONTAINER_CONSOLE&quot;</span>)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the INITPIPE.</span></span><br><span class="line">	pipefd, err = strconv.Atoi(envInitPipe)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to convert _LIBCONTAINER_INITPIPE=%s to int: %s&quot;</span>, envInitPipe, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		pipe = os.NewFile(<span class="type">uintptr</span>(pipefd), <span class="string">&quot;pipe&quot;</span>)</span><br><span class="line">		it   = initType(os.Getenv(<span class="string">&quot;_LIBCONTAINER_INITTYPE&quot;</span>))</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">defer</span> pipe.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Only init processes have FIFOFD.</span></span><br><span class="line">	fifofd = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">if</span> it == initStandard &#123;</span><br><span class="line">		<span class="keyword">if</span> fifofd, err = strconv.Atoi(envFifoFd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to convert _LIBCONTAINER_FIFOFD=%s to int: %s&quot;</span>, envFifoFd, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> envConsole != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		console, err := strconv.Atoi(envConsole)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to convert _LIBCONTAINER_CONSOLE=%s to int: %s&quot;</span>, envConsole, err)</span><br><span class="line">		&#125;</span><br><span class="line">		consoleSocket = os.NewFile(<span class="type">uintptr</span>(console), <span class="string">&quot;console-socket&quot;</span>)</span><br><span class="line">		<span class="keyword">defer</span> consoleSocket.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// clear the current process&#x27;s environment to clean any libcontainer</span></span><br><span class="line">	<span class="comment">// specific env vars.</span></span><br><span class="line">	os.Clearenv()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// We have an error during the initialization of the container&#x27;s init,</span></span><br><span class="line">		<span class="comment">// send it back to the parent process in the form of an initError.</span></span><br><span class="line">		<span class="keyword">if</span> werr := utils.WriteJSON(pipe, syncT&#123;procError&#125;); werr != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> werr := utils.WriteJSON(pipe, newSystemError(err)); werr != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintln(os.Stderr, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;panic from initialization: %v, %v&quot;</span>, e, <span class="type">string</span>(debug.Stack()))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	i, err := newContainerInit(it, pipe, consoleSocket, fifofd)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If Init succeeds, syscall.Exec will not return, hence none of the defers will be called.</span></span><br><span class="line">	<span class="keyword">return</span> i.Init()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newContainerInit()</code>整体逻辑也比较简单</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newContainerInit</span><span class="params">(t initType, pipe *os.File, consoleSocket *os.File, fifoFd <span class="type">int</span>)</span></span> (initer, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> config *initConfig</span><br><span class="line">	<span class="keyword">if</span> err := json.NewDecoder(pipe).Decode(&amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := populateProcessEnvironment(config.Env); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> t &#123;</span><br><span class="line">	<span class="keyword">case</span> initSetns:</span><br><span class="line">		<span class="keyword">return</span> &amp;linuxSetnsInit&#123;</span><br><span class="line">			pipe:          pipe,</span><br><span class="line">			consoleSocket: consoleSocket,</span><br><span class="line">			config:        config,</span><br><span class="line">		&#125;, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> initStandard:</span><br><span class="line">		<span class="keyword">return</span> &amp;linuxStandardInit&#123;</span><br><span class="line">			pipe:          pipe,</span><br><span class="line">			consoleSocket: consoleSocket,</span><br><span class="line">			parentPid:     unix.Getppid(),</span><br><span class="line">			config:        config,</span><br><span class="line">			fifoFd:        fifoFd,</span><br><span class="line">		&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unknown init type %q&quot;</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你运行 <code>runc crate</code> 这个时候的 <code>init</code> 是调用就是 <code>linuxStandardInit</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *linuxStandardInit)</span></span> Init() <span class="type">error</span> &#123;</span><br><span class="line">	runtime.LockOSThread()</span><br><span class="line">	<span class="keyword">defer</span> runtime.UnlockOSThread()</span><br><span class="line">....	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := setupNetwork(l.config); err != <span class="literal">nil</span> &#123; <span class="comment">// 根据 config 使用 netlink 进行配置</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := setupRoute(l.config.Config); err != <span class="literal">nil</span> &#123; <span class="comment">// 使用 netlink 设置 route -</span></span><br><span class="line">	<span class="comment">// signal, so we restore it here.</span></span><br><span class="line">	<span class="keyword">if</span> err := pdeath.Restore(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;restore pdeath signal&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Compare the parent from the initial start of the init process and make</span></span><br><span class="line">	<span class="comment">// sure that it did not change.  if the parent changes that means it died</span></span><br><span class="line">	<span class="comment">// and we were reparented to something else so we should just kill ourself</span></span><br><span class="line">	<span class="comment">// and not cause problems for someone else.</span></span><br><span class="line">	<span class="keyword">if</span> unix.Getppid() != l.parentPid &#123;</span><br><span class="line">		<span class="keyword">return</span> unix.Kill(unix.Getpid(), unix.SIGKILL)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Check for the arg before waiting to make sure it exists and it is</span></span><br><span class="line">	<span class="comment">// returned as a create time error.</span></span><br><span class="line">	name, err := exec.LookPath(l.config.Args[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Close the pipe to signal that we have completed our init.</span></span><br><span class="line">	l.pipe.Close()</span><br><span class="line">	<span class="comment">// Wait for the FIFO to be opened on the other side before exec-ing the</span></span><br><span class="line">	<span class="comment">// user process. We open it through /proc/self/fd/$fd, because the fd that</span></span><br><span class="line">	<span class="comment">// was given to us was an O_PATH fd to the fifo itself. Linux allows us to</span></span><br><span class="line">	<span class="comment">// re-open an O_PATH fd through /proc.</span></span><br><span class="line">  <span class="comment">// 看一下注释，这里利用了 fifo 的特点，等待 runc start 来开这个 fifo</span></span><br><span class="line">	fd, err := unix.Open(fmt.Sprintf(<span class="string">&quot;/proc/self/fd/%d&quot;</span>, l.fifoFd), unix.O_WRONLY|unix.O_CLOEXEC, <span class="number">0</span>) <span class="comment">// 一起准备就绪过后他就会 hang 在这里</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;open exec fifo&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, err := unix.Write(fd, []<span class="type">byte</span>(<span class="string">&quot;0&quot;</span>)); err != <span class="literal">nil</span> &#123; <span class="comment">// 当用户调用 runc start 打开 fifo，就会执行到这里</span></span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;write 0 exec fifo&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Close the O_PATH fifofd fd before exec because the kernel resets</span></span><br><span class="line">	<span class="comment">// dumpable in the wrong order. This has been fixed in newer kernels, but</span></span><br><span class="line">	<span class="comment">// we keep this to ensure CVE-2016-9962 doesn&#x27;t re-emerge on older kernels.</span></span><br><span class="line">	<span class="comment">// N.B. the core issue itself (passing dirfds to the host filesystem) has</span></span><br><span class="line">	<span class="comment">// since been resolved.</span></span><br><span class="line">	<span class="comment">// https://github.com/torvalds/linux/blob/v4.9/fs/exec.c#L1290-L1318</span></span><br><span class="line">	unix.Close(l.fifoFd)</span><br><span class="line">	<span class="comment">// Set seccomp as close to execve as possible, so as few syscalls take</span></span><br><span class="line">	<span class="comment">// place afterward (reducing the amount of syscalls that users need to</span></span><br><span class="line">	<span class="comment">// enable in their seccomp profiles).</span></span><br><span class="line">	<span class="keyword">if</span> l.config.Config.Seccomp != <span class="literal">nil</span> &amp;&amp; l.config.NoNewPrivileges &#123;</span><br><span class="line">		<span class="keyword">if</span> err := seccomp.InitSeccomp(l.config.Config.Seccomp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;init seccomp&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := syscall.Exec(name, l.config.Args[<span class="number">0</span>:], os.Environ()); err != <span class="literal">nil</span> &#123; <span class="comment">// 这里 swap 用户的进程了</span></span><br><span class="line">		<span class="keyword">return</span> newSystemErrorWithCause(err, <span class="string">&quot;exec user process&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="runc-start"><a href="#runc-start" class="headerlink" title="runc start"></a>runc start</h2><p>其实 <code>runc start</code> 的逻辑更简单，仅仅是通过 <code>fifo</code> 和 <code>runc init</code>进程沟通，让他继续执行用户进程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> startCommand = cli.Command&#123;</span><br><span class="line">	Name:  <span class="string">&quot;start&quot;</span>,</span><br><span class="line">...</span><br><span class="line">		container, err := getContainer(context)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		status, err := container.Status()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> status &#123;</span><br><span class="line">		<span class="keyword">case</span> libcontainer.Created:</span><br><span class="line">			<span class="keyword">return</span> container.Exec()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> Exec() <span class="type">error</span> &#123;</span><br><span class="line">	c.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.m.Unlock()</span><br><span class="line">	<span class="keyword">return</span> c.exec()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开子进程的<code>fifo.exec</code> 文件，子进程就能继续执行下去了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *linuxContainer)</span></span> exec() <span class="type">error</span> &#123;</span><br><span class="line">	path := filepath.Join(c.root, execFifoFilename)</span><br><span class="line">	pid := c.initProcess.pid()</span><br><span class="line">	blockingFifoOpenCh := awaitFifoOpen(path)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> result := &lt;-blockingFifoOpenCh:</span><br><span class="line">			<span class="keyword">return</span> handleFifoResult(result)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">100</span>):</span><br><span class="line">			stat, err := system.Stat(pid)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> || stat.State == system.Zombie &#123;</span><br><span class="line">				<span class="comment">// could be because process started, ran, and completed between our 100ms timeout and our system.Stat() check.</span></span><br><span class="line">				<span class="comment">// see if the fifo exists and has data (with a non-blocking open, which will succeed if the writing process is complete).</span></span><br><span class="line">				<span class="keyword">if</span> err := handleFifoResult(fifoOpen(path, <span class="literal">false</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> errors.New(<span class="string">&quot;container process is already dead&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleFifoResult</span><span class="params">(result openResult)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> result.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result.err</span><br><span class="line">	&#125;</span><br><span class="line">	f := result.file</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="keyword">if</span> err := readFromExecFifo(f); err != <span class="literal">nil</span> &#123; <span class="comment">//</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> os.Remove(f.Name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFromExecFifo</span><span class="params">(execFifo io.Reader)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	data, err := ioutil.ReadAll(execFifo)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(data) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot start an already running container&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开 <code>fifo</code>，如果 <code>data</code> 小于 0 说明这个  <code>fifo</code> 里面 0 已经被读完了，也就是 running 的。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a target="_blank" rel="noopener" href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/">container-runtime-interface-cri-in-kubernetes&#x2F;</a></p>



<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>License</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">Newer</div><a href="/2021/01/06/kubelet-use-cotnainerd/">kubelet 是如何使用 containerd</a></div><div class="item" id="next"><div class="note">Older</div><a href="/2020/08/10/aws-nlb-full-nat/">aws nlb 使用 full nat 遇到的 tcp rest 问题</a></div></section></div>






  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      Join the discussion
    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" data-repo="sn0rt/sn0rt.github.io" data-repo-id="R_kgDOJhu0tg" data-category="General" data-category-id="DIC_kwDOJhu0ts4CWai7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期</a><a href="/tags">标签</a><a href="/archives">归档</a></div><div class="sitemap-group"><span class="fs14">项目</span><a href="/wiki">开源库</a></div><div class="sitemap-group"><span class="fs14">社交</span><a href="/friends">友链</a><a href="/about">留言板</a></div><div class="sitemap-group"><span class="fs14">更多</span><a href="/about">关于本站</a><a target="_blank" rel="noopener" href="https://github.com/Sn0rt">GitHub</a></div></div><div class="text"><p>本站由 <a href="/">@sn0rt</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.19.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0';
  stellar.config = {
    date_suffix: {
      just: 'Just',
      min: 'minutes ago',
      hour: 'hours ago',
      day: 'days ago',
      month: 'months ago',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadJS() {
    const els = document.querySelectorAll("#comments #giscus");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://giscus.app/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    loadJS();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
